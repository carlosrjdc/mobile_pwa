"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/recebimento/[id]/page",{

/***/ "(app-pages-browser)/./node_modules/lucide-react/dist/esm/icons/arrow-left.js":
/*!****************************************************************!*\
  !*** ./node_modules/lucide-react/dist/esm/icons/arrow-left.js ***!
  \****************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": function() { return /* binding */ ArrowLeft; }\n/* harmony export */ });\n/* harmony import */ var _createLucideIcon_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../createLucideIcon.js */ \"(app-pages-browser)/./node_modules/lucide-react/dist/esm/createLucideIcon.js\");\n/**\n * @license lucide-react v0.320.0 - ISC\n *\n * This source code is licensed under the ISC license.\n * See the LICENSE file in the root directory of this source tree.\n */ \nconst ArrowLeft = (0,_createLucideIcon_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(\"ArrowLeft\", [\n    [\n        \"path\",\n        {\n            d: \"m12 19-7-7 7-7\",\n            key: \"1l729n\"\n        }\n    ],\n    [\n        \"path\",\n        {\n            d: \"M19 12H5\",\n            key: \"x3x0zl\"\n        }\n    ]\n]);\n //# sourceMappingURL=arrow-left.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9sdWNpZGUtcmVhY3QvZGlzdC9lc20vaWNvbnMvYXJyb3ctbGVmdC5qcyIsIm1hcHBpbmdzIjoiOzs7OztBQUFBOzs7OztDQUtDLEdBRXFEO0FBRXRELE1BQU1DLFlBQVlELGdFQUFnQkEsQ0FBQyxhQUFhO0lBQzlDO1FBQUM7UUFBUTtZQUFFRSxHQUFHO1lBQWtCQyxLQUFLO1FBQVM7S0FBRTtJQUNoRDtRQUFDO1FBQVE7WUFBRUQsR0FBRztZQUFZQyxLQUFLO1FBQVM7S0FBRTtDQUMzQztBQUUrQixDQUNoQyxzQ0FBc0MiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL2x1Y2lkZS1yZWFjdC9kaXN0L2VzbS9pY29ucy9hcnJvdy1sZWZ0LmpzPzQ0ODAiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBAbGljZW5zZSBsdWNpZGUtcmVhY3QgdjAuMzIwLjAgLSBJU0NcbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBJU0MgbGljZW5zZS5cbiAqIFNlZSB0aGUgTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICovXG5cbmltcG9ydCBjcmVhdGVMdWNpZGVJY29uIGZyb20gJy4uL2NyZWF0ZUx1Y2lkZUljb24uanMnO1xuXG5jb25zdCBBcnJvd0xlZnQgPSBjcmVhdGVMdWNpZGVJY29uKFwiQXJyb3dMZWZ0XCIsIFtcbiAgW1wicGF0aFwiLCB7IGQ6IFwibTEyIDE5LTctNyA3LTdcIiwga2V5OiBcIjFsNzI5blwiIH1dLFxuICBbXCJwYXRoXCIsIHsgZDogXCJNMTkgMTJINVwiLCBrZXk6IFwieDN4MHpsXCIgfV1cbl0pO1xuXG5leHBvcnQgeyBBcnJvd0xlZnQgYXMgZGVmYXVsdCB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9YXJyb3ctbGVmdC5qcy5tYXBcbiJdLCJuYW1lcyI6WyJjcmVhdGVMdWNpZGVJY29uIiwiQXJyb3dMZWZ0IiwiZCIsImtleSIsImRlZmF1bHQiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/lucide-react/dist/esm/icons/arrow-left.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/lucide-react/dist/esm/icons/arrow-right.js":
/*!*****************************************************************!*\
  !*** ./node_modules/lucide-react/dist/esm/icons/arrow-right.js ***!
  \*****************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": function() { return /* binding */ ArrowRight; }\n/* harmony export */ });\n/* harmony import */ var _createLucideIcon_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../createLucideIcon.js */ \"(app-pages-browser)/./node_modules/lucide-react/dist/esm/createLucideIcon.js\");\n/**\n * @license lucide-react v0.320.0 - ISC\n *\n * This source code is licensed under the ISC license.\n * See the LICENSE file in the root directory of this source tree.\n */ \nconst ArrowRight = (0,_createLucideIcon_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(\"ArrowRight\", [\n    [\n        \"path\",\n        {\n            d: \"M5 12h14\",\n            key: \"1ays0h\"\n        }\n    ],\n    [\n        \"path\",\n        {\n            d: \"m12 5 7 7-7 7\",\n            key: \"xquz4c\"\n        }\n    ]\n]);\n //# sourceMappingURL=arrow-right.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9sdWNpZGUtcmVhY3QvZGlzdC9lc20vaWNvbnMvYXJyb3ctcmlnaHQuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7QUFBQTs7Ozs7Q0FLQyxHQUVxRDtBQUV0RCxNQUFNQyxhQUFhRCxnRUFBZ0JBLENBQUMsY0FBYztJQUNoRDtRQUFDO1FBQVE7WUFBRUUsR0FBRztZQUFZQyxLQUFLO1FBQVM7S0FBRTtJQUMxQztRQUFDO1FBQVE7WUFBRUQsR0FBRztZQUFpQkMsS0FBSztRQUFTO0tBQUU7Q0FDaEQ7QUFFZ0MsQ0FDakMsdUNBQXVDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9sdWNpZGUtcmVhY3QvZGlzdC9lc20vaWNvbnMvYXJyb3ctcmlnaHQuanM/YTcwMiJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEBsaWNlbnNlIGx1Y2lkZS1yZWFjdCB2MC4zMjAuMCAtIElTQ1xuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIElTQyBsaWNlbnNlLlxuICogU2VlIHRoZSBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKi9cblxuaW1wb3J0IGNyZWF0ZUx1Y2lkZUljb24gZnJvbSAnLi4vY3JlYXRlTHVjaWRlSWNvbi5qcyc7XG5cbmNvbnN0IEFycm93UmlnaHQgPSBjcmVhdGVMdWNpZGVJY29uKFwiQXJyb3dSaWdodFwiLCBbXG4gIFtcInBhdGhcIiwgeyBkOiBcIk01IDEyaDE0XCIsIGtleTogXCIxYXlzMGhcIiB9XSxcbiAgW1wicGF0aFwiLCB7IGQ6IFwibTEyIDUgNyA3LTcgN1wiLCBrZXk6IFwieHF1ejRjXCIgfV1cbl0pO1xuXG5leHBvcnQgeyBBcnJvd1JpZ2h0IGFzIGRlZmF1bHQgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWFycm93LXJpZ2h0LmpzLm1hcFxuIl0sIm5hbWVzIjpbImNyZWF0ZUx1Y2lkZUljb24iLCJBcnJvd1JpZ2h0IiwiZCIsImtleSIsImRlZmF1bHQiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/lucide-react/dist/esm/icons/arrow-right.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./src/components/ui/carousel.tsx":
/*!****************************************!*\
  !*** ./src/components/ui/carousel.tsx ***!
  \****************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Carousel: function() { return /* binding */ Carousel; },\n/* harmony export */   CarouselContent: function() { return /* binding */ CarouselContent; },\n/* harmony export */   CarouselItem: function() { return /* binding */ CarouselItem; },\n/* harmony export */   CarouselNext: function() { return /* binding */ CarouselNext; },\n/* harmony export */   CarouselPrevious: function() { return /* binding */ CarouselPrevious; }\n/* harmony export */ });\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/jsx-dev-runtime.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var embla_carousel_react__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! embla-carousel-react */ \"(app-pages-browser)/./node_modules/embla-carousel-react/esm/embla-carousel-react.esm.js\");\n/* harmony import */ var _barrel_optimize_names_ArrowLeft_ArrowRight_lucide_react__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! __barrel_optimize__?names=ArrowLeft,ArrowRight!=!lucide-react */ \"(app-pages-browser)/./node_modules/lucide-react/dist/esm/icons/arrow-left.js\");\n/* harmony import */ var _barrel_optimize_names_ArrowLeft_ArrowRight_lucide_react__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! __barrel_optimize__?names=ArrowLeft,ArrowRight!=!lucide-react */ \"(app-pages-browser)/./node_modules/lucide-react/dist/esm/icons/arrow-right.js\");\n/* harmony import */ var _lib_utils__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @/lib/utils */ \"(app-pages-browser)/./src/lib/utils.ts\");\n/* harmony import */ var _components_ui_button__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @/components/ui/button */ \"(app-pages-browser)/./src/components/ui/button.tsx\");\n/* __next_internal_client_entry_do_not_use__ Carousel,CarouselContent,CarouselItem,CarouselPrevious,CarouselNext auto */ \nvar _s = $RefreshSig$(), _s1 = $RefreshSig$(), _s2 = $RefreshSig$(), _s3 = $RefreshSig$(), _s4 = $RefreshSig$(), _s5 = $RefreshSig$();\n\n\n\n\n\nconst CarouselContext = /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_1__.createContext(null);\nfunction useCarousel() {\n    _s();\n    const context = react__WEBPACK_IMPORTED_MODULE_1__.useContext(CarouselContext);\n    if (!context) {\n        throw new Error(\"useCarousel must be used within a <Carousel />\");\n    }\n    return context;\n}\n_s(useCarousel, \"b9L3QQ+jgeyIrH0NfHrJ8nn7VMU=\");\nconst Carousel = /*#__PURE__*/ _s1(react__WEBPACK_IMPORTED_MODULE_1__.forwardRef(_c = _s1((param, ref)=>{\n    let { orientation = \"horizontal\", opts, setApi, plugins, className, children, ...props } = param;\n    _s1();\n    const [carouselRef, api] = (0,embla_carousel_react__WEBPACK_IMPORTED_MODULE_4__[\"default\"])({\n        ...opts,\n        axis: orientation === \"horizontal\" ? \"x\" : \"y\"\n    }, plugins);\n    const [canScrollPrev, setCanScrollPrev] = react__WEBPACK_IMPORTED_MODULE_1__.useState(false);\n    const [canScrollNext, setCanScrollNext] = react__WEBPACK_IMPORTED_MODULE_1__.useState(false);\n    const onSelect = react__WEBPACK_IMPORTED_MODULE_1__.useCallback((api)=>{\n        if (!api) {\n            return;\n        }\n        setCanScrollPrev(api.canScrollPrev());\n        setCanScrollNext(api.canScrollNext());\n    }, []);\n    const scrollPrev = react__WEBPACK_IMPORTED_MODULE_1__.useCallback(()=>{\n        api === null || api === void 0 ? void 0 : api.scrollPrev();\n    }, [\n        api\n    ]);\n    const scrollNext = react__WEBPACK_IMPORTED_MODULE_1__.useCallback(()=>{\n        api === null || api === void 0 ? void 0 : api.scrollNext();\n    }, [\n        api\n    ]);\n    const handleKeyDown = react__WEBPACK_IMPORTED_MODULE_1__.useCallback((event)=>{\n        if (event.key === \"ArrowLeft\") {\n            event.preventDefault();\n            scrollPrev();\n        } else if (event.key === \"ArrowRight\") {\n            event.preventDefault();\n            scrollNext();\n        }\n    }, [\n        scrollPrev,\n        scrollNext\n    ]);\n    react__WEBPACK_IMPORTED_MODULE_1__.useEffect(()=>{\n        if (!api || !setApi) {\n            return;\n        }\n        setApi(api);\n    }, [\n        api,\n        setApi\n    ]);\n    react__WEBPACK_IMPORTED_MODULE_1__.useEffect(()=>{\n        if (!api) {\n            return;\n        }\n        onSelect(api);\n        api.on(\"reInit\", onSelect);\n        api.on(\"select\", onSelect);\n        return ()=>{\n            api === null || api === void 0 ? void 0 : api.off(\"select\", onSelect);\n        };\n    }, [\n        api,\n        onSelect\n    ]);\n    return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(CarouselContext.Provider, {\n        value: {\n            carouselRef,\n            api: api,\n            opts,\n            orientation: orientation || ((opts === null || opts === void 0 ? void 0 : opts.axis) === \"y\" ? \"vertical\" : \"horizontal\"),\n            scrollPrev,\n            scrollNext,\n            canScrollPrev,\n            canScrollNext\n        },\n        children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n            ref: ref,\n            onKeyDownCapture: handleKeyDown,\n            className: (0,_lib_utils__WEBPACK_IMPORTED_MODULE_2__.cn)(\"relative\", className),\n            role: \"region\",\n            \"aria-roledescription\": \"carousel\",\n            ...props,\n            children: children\n        }, void 0, false, {\n            fileName: \"/Users/carlos/Documents/carlos/WMS/front/pwa/src/components/ui/carousel.tsx\",\n            lineNumber: 137,\n            columnNumber: 9\n        }, undefined)\n    }, void 0, false, {\n        fileName: \"/Users/carlos/Documents/carlos/WMS/front/pwa/src/components/ui/carousel.tsx\",\n        lineNumber: 124,\n        columnNumber: 7\n    }, undefined);\n}, \"72w3/pym1wz2ZcTGqySg56b8KiQ=\", false, function() {\n    return [\n        embla_carousel_react__WEBPACK_IMPORTED_MODULE_4__[\"default\"]\n    ];\n})), \"72w3/pym1wz2ZcTGqySg56b8KiQ=\", false, function() {\n    return [\n        embla_carousel_react__WEBPACK_IMPORTED_MODULE_4__[\"default\"]\n    ];\n});\n_c1 = Carousel;\nCarousel.displayName = \"Carousel\";\nconst CarouselContent = /*#__PURE__*/ _s2(react__WEBPACK_IMPORTED_MODULE_1__.forwardRef(_c2 = _s2((param, ref)=>{\n    let { className, ...props } = param;\n    _s2();\n    const { carouselRef, orientation } = useCarousel();\n    return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n        ref: carouselRef,\n        className: \"overflow-hidden\",\n        children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n            ref: ref,\n            className: (0,_lib_utils__WEBPACK_IMPORTED_MODULE_2__.cn)(\"flex\", orientation === \"horizontal\" ? \"-ml-4\" : \"-mt-4 flex-col\", className),\n            ...props\n        }, void 0, false, {\n            fileName: \"/Users/carlos/Documents/carlos/WMS/front/pwa/src/components/ui/carousel.tsx\",\n            lineNumber: 161,\n            columnNumber: 7\n        }, undefined)\n    }, void 0, false, {\n        fileName: \"/Users/carlos/Documents/carlos/WMS/front/pwa/src/components/ui/carousel.tsx\",\n        lineNumber: 160,\n        columnNumber: 5\n    }, undefined);\n}, \"YNqN7/p8l2NfYueiPechI4IqsYo=\", false, function() {\n    return [\n        useCarousel\n    ];\n})), \"YNqN7/p8l2NfYueiPechI4IqsYo=\", false, function() {\n    return [\n        useCarousel\n    ];\n});\n_c3 = CarouselContent;\nCarouselContent.displayName = \"CarouselContent\";\nconst CarouselItem = /*#__PURE__*/ _s3(react__WEBPACK_IMPORTED_MODULE_1__.forwardRef(_c4 = _s3((param, ref)=>{\n    let { className, ...props } = param;\n    _s3();\n    const { orientation } = useCarousel();\n    return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n        ref: ref,\n        role: \"group\",\n        \"aria-roledescription\": \"slide\",\n        className: (0,_lib_utils__WEBPACK_IMPORTED_MODULE_2__.cn)(\"min-w-0 shrink-0 grow-0 basis-full\", orientation === \"horizontal\" ? \"pl-4\" : \"pt-4\", className),\n        ...props\n    }, void 0, false, {\n        fileName: \"/Users/carlos/Documents/carlos/WMS/front/pwa/src/components/ui/carousel.tsx\",\n        lineNumber: 182,\n        columnNumber: 5\n    }, undefined);\n}, \"bPPpMbUdjWnfcwMzP4altEp5ZJs=\", false, function() {\n    return [\n        useCarousel\n    ];\n})), \"bPPpMbUdjWnfcwMzP4altEp5ZJs=\", false, function() {\n    return [\n        useCarousel\n    ];\n});\n_c5 = CarouselItem;\nCarouselItem.displayName = \"CarouselItem\";\nconst CarouselPrevious = /*#__PURE__*/ _s4(react__WEBPACK_IMPORTED_MODULE_1__.forwardRef(_c6 = _s4((param, ref)=>{\n    let { className, variant = \"outline\", size = \"icon\", ...props } = param;\n    _s4();\n    const { orientation, scrollPrev, canScrollPrev } = useCarousel();\n    return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_components_ui_button__WEBPACK_IMPORTED_MODULE_3__.Button, {\n        ref: ref,\n        variant: variant,\n        size: size,\n        className: (0,_lib_utils__WEBPACK_IMPORTED_MODULE_2__.cn)(\"absolute  h-8 w-8 rounded-full\", orientation === \"horizontal\" ? \"-left-12 top-1/2 -translate-y-1/2\" : \"-top-12 left-1/2 -translate-x-1/2 rotate-90\", className),\n        disabled: !canScrollPrev,\n        onClick: scrollPrev,\n        ...props,\n        children: [\n            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_barrel_optimize_names_ArrowLeft_ArrowRight_lucide_react__WEBPACK_IMPORTED_MODULE_5__[\"default\"], {\n                className: \"h-4 w-4\"\n            }, void 0, false, {\n                fileName: \"/Users/carlos/Documents/carlos/WMS/front/pwa/src/components/ui/carousel.tsx\",\n                lineNumber: 219,\n                columnNumber: 7\n            }, undefined),\n            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"span\", {\n                className: \"sr-only\",\n                children: \"Previous slide\"\n            }, void 0, false, {\n                fileName: \"/Users/carlos/Documents/carlos/WMS/front/pwa/src/components/ui/carousel.tsx\",\n                lineNumber: 220,\n                columnNumber: 7\n            }, undefined)\n        ]\n    }, void 0, true, {\n        fileName: \"/Users/carlos/Documents/carlos/WMS/front/pwa/src/components/ui/carousel.tsx\",\n        lineNumber: 204,\n        columnNumber: 5\n    }, undefined);\n}, \"StVzzFT/dKvE6v0nHx014nh7DNA=\", false, function() {\n    return [\n        useCarousel\n    ];\n})), \"StVzzFT/dKvE6v0nHx014nh7DNA=\", false, function() {\n    return [\n        useCarousel\n    ];\n});\n_c7 = CarouselPrevious;\nCarouselPrevious.displayName = \"CarouselPrevious\";\nconst CarouselNext = /*#__PURE__*/ _s5(react__WEBPACK_IMPORTED_MODULE_1__.forwardRef(_c8 = _s5((param, ref)=>{\n    let { className, variant = \"outline\", size = \"icon\", ...props } = param;\n    _s5();\n    const { orientation, scrollNext, canScrollNext } = useCarousel();\n    return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_components_ui_button__WEBPACK_IMPORTED_MODULE_3__.Button, {\n        ref: ref,\n        variant: variant,\n        size: size,\n        className: (0,_lib_utils__WEBPACK_IMPORTED_MODULE_2__.cn)(\"absolute h-8 w-8 rounded-full\", orientation === \"horizontal\" ? \"-right-12 top-1/2 -translate-y-1/2\" : \"-bottom-12 left-1/2 -translate-x-1/2 rotate-90\", className),\n        disabled: !canScrollNext,\n        onClick: scrollNext,\n        ...props,\n        children: [\n            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_barrel_optimize_names_ArrowLeft_ArrowRight_lucide_react__WEBPACK_IMPORTED_MODULE_6__[\"default\"], {\n                className: \"h-4 w-4\"\n            }, void 0, false, {\n                fileName: \"/Users/carlos/Documents/carlos/WMS/front/pwa/src/components/ui/carousel.tsx\",\n                lineNumber: 248,\n                columnNumber: 7\n            }, undefined),\n            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"span\", {\n                className: \"sr-only\",\n                children: \"Next slide\"\n            }, void 0, false, {\n                fileName: \"/Users/carlos/Documents/carlos/WMS/front/pwa/src/components/ui/carousel.tsx\",\n                lineNumber: 249,\n                columnNumber: 7\n            }, undefined)\n        ]\n    }, void 0, true, {\n        fileName: \"/Users/carlos/Documents/carlos/WMS/front/pwa/src/components/ui/carousel.tsx\",\n        lineNumber: 233,\n        columnNumber: 5\n    }, undefined);\n}, \"VthXVrvg+0LPsG5FRGeAaBGswm4=\", false, function() {\n    return [\n        useCarousel\n    ];\n})), \"VthXVrvg+0LPsG5FRGeAaBGswm4=\", false, function() {\n    return [\n        useCarousel\n    ];\n});\n_c9 = CarouselNext;\nCarouselNext.displayName = \"CarouselNext\";\n\nvar _c, _c1, _c2, _c3, _c4, _c5, _c6, _c7, _c8, _c9;\n$RefreshReg$(_c, \"Carousel$React.forwardRef\");\n$RefreshReg$(_c1, \"Carousel\");\n$RefreshReg$(_c2, \"CarouselContent$React.forwardRef\");\n$RefreshReg$(_c3, \"CarouselContent\");\n$RefreshReg$(_c4, \"CarouselItem$React.forwardRef\");\n$RefreshReg$(_c5, \"CarouselItem\");\n$RefreshReg$(_c6, \"CarouselPrevious$React.forwardRef\");\n$RefreshReg$(_c7, \"CarouselPrevious\");\n$RefreshReg$(_c8, \"CarouselNext$React.forwardRef\");\n$RefreshReg$(_c9, \"CarouselNext\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9jb21wb25lbnRzL3VpL2Nhcm91c2VsLnRzeCIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFFOEI7QUFHRDtBQUN1QjtBQUVwQjtBQUNlO0FBdUIvQyxNQUFNTSxnQ0FBa0JOLGdEQUFtQixDQUE4QjtBQUV6RSxTQUFTUTs7SUFDUCxNQUFNQyxVQUFVVCw2Q0FBZ0IsQ0FBQ007SUFFakMsSUFBSSxDQUFDRyxTQUFTO1FBQ1osTUFBTSxJQUFJRSxNQUFNO0lBQ2xCO0lBRUEsT0FBT0Y7QUFDVDtHQVJTRDtBQVVULE1BQU1JLHlCQUFXWixJQUFBQSw2Q0FBZ0IsVUFJL0IsUUFVRWM7UUFUQSxFQUNFQyxjQUFjLFlBQVksRUFDMUJDLElBQUksRUFDSkMsTUFBTSxFQUNOQyxPQUFPLEVBQ1BDLFNBQVMsRUFDVEMsUUFBUSxFQUNSLEdBQUdDLE9BQ0o7O0lBR0QsTUFBTSxDQUFDQyxhQUFhQyxJQUFJLEdBQUd0QixnRUFBZ0JBLENBQ3pDO1FBQ0UsR0FBR2UsSUFBSTtRQUNQUSxNQUFNVCxnQkFBZ0IsZUFBZSxNQUFNO0lBQzdDLEdBQ0FHO0lBRUYsTUFBTSxDQUFDTyxlQUFlQyxpQkFBaUIsR0FBRzFCLDJDQUFjLENBQUM7SUFDekQsTUFBTSxDQUFDNEIsZUFBZUMsaUJBQWlCLEdBQUc3QiwyQ0FBYyxDQUFDO0lBRXpELE1BQU04QixXQUFXOUIsOENBQWlCLENBQUMsQ0FBQ3VCO1FBQ2xDLElBQUksQ0FBQ0EsS0FBSztZQUNSO1FBQ0Y7UUFFQUcsaUJBQWlCSCxJQUFJRSxhQUFhO1FBQ2xDSSxpQkFBaUJOLElBQUlLLGFBQWE7SUFDcEMsR0FBRyxFQUFFO0lBRUwsTUFBTUksYUFBYWhDLDhDQUFpQixDQUFDO1FBQ25DdUIsZ0JBQUFBLDBCQUFBQSxJQUFLUyxVQUFVO0lBQ2pCLEdBQUc7UUFBQ1Q7S0FBSTtJQUVSLE1BQU1VLGFBQWFqQyw4Q0FBaUIsQ0FBQztRQUNuQ3VCLGdCQUFBQSwwQkFBQUEsSUFBS1Us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QUNBVyxnQkFBZ0IsZUFDWixzQ0FDQSwrQ0FDSkk7UUFFRmtDLFVBQVUsQ0FBQzVCO1FBQ1g2QixTQUFTdEI7UUFDUixHQUFHWCxLQUFLOzswQkFFVCw4REFBQ25CLGdHQUFTQTtnQkFBQ2lCLFdBQVU7Ozs7OzswQkFDckIsOERBQUNvQztnQkFBS3BDLFdBQVU7MEJBQVU7Ozs7Ozs7Ozs7OztBQUdoQzs7UUF0QnFEWDs7OztRQUFBQTs7OztBQXVCckQwQyxpQkFBaUJILFdBQVcsR0FBRztBQUUvQixNQUFNUyw2QkFBZXhELElBQUFBLDZDQUFnQixXQUduQyxRQUE4RGM7UUFBN0QsRUFBRUssU0FBUyxFQUFFZ0MsVUFBVSxTQUFTLEVBQUVDLE9BQU8sTUFBTSxFQUFFLEdBQUcvQixPQUFPOztJQUM1RCxNQUFNLEVBQUVOLFdBQVcsRUFBRWtCLFVBQVUsRUFBRUwsYUFBYSxFQUFFLEdBQUdwQjtJQUVuRCxxQkFDRSw4REFBQ0gseURBQU1BO1FBQ0xTLEtBQUtBO1FBQ0xxQyxTQUFTQTtRQUNUQyxNQUFNQTtRQUNOakMsV0FBV2YsOENBQUVBLENBQ1gsaUNBQ0FXLGdCQUFnQixlQUNaLHVDQUNBLGtEQUNKSTtRQUVGa0MsVUFBVSxDQUFDekI7UUFDWDBCLFNBQVNyQjtRQUNSLEdBQUdaLEtBQUs7OzBCQUVULDhEQUFDbEIsZ0dBQVVBO2dCQUFDZ0IsV0FBVTs7Ozs7OzBCQUN0Qiw4REFBQ29DO2dCQUFLcEMsV0FBVTswQkFBVTs7Ozs7Ozs7Ozs7O0FBR2hDOztRQXRCcURYOzs7O1FBQUFBOzs7O0FBdUJyRGdELGFBQWFULFdBQVcsR0FBRztBQVMxQiIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9zcmMvY29tcG9uZW50cy91aS9jYXJvdXNlbC50c3g/MTk2MCJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBjbGllbnRcIlxuXG5pbXBvcnQgKiBhcyBSZWFjdCBmcm9tIFwicmVhY3RcIlxuaW1wb3J0IHVzZUVtYmxhQ2Fyb3VzZWwsIHtcbiAgdHlwZSBVc2VFbWJsYUNhcm91c2VsVHlwZSxcbn0gZnJvbSBcImVtYmxhLWNhcm91c2VsLXJlYWN0XCJcbmltcG9ydCB7IEFycm93TGVmdCwgQXJyb3dSaWdodCB9IGZyb20gXCJsdWNpZGUtcmVhY3RcIlxuXG5pbXBvcnQgeyBjbiB9IGZyb20gXCJAL2xpYi91dGlsc1wiXG5pbXBvcnQgeyBCdXR0b24gfSBmcm9tIFwiQC9jb21wb25lbnRzL3VpL2J1dHRvblwiXG5cbnR5cGUgQ2Fyb3VzZWxBcGkgPSBVc2VFbWJsYUNhcm91c2VsVHlwZVsxXVxudHlwZSBVc2VDYXJvdXNlbFBhcmFtZXRlcnMgPSBQYXJhbWV0ZXJzPHR5cGVvZiB1c2VFbWJsYUNhcm91c2VsPlxudHlwZSBDYXJvdXNlbE9wdGlvbnMgPSBVc2VDYXJvdXNlbFBhcmFtZXRlcnNbMF1cbnR5cGUgQ2Fyb3VzZWxQbHVnaW4gPSBVc2VDYXJvdXNlbFBhcmFtZXRlcnNbMV1cblxudHlwZSBDYXJvdXNlbFByb3BzID0ge1xuICBvcHRzPzogQ2Fyb3VzZWxPcHRpb25zXG4gIHBsdWdpbnM/OiBDYXJvdXNlbFBsdWdpblxuICBvcmllbnRhdGlvbj86IFwiaG9yaXpvbnRhbFwiIHwgXCJ2ZXJ0aWNhbFwiXG4gIHNldEFwaT86IChhcGk6IENhcm91c2VsQXBpKSA9PiB2b2lkXG59XG5cbnR5cGUgQ2Fyb3VzZWxDb250ZXh0UHJvcHMgPSB7XG4gIGNhcm91c2VsUmVmOiBSZXR1cm5UeXBlPHR5cGVvZiB1c2VFbWJsYUNhcm91c2VsPlswXVxuICBhcGk6IFJldHVyblR5cGU8dHlwZW9mIHVzZUVtYmxhQ2Fyb3VzZWw+WzFdXG4gIHNjcm9sbFByZXY6ICgpID0+IHZvaWRcbiAgc2Nyb2xsTmV4dDogKCkgPT4gdm9pZFxuICBjYW5TY3JvbGxQcmV2OiBib29sZWFuXG4gIGNhblNjcm9sbE5leHQ6IGJvb2xlYW5cbn0gJiBDYXJvdXNlbFByb3BzXG5cbmNvbnN0IENhcm91c2VsQ29udGV4dCA9IFJlYWN0LmNyZWF0ZUNvbnRleHQ8Q2Fyb3VzZWxDb250ZXh0UHJvcHMgfCBudWxsPihudWxsKVxuXG5mdW5jdGlvbiB1c2VDYXJvdXNlbCgpIHtcbiAgY29uc3QgY29udGV4dCA9IFJlYWN0LnVzZUNvbnRleHQoQ2Fyb3VzZWxDb250ZXh0KVxuXG4gIGlmICghY29udGV4dCkge1xuICAgIHRocm93IG5ldyBFcnJvcihcInVzZUNhcm91c2VsIG11c3QgYmUgdXNlZCB3aXRoaW4gYSA8Q2Fyb3VzZWwgLz5cIilcbiAgfVxuXG4gIHJldHVybiBjb250ZXh0XG59XG5cbmNvbnN0IENhcm91c2VsID0gUmVhY3QuZm9yd2FyZFJlZjxcbiAgSFRNTERpdkVsZW1lbnQsXG4gIFJlYWN0LkhUTUxBdHRyaWJ1dGVzPEhUTUxEaXZFbGVtZW50PiAmIENhcm91c2VsUHJvcHNcbj4oXG4gIChcbiAgICB7XG4gICAgICBvcmllbnRhdGlvbiA9IFwiaG9yaXpvbnRhbFwiLFxuICAgICAgb3B0cyxcbiAgICAgIHNldEFwaSxcbiAgICAgIHBsdWdpbnMsXG4gICAgICBjbGFzc05hbWUsXG4gICAgICBjaGlsZHJlbixcbiAgICAgIC4uLnByb3BzXG4gICAgfSxcbiAgICByZWZcbiAgKSA9PiB7XG4gICAgY29uc3QgW2Nhcm91c2VsUmVmLCBhcGldID0gdXNlRW1ibGFDYXJvdXNlbChcbiAgICAgIHtcbiAgICAgICAgLi4ub3B0cyxcbiAgICAgICAgYXhpczogb3JpZW50YXRpb24gPT09IFwiaG9yaXpvbnRhbFwiID8gXCJ4XCIgOiBcInlcIixcbiAgICAgIH0sXG4gICAgICBwbHVnaW5zXG4gICAgKVxuICAgIGNvbnN0IFtjYW5TY3JvbGxQcmV2LCBzZXRDYW5TY3JvbGxQcmV2XSA9IFJlYWN0LnVzZVN0YXRlKGZhbHNlKVxuICAgIGNvbnN0IFtjYW5TY3JvbGxOZXh0LCBzZXRDYW5TY3JvbGxOZXh0XSA9IFJlYWN0LnVzZVN0YXRlKGZhbHNlKVxuXG4gICAgY29uc3Qgb25TZWxlY3QgPSBSZWFjdC51c2VDYWxsYmFjaygoYXBpOiBDYXJvdXNlbEFwaSkgPT4ge1xuICAgICAgaWYgKCFhcGkpIHtcbiAgICAgICAgcmV0dXJuXG4gICAgICB9XG5cbiAgICAgIHNldENhblNjcm9sbFByZXYoYXBpLmNhblNjcm9sbFByZXYoKSlcbiAgICAgIHNldENhblNjcm9sbE5leHQoYXBpLmNhblNjcm9sbE5leHQoKSlcbiAgICB9LCBbXSlcblxuICAgIGNvbnN0IHNjcm9sbFByZXYgPSBSZWFjdC51c2VDYWxsYmFjaygoKSA9PiB7XG4gICAgICBhcGk/LnNjcm9sbFByZXYoKVxuICAgIH0sIFthcGldKVxuXG4gICAgY29uc3Qgc2Nyb2xsTmV4dCA9IFJlYWN0LnVzZUNhbGxiYWNrKCgpID0+IHtcbiAgICAgIGFwaT8uc2Nyb2xsTmV4dCgpXG4gICAgfSwgW2FwaV0pXG5cbiAgICBjb25zdCBoYW5kbGVLZXlEb3duID0gUmVhY3QudXNlQ2FsbGJhY2soXG4gICAgICAoZXZlbnQ6IFJlYWN0LktleWJvYXJkRXZlbnQ8SFRNTERpdkVsZW1lbnQ+KSA9PiB7XG4gICAgICAgIGlmIChldmVudC5rZXkgPT09IFwiQXJyb3dMZWZ0XCIpIHtcbiAgICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpXG4gICAgICAgICAgc2Nyb2xsUHJldigpXG4gICAgICAgIH0gZWxzZSBpZiAoZXZlbnQua2V5ID09PSBcIkFycm93UmlnaHRcIikge1xuICAgICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KClcbiAgICAgICAgICBzY3JvbGxOZXh0KClcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIFtzY3JvbGxQcmV2LCBzY3JvbGxOZXh0XVxuICAgIClcblxuICAgIFJlYWN0LnVzZUVmZmVjdCgoKSA9PiB7XG4gICAgICBpZiAoIWFwaSB8fCAhc2V0QXBpKSB7XG4gICAgICAgIHJldHVyblxuICAgICAgfVxuXG4gICAgICBzZXRBcGkoYXBpKVxuICAgIH0sIFthcGksIHNldEFwaV0pXG5cbiAgICBSZWFjdC51c2VFZmZlY3QoKCkgPT4ge1xuICAgICAgaWYgKCFhcGkpIHtcbiAgICAgICAgcmV0dXJuXG4gICAgICB9XG5cbiAgICAgIG9uU2VsZWN0KGFwaSlcbiAgICAgIGFwaS5vbihcInJlSW5pdFwiLCBvblNlbGVjdClcbiAgICAgIGFwaS5vbihcInNlbGVjdFwiLCBvblNlbGVjdClcblxuICAgICAgcmV0dXJuICgpID0+IHtcbiAgICAgICAgYXBpPy5vZmYoXCJzZWxlY3RcIiwgb25TZWxlY3QpXG4gICAgICB9XG4gICAgfSwgW2FwaSwgb25TZWxlY3RdKVxuXG4gICAgcmV0dXJuIChcbiAgICAgIDxDYXJvdXNlbENvbnRleHQuUHJvdmlkZXJcbiAgICAgICAgdmFsdWU9e3tcbiAgICAgICAgICBjYXJvdXNlbFJlZixcbiAgICAgICAgICBhcGk6IGFwaSxcbiAgICAgICAgICBvcHRzLFxuICAgICAgICAgIG9yaWVudGF0aW9uOlxuICAgICAgICAgICAgb3JpZW50YXRpb24gfHwgKG9wdHM/LmF4aXMgPT09IFwieVwiID8gXCJ2ZXJ0aWNhbFwiIDogXCJob3Jpem9udGFsXCIpLFxuICAgICAgICAgIHNjcm9sbFByZXYsXG4gICAgICAgICAgc2Nyb2xsTmV4dCxcbiAgICAgICAgICBjYW5TY3JvbGxQcmV2LFxuICAgICAgICAgIGNhblNjcm9sbE5leHQsXG4gICAgICAgIH19XG4gICAgICA+XG4gICAgICAgIDxkaXZcbiAgICAgICAgICByZWY9e3JlZn1cbiAgICAgICAgICBvbktleURvd25DYXB0dXJlPXtoYW5kbGVLZXlEb3dufVxuICAgICAgICAgIGNsYXNzTmFtZT17Y24oXCJyZWxhdGl2ZVwiLCBjbGFzc05hbWUpfVxuICAgICAgICAgIHJvbGU9XCJyZWdpb25cIlxuICAgICAgICAgIGFyaWEtcm9sZWRlc2NyaXB0aW9uPVwiY2Fyb3VzZWxcIlxuICAgICAgICAgIHsuLi5wcm9wc31cbiAgICAgICAgPlxuICAgICAgICAgIHtjaGlsZHJlbn1cbiAgICAgICAgPC9kaXY+XG4gICAgICA8L0Nhcm91c2VsQ29udGV4dC5Qcm92aWRlcj5cbiAgICApXG4gIH1cbilcbkNhcm91c2VsLmRpc3BsYXlOYW1lID0gXCJDYXJvdXNlbFwiXG5cbmNvbnN0IENhcm91c2VsQ29udGVudCA9IFJlYWN0LmZvcndhcmRSZWY8XG4gIEhUTUxEaXZFbGVtZW50LFxuICBSZWFjdC5IVE1MQXR0cmlidXRlczxIVE1MRGl2RWxlbWVudD5cbj4oKHsgY2xhc3NOYW1lLCAuLi5wcm9wcyB9LCByZWYpID0+IHtcbiAgY29uc3QgeyBjYXJvdXNlbFJlZiwgb3JpZW50YXRpb24gfSA9IHVzZUNhcm91c2VsKClcblxuICByZXR1cm4gKFxuICAgIDxkaXYgcmVmPXtjYXJvdXNlbFJlZn0gY2xhc3NOYW1lPVwib3ZlcmZsb3ctaGlkZGVuXCI+XG4gICAgICA8ZGl2XG4gICAgICAgIHJlZj17cmVmfVxuICAgICAgICBjbGFzc05hbWU9e2NuKFxuICAgICAgICAgIFwiZmxleFwiLFxuICAgICAgICAgIG9yaWVudGF0aW9uID09PSBcImhvcml6b250YWxcIiA/IFwiLW1sLTRcIiA6IFwiLW10LTQgZmxleC1jb2xcIixcbiAgICAgICAgICBjbGFzc05hbWVcbiAgICAgICAgKX1cbiAgICAgICAgey4uLnByb3BzfVxuICAgICAgLz5cbiAgICA8L2Rpdj5cbiAgKVxufSlcbkNhcm91c2VsQ29udGVudC5kaXNwbGF5TmFtZSA9IFwiQ2Fyb3VzZWxDb250ZW50XCJcblxuY29uc3QgQ2Fyb3VzZWxJdGVtID0gUmVhY3QuZm9yd2FyZFJlZjxcbiAgSFRNTERpdkVsZW1lbnQsXG4gIFJlYWN0LkhUTUxBdHRyaWJ1dGVzPEhUTUxEaXZFbGVtZW50PlxuPigoeyBjbGFzc05hbWUsIC4uLnByb3BzIH0sIHJlZikgPT4ge1xuICBjb25zdCB7IG9yaWVudGF0aW9uIH0gPSB1c2VDYXJvdXNlbCgpXG5cbiAgcmV0dXJuIChcbiAgICA8ZGl2XG4gICAgICByZWY9e3JlZn1cbiAgICAgIHJvbGU9XCJncm91cFwiXG4gICAgICBhcmlhLXJvbGVkZXNjcmlwdGlvbj1cInNsaWRlXCJcbiAgICAgIGNsYXNzTmFtZT17Y24oXG4gICAgICAgIFwibWluLXctMCBzaHJpbmstMCBncm93LTAgYmFzaXMtZnVsbFwiLFxuICAgICAgICBvcmllbnRhdGlvbiA9PT0gXCJob3Jpem9udGFsXCIgPyBcInBsLTRcIiA6IFwicHQtNFwiLFxuICAgICAgICBjbGFzc05hbWVcbiAgICAgICl9XG4gICAgICB7Li4ucHJvcHN9XG4gICAgLz5cbiAgKVxufSlcbkNhcm91c2VsSXRlbS5kaXNwbGF5TmFtZSA9IFwiQ2Fyb3VzZWxJdGVtXCJcblxuY29uc3QgQ2Fyb3VzZWxQcmV2aW91cyA9IFJlYWN0LmZvcndhcmRSZWY8XG4gIEhUTUxCdXR0b25FbGVtZW50LFxuICBSZWFjdC5Db21wb25lbnRQcm9wczx0eXBlb2YgQnV0dG9uPlxuPigoeyBjbGFzc05hbWUsIHZhcmlhbnQgPSBcIm91dGxpbmVcIiwgc2l6ZSA9IFwiaWNvblwiLCAuLi5wcm9wcyB9LCByZWYpID0+IHtcbiAgY29uc3QgeyBvcmllbnRhdGlvbiwgc2Nyb2xsUHJldiwgY2FuU2Nyb2xsUHJldiB9ID0gdXNlQ2Fyb3VzZWwoKVxuXG4gIHJldHVybiAoXG4gICAgPEJ1dHRvblxuICAgICAgcmVmPXtyZWZ9XG4gICAgICB2YXJpYW50PXt2YXJpYW50fVxuICAgICAgc2l6ZT17c2l6ZX1cbiAgICAgIGNsYXNzTmFtZT17Y24oXG4gICAgICAgIFwiYWJzb2x1dGUgIGgtOCB3LTggcm91bmRlZC1mdWxsXCIsXG4gICAgICAgIG9yaWVudGF0aW9uID09PSBcImhvcml6b250YWxcIlxuICAgICAgICAgID8gXCItbGVmdC0xMiB0b3AtMS8yIC10cmFuc2xhdGUteS0xLzJcIlxuICAgICAgICAgIDogXCItdG9wLTEyIGxlZnQtMS8yIC10cmFuc2xhdGUteC0xLzIgcm90YXRlLTkwXCIsXG4gICAgICAgIGNsYXNzTmFtZVxuICAgICAgKX1cbiAgICAgIGRpc2FibGVkPXshY2FuU2Nyb2xsUHJldn1cbiAgICAgIG9uQ2xpY2s9e3Njcm9sbFByZXZ9XG4gICAgICB7Li4ucHJvcHN9XG4gICAgPlxuICAgICAgPEFycm93TGVmdCBjbGFzc05hbWU9XCJoLTQgdy00XCIgLz5cbiAgICAgIDxzcGFuIGNsYXNzTmFtZT1cInNyLW9ubHlcIj5QcmV2aW91cyBzbGlkZTwvc3Bhbj5cbiAgICA8L0J1dHRvbj5cbiAgKVxufSlcbkNhcm91c2VsUHJldmlvdXMuZGlzcGxheU5hbWUgPSBcIkNhcm91c2VsUHJldmlvdXNcIlxuXG5jb25zdCBDYXJvdXNlbE5leHQgPSBSZWFjdC5mb3J3YXJkUmVmPFxuICBIVE1MQnV0dG9uRWxlbWVudCxcbiAgUmVhY3QuQ29tcG9uZW50UHJvcHM8dHlwZW9mIEJ1dHRvbj5cbj4oKHsgY2xhc3NOYW1lLCB2YXJpYW50ID0gXCJvdXRsaW5lXCIsIHNpemUgPSBcImljb25cIiwgLi4ucHJvcHMgfSwgcmVmKSA9PiB7XG4gIGNvbnN0IHsgb3JpZW50YXRpb24sIHNjcm9sbE5leHQsIGNhblNjcm9sbE5leHQgfSA9IHVzZUNhcm91c2VsKClcblxuICByZXR1cm4gKFxuICAgIDxCdXR0b25cbiAgICAgIHJlZj17cmVmfVxuICAgICAgdmFyaWFudD17dmFyaWFudH1cbiAgICAgIHNpemU9e3NpemV9XG4gICAgICBjbGFzc05hbWU9e2NuKFxuICAgICAgICBcImFic29sdXRlIGgtOCB3LTggcm91bmRlZC1mdWxsXCIsXG4gICAgICAgIG9yaWVudGF0aW9uID09PSBcImhvcml6b250YWxcIlxuICAgICAgICAgID8gXCItcmlnaHQtMTIgdG9wLTEvMiAtdHJhbnNsYXRlLXktMS8yXCJcbiAgICAgICAgICA6IFwiLWJvdHRvbS0xMiBsZWZ0LTEvMiAtdHJhbnNsYXRlLXgtMS8yIHJvdGF0ZS05MFwiLFxuICAgICAgICBjbGFzc05hbWVcbiAgICAgICl9XG4gICAgICBkaXNhYmxlZD17IWNhblNjcm9sbE5leHR9XG4gICAgICBvbkNsaWNrPXtzY3JvbGxOZXh0fVxuICAgICAgey4uLnByb3BzfVxuICAgID5cbiAgICAgIDxBcnJvd1JpZ2h0IGNsYXNzTmFtZT1cImgtNCB3LTRcIiAvPlxuICAgICAgPHNwYW4gY2xhc3NOYW1lPVwic3Itb25seVwiPk5leHQgc2xpZGU8L3NwYW4+XG4gICAgPC9CdXR0b24+XG4gIClcbn0pXG5DYXJvdXNlbE5leHQuZGlzcGxheU5hbWUgPSBcIkNhcm91c2VsTmV4dFwiXG5cbmV4cG9ydCB7XG4gIHR5cGUgQ2Fyb3VzZWxBcGksXG4gIENhcm91c2VsLFxuICBDYXJvdXNlbENvbnRlbnQsXG4gIENhcm91c2VsSXRlbSxcbiAgQ2Fyb3VzZWxQcmV2aW91cyxcbiAgQ2Fyb3VzZWxOZXh0LFxufVxuIl0sIm5hbWVzIjpbIlJlYWN0IiwidXNlRW1ibGFDYXJvdXNlbCIsIkFycm93TGVmdCIsIkFycm93UmlnaHQiLCJjbiIsIkJ1dHRvbiIsIkNhcm91c2VsQ29udGV4dCIsImNyZWF0ZUNvbnRleHQiLCJ1c2VDYXJvdXNlbCIsImNvbnRleHQiLCJ1c2VDb250ZXh0IiwiRXJyb3IiLCJDYXJvdXNlbCIsImZvcndhcmRSZWYiLCJyZWYiLCJvcmllbnRhdGlvbiIsIm9wdHMiLCJzZXRBcGkiLCJwbHVnaW5zIiwiY2xhc3NOYW1lIiwiY2hpbGRyZW4iLCJwcm9wcyIsImNhcm91c2VsUmVmIiwiYXBpIiwiYXhpcyIsImNhblNjcm9sbFByZXYiLCJzZXRDYW5TY3JvbGxQcmV2IiwidXNlU3RhdGUiLCJjYW5TY3JvbGxOZXh0Iiwic2V0Q2FuU2Nyb2xsTmV4dCIsIm9uU2VsZWN0IiwidXNlQ2FsbGJhY2siLCJzY3JvbGxQcmV2Iiwic2Nyb2xsTmV4dCIsImhhbmRsZUtleURvd24iLCJldmVudCIsImtleSIsInByZXZlbnREZWZhdWx0IiwidXNlRWZmZWN0Iiwib24iLCJvZmYiLCJQcm92aWRlciIsInZhbHVlIiwiZGl2Iiwib25LZXlEb3duQ2FwdHVyZSIsInJvbGUiLCJhcmlhLXJvbGVkZXNjcmlwdGlvbiIsImRpc3BsYXlOYW1lIiwiQ2Fyb3VzZWxDb250ZW50IiwiQ2Fyb3VzZWxJdGVtIiwiQ2Fyb3VzZWxQcmV2aW91cyIsInZhcmlhbnQiLCJzaXplIiwiZGlzYWJsZWQiLCJvbkNsaWNrIiwic3BhbiIsIkNhcm91c2VsTmV4dCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/components/ui/carousel.tsx\n"));

/***/ }),

/***/ "(app-pages-browser)/./src/pagina/recebimento/descarga/4_anomalia/ajuda/index.tsx":
/*!********************************************************************!*\
  !*** ./src/pagina/recebimento/descarga/4_anomalia/ajuda/index.tsx ***!
  \********************************************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": function() { return /* binding */ AjudaDrawer; }\n/* harmony export */ });\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/jsx-dev-runtime.js\");\n/* harmony import */ var _components_ui_sheet__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @/components/ui/sheet */ \"(app-pages-browser)/./src/components/ui/sheet.tsx\");\n/* harmony import */ var _components_ui_carousel__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @/components/ui/carousel */ \"(app-pages-browser)/./src/components/ui/carousel.tsx\");\n/* harmony import */ var _barrel_optimize_names_AlertCircle_lucide_react__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! __barrel_optimize__?names=AlertCircle!=!lucide-react */ \"(app-pages-browser)/./node_modules/lucide-react/dist/esm/icons/alert-circle.js\");\n\n\n\n\nfunction AjudaDrawer() {\n    return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_components_ui_sheet__WEBPACK_IMPORTED_MODULE_1__.Sheet, {\n        children: [\n            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_components_ui_sheet__WEBPACK_IMPORTED_MODULE_1__.SheetTrigger, {\n                children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_barrel_optimize_names_AlertCircle_lucide_react__WEBPACK_IMPORTED_MODULE_3__[\"default\"], {}, void 0, false, {\n                    fileName: \"/Users/carlos/Documents/carlos/WMS/front/pwa/src/pagina/recebimento/descarga/4_anomalia/ajuda/index.tsx\",\n                    lineNumber: 23,\n                    columnNumber: 9\n                }, this)\n            }, void 0, false, {\n                fileName: \"/Users/carlos/Documents/carlos/WMS/front/pwa/src/pagina/recebimento/descarga/4_anomalia/ajuda/index.tsx\",\n                lineNumber: 22,\n                columnNumber: 7\n            }, this),\n            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_components_ui_sheet__WEBPACK_IMPORTED_MODULE_1__.SheetContent, {\n                className: \"w-full\",\n                children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_components_ui_sheet__WEBPACK_IMPORTED_MODULE_1__.SheetHeader, {\n                    children: [\n                        /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_components_ui_sheet__WEBPACK_IMPORTED_MODULE_1__.SheetTitle, {\n                            children: \"Are you absolutely sure?\"\n                        }, void 0, false, {\n                            fileName: \"/Users/carlos/Documents/carlos/WMS/front/pwa/src/pagina/recebimento/descarga/4_anomalia/ajuda/index.tsx\",\n                            lineNumber: 27,\n                            columnNumber: 11\n                        }, this),\n                        /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_components_ui_sheet__WEBPACK_IMPORTED_MODULE_1__.SheetDescription, {\n                            children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_components_ui_carousel__WEBPACK_IMPORTED_MODULE_2__.Carousel, {\n                                children: [\n                                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_components_ui_carousel__WEBPACK_IMPORTED_MODULE_2__.CarouselContent, {\n                                        children: [\n                                            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_components_ui_carousel__WEBPACK_IMPORTED_MODULE_2__.CarouselItem, {\n                                                children: \"...\"\n                                            }, void 0, false, {\n                                                fileName: \"/Users/carlos/Documents/carlos/WMS/front/pwa/src/pagina/recebimento/descarga/4_anomalia/ajuda/index.tsx\",\n                                                lineNumber: 31,\n                                                columnNumber: 17\n                                            }, this),\n                                            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_components_ui_carousel__WEBPACK_IMPORTED_MODULE_2__.CarouselItem, {\n                                                children: \"...\"\n                                            }, void 0, false, {\n                                                fileName: \"/Users/carlos/Documents/carlos/WMS/front/pwa/src/pagina/recebimento/descarga/4_anomalia/ajuda/index.tsx\",\n                                                lineNumber: 32,\n                                                columnNumber: 17\n                                            }, this),\n                                            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_components_ui_carousel__WEBPACK_IMPORTED_MODULE_2__.CarouselItem, {\n                                                children: \"...\"\n                                            }, void 0, false, {\n                                                fileName: \"/Users/carlos/Documents/carlos/WMS/front/pwa/src/pagina/recebimento/descarga/4_anomalia/ajuda/index.tsx\",\n                                                lineNumber: 33,\n                                                columnNumber: 17\n                                            }, this)\n                                        ]\n                                    }, void 0, true, {\n                                        fileName: \"/Users/carlos/Documents/carlos/WMS/front/pwa/src/pagina/recebimento/descarga/4_anomalia/ajuda/index.tsx\",\n                                        lineNumber: 30,\n                                        columnNumber: 15\n                                    }, this),\n                                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_components_ui_carousel__WEBPACK_IMPORTED_MODULE_2__.CarouselPrevious, {}, void 0, false, {\n                                        fileName: \"/Users/carlos/Documents/carlos/WMS/front/pwa/src/pagina/recebimento/descarga/4_anomalia/ajuda/index.tsx\",\n                                        lineNumber: 35,\n                                        columnNumber: 15\n                                    }, this),\n                                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_components_ui_carousel__WEBPACK_IMPORTED_MODULE_2__.CarouselNext, {}, void 0, false, {\n                                        fileName: \"/Users/carlos/Documents/carlos/WMS/front/pwa/src/pagina/recebimento/descarga/4_anomalia/ajuda/index.tsx\",\n                                        lineNumber: 36,\n                                        columnNumber: 15\n                                    }, this)\n                                ]\n                            }, void 0, true, {\n                                fileName: \"/Users/carlos/Documents/carlos/WMS/front/pwa/src/pagina/recebimento/descarga/4_anomalia/ajuda/index.tsx\",\n                                lineNumber: 29,\n                                columnNumber: 13\n                            }, this)\n                        }, void 0, false, {\n                            fileName: \"/Users/carlos/Documents/carlos/WMS/front/pwa/src/pagina/recebimento/descarga/4_anomalia/ajuda/index.tsx\",\n                            lineNumber: 28,\n                            columnNumber: 11\n                        }, this)\n                    ]\n                }, void 0, true, {\n                    fileName: \"/Users/carlos/Documents/carlos/WMS/front/pwa/src/pagina/recebimento/descarga/4_anomalia/ajuda/index.tsx\",\n                    lineNumber: 26,\n                    columnNumber: 9\n                }, this)\n            }, void 0, false, {\n                fileName: \"/Users/carlos/Documents/carlos/WMS/front/pwa/src/pagina/recebimento/descarga/4_anomalia/ajuda/index.tsx\",\n                lineNumber: 25,\n                columnNumber: 7\n            }, this)\n        ]\n    }, void 0, true, {\n        fileName: \"/Users/carlos/Documents/carlos/WMS/front/pwa/src/pagina/recebimento/descarga/4_anomalia/ajuda/index.tsx\",\n        lineNumber: 21,\n        columnNumber: 5\n    }, this);\n}\n_c = AjudaDrawer;\nvar _c;\n$RefreshReg$(_c, \"AjudaDrawer\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9wYWdpbmEvcmVjZWJpbWVudG8vZGVzY2FyZ2EvNF9hbm9tYWxpYS9hanVkYS9pbmRleC50c3giLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7O0FBTytCO0FBUUc7QUFDUztBQUU1QixTQUFTWTtJQUN0QixxQkFDRSw4REFBQ1osdURBQUtBOzswQkFDSiw4REFBQ0ssOERBQVlBOzBCQUNYLDRFQUFDTSx1RkFBV0E7Ozs7Ozs7Ozs7MEJBRWQsOERBQUNWLDhEQUFZQTtnQkFBQ1ksV0FBVTswQkFDdEIsNEVBQUNWLDZEQUFXQTs7c0NBQ1YsOERBQUNDLDREQUFVQTtzQ0FBQzs7Ozs7O3NDQUNaLDhEQUFDRixrRUFBZ0JBO3NDQUNmLDRFQUFDSSw2REFBUUE7O2tEQUNQLDhEQUFDQyxvRUFBZUE7OzBEQUNkLDhEQUFDQyxpRUFBWUE7MERBQUM7Ozs7OzswREFDZCw4REFBQ0EsaUVBQVlBOzBEQUFDOzs7Ozs7MERBQ2QsOERBQUNBLGlFQUFZQTswREFBQzs7Ozs7Ozs7Ozs7O2tEQUVoQiw4REFBQ0UscUVBQWdCQTs7Ozs7a0RBQ2pCLDhEQUFDRCxpRUFBWUE7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQU8zQjtLQXhCd0JHIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL3NyYy9wYWdpbmEvcmVjZWJpbWVudG8vZGVzY2FyZ2EvNF9hbm9tYWxpYS9hanVkYS9pbmRleC50c3g/M2MzZiJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQge1xuICAgIFNoZWV0LFxuICAgIFNoZWV0Q29udGVudCxcbiAgICBTaGVldERlc2NyaXB0aW9uLFxuICAgIFNoZWV0SGVhZGVyLFxuICAgIFNoZWV0VGl0bGUsXG4gICAgU2hlZXRUcmlnZ2VyLFxufSBmcm9tIFwiQC9jb21wb25lbnRzL3VpL3NoZWV0XCI7XG5cbmltcG9ydCB7XG4gICAgQ2Fyb3VzZWwsXG4gICAgQ2Fyb3VzZWxDb250ZW50LFxuICAgIENhcm91c2VsSXRlbSxcbiAgICBDYXJvdXNlbE5leHQsXG4gICAgQ2Fyb3VzZWxQcmV2aW91cyxcbn0gZnJvbSBcIkAvY29tcG9uZW50cy91aS9jYXJvdXNlbFwiO1xuaW1wb3J0IHsgQWxlcnRDaXJjbGUgfSBmcm9tIFwibHVjaWRlLXJlYWN0XCI7XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIEFqdWRhRHJhd2VyKCkge1xuICByZXR1cm4gKFxuICAgIDxTaGVldD5cbiAgICAgIDxTaGVldFRyaWdnZXI+XG4gICAgICAgIDxBbGVydENpcmNsZT48L0FsZXJ0Q2lyY2xlPlxuICAgICAgPC9TaGVldFRyaWdnZXI+XG4gICAgICA8U2hlZXRDb250ZW50IGNsYXNzTmFtZT1cInctZnVsbFwiPlxuICAgICAgICA8U2hlZXRIZWFkZXI+XG4gICAgICAgICAgPFNoZWV0VGl0bGU+QXJlIHlvdSBhYnNvbHV0ZWx5IHN1cmU/PC9TaGVldFRpdGxlPlxuICAgICAgICAgIDxTaGVldERlc2NyaXB0aW9uPlxuICAgICAgICAgICAgPENhcm91c2VsPlxuICAgICAgICAgICAgICA8Q2Fyb3VzZWxDb250ZW50PlxuICAgICAgICAgICAgICAgIDxDYXJvdXNlbEl0ZW0+Li4uPC9DYXJvdXNlbEl0ZW0+XG4gICAgICAgICAgICAgICAgPENhcm91c2VsSXRlbT4uLi48L0Nhcm91c2VsSXRlbT5cbiAgICAgICAgICAgICAgICA8Q2Fyb3VzZWxJdGVtPi4uLjwvQ2Fyb3VzZWxJdGVtPlxuICAgICAgICAgICAgICA8L0Nhcm91c2VsQ29udGVudD5cbiAgICAgICAgICAgICAgPENhcm91c2VsUHJldmlvdXMgLz5cbiAgICAgICAgICAgICAgPENhcm91c2VsTmV4dCAvPlxuICAgICAgICAgICAgPC9DYXJvdXNlbD5cbiAgICAgICAgICA8L1NoZWV0RGVzY3JpcHRpb24+XG4gICAgICAgIDwvU2hlZXRIZWFkZXI+XG4gICAgICA8L1NoZWV0Q29udGVudD5cbiAgICA8L1NoZWV0PlxuICApO1xufVxuIl0sIm5hbWVzIjpbIlNoZWV0IiwiU2hlZXRDb250ZW50IiwiU2hlZXREZXNjcmlwdGlvbiIsIlNoZWV0SGVhZGVyIiwiU2hlZXRUaXRsZSIsIlNoZWV0VHJpZ2dlciIsIkNhcm91c2VsIiwiQ2Fyb3VzZWxDb250ZW50IiwiQ2Fyb3VzZWxJdGVtIiwiQ2Fyb3VzZWxOZXh0IiwiQ2Fyb3VzZWxQcmV2aW91cyIsIkFsZXJ0Q2lyY2xlIiwiQWp1ZGFEcmF3ZXIiLCJjbGFzc05hbWUiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/pagina/recebimento/descarga/4_anomalia/ajuda/index.tsx\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/embla-carousel-react/esm/embla-carousel-react.esm.js":
/*!***************************************************************************!*\
  !*** ./node_modules/embla-carousel-react/esm/embla-carousel-react.esm.js ***!
  \***************************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": function() { return /* binding */ useEmblaCarousel; }\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\n/* harmony import */ var embla_carousel_reactive_utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! embla-carousel-reactive-utils */ \"(app-pages-browser)/./node_modules/embla-carousel-reactive-utils/esm/embla-carousel-reactive-utils.esm.js\");\n/* harmony import */ var embla_carousel__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! embla-carousel */ \"(app-pages-browser)/./node_modules/embla-carousel/esm/embla-carousel.esm.js\");\nvar _s = $RefreshSig$();\n\n\n\nfunction useEmblaCarousel() {\n    let options = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {}, plugins = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : [];\n    _s();\n    const storedOptions = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(options);\n    const storedPlugins = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(plugins);\n    const [emblaApi, setEmblaApi] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)();\n    const [viewport, setViewport] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)();\n    const reInit = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(()=>{\n        if (emblaApi) emblaApi.reInit(storedOptions.current, storedPlugins.current);\n    }, [\n        emblaApi\n    ]);\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{\n        if ((0,embla_carousel_reactive_utils__WEBPACK_IMPORTED_MODULE_1__.canUseDOM)() && viewport) {\n            embla_carousel__WEBPACK_IMPORTED_MODULE_2__[\"default\"].globalOptions = useEmblaCarousel.globalOptions;\n            const newEmblaApi = (0,embla_carousel__WEBPACK_IMPORTED_MODULE_2__[\"default\"])(viewport, storedOptions.current, storedPlugins.current);\n            setEmblaApi(newEmblaApi);\n            return ()=>newEmblaApi.destroy();\n        } else {\n            setEmblaApi(undefined);\n        }\n    }, [\n        viewport,\n        setEmblaApi\n    ]);\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{\n        if ((0,embla_carousel_reactive_utils__WEBPACK_IMPORTED_MODULE_1__.areOptionsEqual)(storedOptions.current, options)) return;\n        storedOptions.current = options;\n        reInit();\n    }, [\n        options,\n        reInit\n    ]);\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{\n        if ((0,embla_carousel_reactive_utils__WEBPACK_IMPORTED_MODULE_1__.arePluginsEqual)(storedPlugins.current, plugins)) return;\n        storedPlugins.current = plugins;\n        reInit();\n    }, [\n        plugins,\n        reInit\n    ]);\n    return [\n        setViewport,\n        emblaApi\n    ];\n}\n_s(useEmblaCarousel, \"tkM1fyR3s74cZOKzx5ONk86UOvg=\");\nuseEmblaCarousel.globalOptions = undefined;\n //# sourceMappingURL=embla-carousel-react.esm.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9lbWJsYS1jYXJvdXNlbC1yZWFjdC9lc20vZW1ibGEtY2Fyb3VzZWwtcmVhY3QuZXNtLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7O0FBQWlFO0FBQzJCO0FBQ2pEO0FBRTNDLFNBQVNRO1FBQWlCQyxVQUFBQSxpRUFBVSxDQUFDLEdBQUdDLFVBQUFBLGlFQUFVLEVBQUU7O0lBQ2xELE1BQU1DLGdCQUFnQlgsNkNBQU1BLENBQUNTO0lBQzdCLE1BQU1HLGdCQUFnQlosNkNBQU1BLENBQUNVO0lBQzdCLE1BQU0sQ0FBQ0csVUFBVUMsWUFBWSxHQUFHYiwrQ0FBUUE7SUFDeEMsTUFBTSxDQUFDYyxVQUFVQyxZQUFZLEdBQUdmLCtDQUFRQTtJQUN4QyxNQUFNZ0IsU0FBU2Ysa0RBQVdBLENBQUM7UUFDekIsSUFBSVcsVUFBVUEsU0FBU0ksTUFBTSxDQUFDTixjQUFjTyxPQUFPLEVBQUVOLGNBQWNNLE9BQU87SUFDNUUsR0FBRztRQUFDTDtLQUFTO0lBQ2JWLGdEQUFTQSxDQUFDO1FBQ1IsSUFBSUMsd0VBQVNBLE1BQU1XLFVBQVU7WUFDM0JSLHNEQUFhQSxDQUFDWSxhQUFhLEdBQUdYLGlCQUFpQlcsYUFBYTtZQUM1RCxNQUFNQyxjQUFjYiwwREFBYUEsQ0FBQ1EsVUFBVUosY0FBY08sT0FBTyxFQUFFTixjQUFjTSxPQUFPO1lBQ3hGSixZQUFZTTtZQUNaLE9BQU8sSUFBTUEsWUFBWUMsT0FBTztRQUNsQyxPQUFPO1lBQ0xQLFlBQVlRO1FBQ2Q7SUFDRixHQUFHO1FBQUNQO1FBQVVEO0tBQVk7SUFDMUJYLGdEQUFTQSxDQUFDO1FBQ1IsSUFBSUUsOEVBQWVBLENBQUNNLGNBQWNPLE9BQU8sRUFBRVQsVUFBVTtRQUNyREUsY0FBY08sT0FBTyxHQUFHVDtRQUN4QlE7SUFDRixHQUFHO1FBQUNSO1FBQVNRO0tBQU87SUFDcEJkLGdEQUFTQSxDQUFDO1FBQ1IsSUFBSUcsOEVBQWVBLENBQUNNLGNBQWNNLE9BQU8sRUFBRVIsVUFBVTtRQUNyREUsY0FBY00sT0FBTyxHQUFHUjtRQUN4Qk87SUFDRixHQUFHO1FBQUNQO1FBQVNPO0tBQU87SUFDcEIsT0FBTztRQUFDRDtRQUFhSDtLQUFTO0FBQ2hDO0dBN0JTTDtBQThCVEEsaUJBQWlCVyxhQUFhLEdBQUdHO0FBRU0sQ0FDdkMsb0RBQW9EIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9lbWJsYS1jYXJvdXNlbC1yZWFjdC9lc20vZW1ibGEtY2Fyb3VzZWwtcmVhY3QuZXNtLmpzPzE0MzQiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgdXNlUmVmLCB1c2VTdGF0ZSwgdXNlQ2FsbGJhY2ssIHVzZUVmZmVjdCB9IGZyb20gJ3JlYWN0JztcbmltcG9ydCB7IGNhblVzZURPTSwgYXJlT3B0aW9uc0VxdWFsLCBhcmVQbHVnaW5zRXF1YWwgfSBmcm9tICdlbWJsYS1jYXJvdXNlbC1yZWFjdGl2ZS11dGlscyc7XG5pbXBvcnQgRW1ibGFDYXJvdXNlbCBmcm9tICdlbWJsYS1jYXJvdXNlbCc7XG5cbmZ1bmN0aW9uIHVzZUVtYmxhQ2Fyb3VzZWwob3B0aW9ucyA9IHt9LCBwbHVnaW5zID0gW10pIHtcbiAgY29uc3Qgc3RvcmVkT3B0aW9ucyA9IHVzZVJlZihvcHRpb25zKTtcbiAgY29uc3Qgc3RvcmVkUGx1Z2lucyA9IHVzZVJlZihwbHVnaW5zKTtcbiAgY29uc3QgW2VtYmxhQXBpLCBzZXRFbWJsYUFwaV0gPSB1c2VTdGF0ZSgpO1xuICBjb25zdCBbdmlld3BvcnQsIHNldFZpZXdwb3J0XSA9IHVzZVN0YXRlKCk7XG4gIGNvbnN0IHJlSW5pdCA9IHVzZUNhbGxiYWNrKCgpID0+IHtcbiAgICBpZiAoZW1ibGFBcGkpIGVtYmxhQXBpLnJlSW5pdChzdG9yZWRPcHRpb25zLmN1cnJlbnQsIHN0b3JlZFBsdWdpbnMuY3VycmVudCk7XG4gIH0sIFtlbWJsYUFwaV0pO1xuICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgIGlmIChjYW5Vc2VET00oKSAmJiB2aWV3cG9ydCkge1xuICAgICAgRW1ibGFDYXJvdXNlbC5nbG9iYWxPcHRpb25zID0gdXNlRW1ibGFDYXJvdXNlbC5nbG9iYWxPcHRpb25zO1xuICAgICAgY29uc3QgbmV3RW1ibGFBcGkgPSBFbWJsYUNhcm91c2VsKHZpZXdwb3J0LCBzdG9yZWRPcHRpb25zLmN1cnJlbnQsIHN0b3JlZFBsdWdpbnMuY3VycmVudCk7XG4gICAgICBzZXRFbWJsYUFwaShuZXdFbWJsYUFwaSk7XG4gICAgICByZXR1cm4gKCkgPT4gbmV3RW1ibGFBcGkuZGVzdHJveSgpO1xuICAgIH0gZWxzZSB7XG4gICAgICBzZXRFbWJsYUFwaSh1bmRlZmluZWQpO1xuICAgIH1cbiAgfSwgW3ZpZXdwb3J0LCBzZXRFbWJsYUFwaV0pO1xuICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgIGlmIChhcmVPcHRpb25zRXF1YWwoc3RvcmVkT3B0aW9ucy5jdXJyZW50LCBvcHRpb25zKSkgcmV0dXJuO1xuICAgIHN0b3JlZE9wdGlvbnMuY3VycmVudCA9IG9wdGlvbnM7XG4gICAgcmVJbml0KCk7XG4gIH0sIFtvcHRpb25zLCByZUluaXRdKTtcbiAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICBpZiAoYXJlUGx1Z2luc0VxdWFsKHN0b3JlZFBsdWdpbnMuY3VycmVudCwgcGx1Z2lucykpIHJldHVybjtcbiAgICBzdG9yZWRQbHVnaW5zLmN1cnJlbnQgPSBwbHVnaW5zO1xuICAgIHJlSW5pdCgpO1xuICB9LCBbcGx1Z2lucywgcmVJbml0XSk7XG4gIHJldHVybiBbc2V0Vmlld3BvcnQsIGVtYmxhQXBpXTtcbn1cbnVzZUVtYmxhQ2Fyb3VzZWwuZ2xvYmFsT3B0aW9ucyA9IHVuZGVmaW5lZDtcblxuZXhwb3J0IHsgdXNlRW1ibGFDYXJvdXNlbCBhcyBkZWZhdWx0IH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1lbWJsYS1jYXJvdXNlbC1yZWFjdC5lc20uanMubWFwXG4iXSwibmFtZXMiOlsidXNlUmVmIiwidXNlU3RhdGUiLCJ1c2VDYWxsYmFjayIsInVzZUVmZmVjdCIsImNhblVzZURPTSIsImFyZU9wdGlvbnNFcXVhbCIsImFyZVBsdWdpbnNFcXVhbCIsIkVtYmxhQ2Fyb3VzZWwiLCJ1c2VFbWJsYUNhcm91c2VsIiwib3B0aW9ucyIsInBsdWdpbnMiLCJzdG9yZWRPcHRpb25zIiwic3RvcmVkUGx1Z2lucyIsImVtYmxhQXBpIiwic2V0RW1ibGFBcGkiLCJ2aWV3cG9ydCIsInNldFZpZXdwb3J0IiwicmVJbml0IiwiY3VycmVudCIsImdsb2JhbE9wdGlvbnMiLCJuZXdFbWJsYUFwaSIsImRlc3Ryb3kiLCJ1bmRlZmluZWQiLCJkZWZhdWx0Il0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/embla-carousel-react/esm/embla-carousel-react.esm.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/embla-carousel-reactive-utils/esm/embla-carousel-reactive-utils.esm.js":
/*!*********************************************************************************************!*\
  !*** ./node_modules/embla-carousel-reactive-utils/esm/embla-carousel-reactive-utils.esm.js ***!
  \*********************************************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   areOptionsEqual: function() { return /* binding */ areOptionsEqual; },\n/* harmony export */   arePluginsEqual: function() { return /* binding */ arePluginsEqual; },\n/* harmony export */   canUseDOM: function() { return /* binding */ canUseDOM; },\n/* harmony export */   sortAndMapPluginToOptions: function() { return /* binding */ sortAndMapPluginToOptions; }\n/* harmony export */ });\nfunction isObject(subject) {\n    return Object.prototype.toString.call(subject) === \"[object Object]\";\n}\nfunction isRecord(subject) {\n    return isObject(subject) || Array.isArray(subject);\n}\nfunction canUseDOM() {\n    return !!( true && window.document && window.document.createElement);\n}\nfunction areOptionsEqual(optionsA, optionsB) {\n    const optionsAKeys = Object.keys(optionsA);\n    const optionsBKeys = Object.keys(optionsB);\n    if (optionsAKeys.length !== optionsBKeys.length) return false;\n    const breakpointsA = JSON.stringify(Object.keys(optionsA.breakpoints || {}));\n    const breakpointsB = JSON.stringify(Object.keys(optionsB.breakpoints || {}));\n    if (breakpointsA !== breakpointsB) return false;\n    return optionsAKeys.every((key)=>{\n        const valueA = optionsA[key];\n        const valueB = optionsB[key];\n        if (typeof valueA === \"function\") return \"\".concat(valueA) === \"\".concat(valueB);\n        if (!isRecord(valueA) || !isRecord(valueB)) return valueA === valueB;\n        return areOptionsEqual(valueA, valueB);\n    });\n}\nfunction sortAndMapPluginToOptions(plugins) {\n    return plugins.concat().sort((a, b)=>a.name > b.name ? 1 : -1).map((plugin)=>plugin.options);\n}\nfunction arePluginsEqual(pluginsA, pluginsB) {\n    if (pluginsA.length !== pluginsB.length) return false;\n    const optionsA = sortAndMapPluginToOptions(pluginsA);\n    const optionsB = sortAndMapPluginToOptions(pluginsB);\n    return optionsA.every((optionA, index)=>{\n        const optionB = optionsB[index];\n        return areOptionsEqual(optionA, optionB);\n    });\n}\n //# sourceMappingURL=embla-carousel-reactive-utils.esm.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9lbWJsYS1jYXJvdXNlbC1yZWFjdGl2ZS11dGlscy9lc20vZW1ibGEtY2Fyb3VzZWwtcmVhY3RpdmUtdXRpbHMuZXNtLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7QUFBQSxTQUFTQSxTQUFTQyxPQUFPO0lBQ3ZCLE9BQU9DLE9BQU9DLFNBQVMsQ0FBQ0MsUUFBUSxDQUFDQyxJQUFJLENBQUNKLGFBQWE7QUFDckQ7QUFDQSxTQUFTSyxTQUFTTCxPQUFPO0lBQ3ZCLE9BQU9ELFNBQVNDLFlBQVlNLE1BQU1DLE9BQU8sQ0FBQ1A7QUFDNUM7QUFDQSxTQUFTUTtJQUNQLE9BQU8sQ0FBQyxDQUFFLE1BQWtCLElBQWVDLE9BQU9DLFFBQVEsSUFBSUQsT0FBT0MsUUFBUSxDQUFDQyxhQUFhO0FBQzdGO0FBQ0EsU0FBU0MsZ0JBQWdCQyxRQUFRLEVBQUVDLFFBQVE7SUFDekMsTUFBTUMsZUFBZWQsT0FBT2UsSUFBSSxDQUFDSDtJQUNqQyxNQUFNSSxlQUFlaEIsT0FBT2UsSUFBSSxDQUFDRjtJQUNqQyxJQUFJQyxhQUFhRyxNQUFNLEtBQUtELGFBQWFDLE1BQU0sRUFBRSxPQUFPO0lBQ3hELE1BQU1DLGVBQWVDLEtBQUtDLFNBQVMsQ0FBQ3BCLE9BQU9lLElBQUksQ0FBQ0gsU0FBU1MsV0FBVyxJQUFJLENBQUM7SUFDekUsTUFBTUMsZUFBZUgsS0FBS0MsU0FBUyxDQUFDcEIsT0FBT2UsSUFBSSxDQUFDRixTQUFTUSxXQUFXLElBQUksQ0FBQztJQUN6RSxJQUFJSCxpQkFBaUJJLGNBQWMsT0FBTztJQUMxQyxPQUFPUixhQUFhUyxLQUFLLENBQUNDLENBQUFBO1FBQ3hCLE1BQU1DLFNBQVNiLFFBQVEsQ0FBQ1ksSUFBSTtRQUM1QixNQUFNRSxTQUFTYixRQUFRLENBQUNXLElBQUk7UUFDNUIsSUFBSSxPQUFPQyxXQUFXLFlBQVksT0FBTyxHQUFVLE9BQVBBLFlBQWEsR0FBVSxPQUFQQztRQUM1RCxJQUFJLENBQUN0QixTQUFTcUIsV0FBVyxDQUFDckIsU0FBU3NCLFNBQVMsT0FBT0QsV0FBV0M7UUFDOUQsT0FBT2YsZ0JBQWdCYyxRQUFRQztJQUNqQztBQUNGO0FBQ0EsU0FBU0MsMEJBQTBCQyxPQUFPO0lBQ3hDLE9BQU9BLFFBQVFDLE1BQU0sR0FBR0MsSUFBSSxDQUFDLENBQUNDLEdBQUdDLElBQU1ELEVBQUVFLElBQUksR0FBR0QsRUFBRUMsSUFBSSxHQUFHLElBQUksQ0FBQyxHQUFHQyxHQUFHLENBQUNDLENBQUFBLFNBQVVBLE9BQU9DLE9BQU87QUFDL0Y7QUFDQSxTQUFTQyxnQkFBZ0JDLFFBQVEsRUFBRUMsUUFBUTtJQUN6QyxJQUFJRCxTQUFTckIsTUFBTSxLQUFLc0IsU0FBU3RCLE1BQU0sRUFBRSxPQUFPO0lBQ2hELE1BQU1MLFdBQVdlLDBCQUEwQlc7SUFDM0MsTUFBTXpCLFdBQVdjLDBCQUEwQlk7SUFDM0MsT0FBTzNCLFNBQVNXLEtBQUssQ0FBQyxDQUFDaUIsU0FBU0M7UUFDOUIsTUFBTUMsVUFBVTdCLFFBQVEsQ0FBQzRCLE1BQU07UUFDL0IsT0FBTzlCLGdCQUFnQjZCLFNBQVNFO0lBQ2xDO0FBQ0Y7QUFFa0YsQ0FDbEYsNkRBQTZEIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9lbWJsYS1jYXJvdXNlbC1yZWFjdGl2ZS11dGlscy9lc20vZW1ibGEtY2Fyb3VzZWwtcmVhY3RpdmUtdXRpbHMuZXNtLmpzP2RjNTciXSwic291cmNlc0NvbnRlbnQiOlsiZnVuY3Rpb24gaXNPYmplY3Qoc3ViamVjdCkge1xuICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHN1YmplY3QpID09PSAnW29iamVjdCBPYmplY3RdJztcbn1cbmZ1bmN0aW9uIGlzUmVjb3JkKHN1YmplY3QpIHtcbiAgcmV0dXJuIGlzT2JqZWN0KHN1YmplY3QpIHx8IEFycmF5LmlzQXJyYXkoc3ViamVjdCk7XG59XG5mdW5jdGlvbiBjYW5Vc2VET00oKSB7XG4gIHJldHVybiAhISh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyAmJiB3aW5kb3cuZG9jdW1lbnQgJiYgd2luZG93LmRvY3VtZW50LmNyZWF0ZUVsZW1lbnQpO1xufVxuZnVuY3Rpb24gYXJlT3B0aW9uc0VxdWFsKG9wdGlvbnNBLCBvcHRpb25zQikge1xuICBjb25zdCBvcHRpb25zQUtleXMgPSBPYmplY3Qua2V5cyhvcHRpb25zQSk7XG4gIGNvbnN0IG9wdGlvbnNCS2V5cyA9IE9iamVjdC5rZXlzKG9wdGlvbnNCKTtcbiAgaWYgKG9wdGlvbnNBS2V5cy5sZW5ndGggIT09IG9wdGlvbnNCS2V5cy5sZW5ndGgpIHJldHVybiBmYWxzZTtcbiAgY29uc3QgYnJlYWtwb2ludHNBID0gSlNPTi5zdHJpbmdpZnkoT2JqZWN0LmtleXMob3B0aW9uc0EuYnJlYWtwb2ludHMgfHwge30pKTtcbiAgY29uc3QgYnJlYWtwb2ludHNCID0gSlNPTi5zdHJpbmdpZnkoT2JqZWN0LmtleXMob3B0aW9uc0IuYnJlYWtwb2ludHMgfHwge30pKTtcbiAgaWYgKGJyZWFrcG9pbnRzQSAhPT0gYnJlYWtwb2ludHNCKSByZXR1cm4gZmFsc2U7XG4gIHJldHVybiBvcHRpb25zQUtleXMuZXZlcnkoa2V5ID0+IHtcbiAgICBjb25zdCB2YWx1ZUEgPSBvcHRpb25zQVtrZXldO1xuICAgIGNvbnN0IHZhbHVlQiA9IG9wdGlvbnNCW2tleV07XG4gICAgaWYgKHR5cGVvZiB2YWx1ZUEgPT09ICdmdW5jdGlvbicpIHJldHVybiBgJHt2YWx1ZUF9YCA9PT0gYCR7dmFsdWVCfWA7XG4gICAgaWYgKCFpc1JlY29yZCh2YWx1ZUEpIHx8ICFpc1JlY29yZCh2YWx1ZUIpKSByZXR1cm4gdmFsdWVBID09PSB2YWx1ZUI7XG4gICAgcmV0dXJuIGFyZU9wdGlvbnNFcXVhbCh2YWx1ZUEsIHZhbHVlQik7XG4gIH0pO1xufVxuZnVuY3Rpb24gc29ydEFuZE1hcFBsdWdpblRvT3B0aW9ucyhwbHVnaW5zKSB7XG4gIHJldHVybiBwbHVnaW5zLmNvbmNhdCgpLnNvcnQoKGEsIGIpID0+IGEubmFtZSA+IGIubmFtZSA/IDEgOiAtMSkubWFwKHBsdWdpbiA9PiBwbHVnaW4ub3B0aW9ucyk7XG59XG5mdW5jdGlvbiBhcmVQbHVnaW5zRXF1YWwocGx1Z2luc0EsIHBsdWdpbnNCKSB7XG4gIGlmIChwbHVnaW5zQS5sZW5ndGggIT09IHBsdWdpbnNCLmxlbmd0aCkgcmV0dXJuIGZhbHNlO1xuICBjb25zdCBvcHRpb25zQSA9IHNvcnRBbmRNYXBQbHVnaW5Ub09wdGlvbnMocGx1Z2luc0EpO1xuICBjb25zdCBvcHRpb25zQiA9IHNvcnRBbmRNYXBQbHVnaW5Ub09wdGlvbnMocGx1Z2luc0IpO1xuICByZXR1cm4gb3B0aW9uc0EuZXZlcnkoKG9wdGlvbkEsIGluZGV4KSA9PiB7XG4gICAgY29uc3Qgb3B0aW9uQiA9IG9wdGlvbnNCW2luZGV4XTtcbiAgICByZXR1cm4gYXJlT3B0aW9uc0VxdWFsKG9wdGlvbkEsIG9wdGlvbkIpO1xuICB9KTtcbn1cblxuZXhwb3J0IHsgYXJlT3B0aW9uc0VxdWFsLCBhcmVQbHVnaW5zRXF1YWwsIGNhblVzZURPTSwgc29ydEFuZE1hcFBsdWdpblRvT3B0aW9ucyB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZW1ibGEtY2Fyb3VzZWwtcmVhY3RpdmUtdXRpbHMuZXNtLmpzLm1hcFxuIl0sIm5hbWVzIjpbImlzT2JqZWN0Iiwic3ViamVjdCIsIk9iamVjdCIsInByb3RvdHlwZSIsInRvU3RyaW5nIiwiY2FsbCIsImlzUmVjb3JkIiwiQXJyYXkiLCJpc0FycmF5IiwiY2FuVXNlRE9NIiwid2luZG93IiwiZG9jdW1lbnQiLCJjcmVhdGVFbGVtZW50IiwiYXJlT3B0aW9uc0VxdWFsIiwib3B0aW9uc0EiLCJvcHRpb25zQiIsIm9wdGlvbnNBS2V5cyIsImtleXMiLCJvcHRpb25zQktleXMiLCJsZW5ndGgiLCJicmVha3BvaW50c0EiLCJKU09OIiwic3RyaW5naWZ5IiwiYnJlYWtwb2ludHMiLCJicmVha3BvaW50c0IiLCJldmVyeSIsImtleSIsInZhbHVlQSIsInZhbHVlQiIsInNvcnRBbmRNYXBQbHVnaW5Ub09wdGlvbnMiLCJwbHVnaW5zIiwiY29uY2F0Iiwic29ydCIsImEiLCJiIiwibmFtZSIsIm1hcCIsInBsdWdpbiIsIm9wdGlvbnMiLCJhcmVQbHVnaW5zRXF1YWwiLCJwbHVnaW5zQSIsInBsdWdpbnNCIiwib3B0aW9uQSIsImluZGV4Iiwib3B0aW9uQiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/embla-carousel-reactive-utils/esm/embla-carousel-reactive-utils.esm.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/embla-carousel/esm/embla-carousel.esm.js":
/*!***************************************************************!*\
  !*** ./node_modules/embla-carousel/esm/embla-carousel.esm.js ***!
  \***************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": function() { return /* binding */ EmblaCarousel; }\n/* harmony export */ });\nfunction isNumber(subject) {\n    return typeof subject === \"number\";\n}\nfunction isString(subject) {\n    return typeof subject === \"string\";\n}\nfunction isBoolean(subject) {\n    return typeof subject === \"boolean\";\n}\nfunction isObject(subject) {\n    return Object.prototype.toString.call(subject) === \"[object Object]\";\n}\nfunction mathAbs(n) {\n    return Math.abs(n);\n}\nfunction mathSign(n) {\n    return Math.sign(n);\n}\nfunction deltaAbs(valueB, valueA) {\n    return mathAbs(valueB - valueA);\n}\nfunction factorAbs(valueB, valueA) {\n    if (valueB === 0 || valueA === 0) return 0;\n    if (mathAbs(valueB) <= mathAbs(valueA)) return 0;\n    const diff = deltaAbs(mathAbs(valueB), mathAbs(valueA));\n    return mathAbs(diff / valueB);\n}\nfunction arrayKeys(array) {\n    return objectKeys(array).map(Number);\n}\nfunction arrayLast(array) {\n    return array[arrayLastIndex(array)];\n}\nfunction arrayLastIndex(array) {\n    return Math.max(0, array.length - 1);\n}\nfunction arrayIsLastIndex(array, index) {\n    return index === arrayLastIndex(array);\n}\nfunction arrayFromNumber(n) {\n    let startAt = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0;\n    return Array.from(Array(n), (_, i)=>startAt + i);\n}\nfunction objectKeys(object) {\n    return Object.keys(object);\n}\nfunction objectsMergeDeep(objectA, objectB) {\n    return [\n        objectA,\n        objectB\n    ].reduce((mergedObjects, currentObject)=>{\n        objectKeys(currentObject).forEach((key)=>{\n            const valueA = mergedObjects[key];\n            const valueB = currentObject[key];\n            const areObjects = isObject(valueA) && isObject(valueB);\n            mergedObjects[key] = areObjects ? objectsMergeDeep(valueA, valueB) : valueB;\n        });\n        return mergedObjects;\n    }, {});\n}\nfunction isMouseEvent(evt, ownerWindow) {\n    return typeof ownerWindow.MouseEvent !== \"undefined\" && evt instanceof ownerWindow.MouseEvent;\n}\nfunction Alignment(align, viewSize) {\n    const predefined = {\n        start,\n        center,\n        end\n    };\n    function start() {\n        return 0;\n    }\n    function center(n) {\n        return end(n) / 2;\n    }\n    function end(n) {\n        return viewSize - n;\n    }\n    function measure(n, index) {\n        if (isString(align)) return predefined[align](n);\n        return align(viewSize, n, index);\n    }\n    const self = {\n        measure\n    };\n    return self;\n}\n_c = Alignment;\nfunction EventStore() {\n    let listeners = [];\n    function add(node, type, handler) {\n        let options = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : {\n            passive: true\n        };\n        let removeListener;\n        if (\"addEventListener\" in node) {\n            node.addEventListener(type, handler, options);\n            removeListener = ()=>node.removeEventListener(type, handler, options);\n        } else {\n            const legacyMediaQueryList = node;\n            legacyMediaQueryList.addListener(handler);\n            removeListener = ()=>legacyMediaQueryList.removeListener(handler);\n        }\n        listeners.push(removeListener);\n        return self;\n    }\n    function clear() {\n        listeners = listeners.filter((remove)=>remove());\n    }\n    const self = {\n        add,\n        clear\n    };\n    return self;\n}\n_c1 = EventStore;\nfunction Animations(ownerDocument, ownerWindow, update, render) {\n    const documentVisibleHandler = EventStore();\n    const timeStep = 1000 / 60;\n    let lastTimeStamp = null;\n    let lag = 0;\n    let animationFrame = 0;\n    function init() {\n        documentVisibleHandler.add(ownerDocument, \"visibilitychange\", ()=>{\n            if (ownerDocument.hidden) reset();\n        });\n    }\n    function destroy() {\n        stop();\n        documentVisibleHandler.clear();\n    }\n    function animate(timeStamp) {\n        if (!lastTimeStamp) lastTimeStamp = timeStamp;\n        const elapsed = timeStamp - lastTimeStamp;\n        lastTimeStamp = timeStamp;\n        lag += elapsed;\n        while(lag >= timeStep){\n            update();\n            lag -= timeStep;\n        }\n        const lagOffset = mathAbs(lag / timeStep);\n        render(lagOffset);\n        if (animationFrame) ownerWindow.requestAnimationFrame(animate);\n    }\n    function start() {\n        if (animationFrame) return;\n        animationFrame = ownerWindow.requestAnimationFrame(animate);\n    }\n    function stop() {\n        ownerWindow.cancelAnimationFrame(animationFrame);\n        lastTimeStamp = null;\n        lag = 0;\n        animationFrame = 0;\n    }\n    function reset() {\n        lastTimeStamp = null;\n        lag = 0;\n    }\n    const self = {\n        init,\n        destroy,\n        start,\n        stop,\n        update,\n        render\n    };\n    return self;\n}\n_c2 = Animations;\nfunction Axis(axis, direction) {\n    const scroll = axis === \"y\" ? \"y\" : \"x\";\n    const cross = axis === \"y\" ? \"x\" : \"y\";\n    const startEdge = getStartEdge();\n    const endEdge = getEndEdge();\n    function measureSize(nodeRect) {\n        const { width, height } = nodeRect;\n        return scroll === \"x\" ? width : height;\n    }\n    function getStartEdge() {\n        if (scroll === \"y\") return \"top\";\n        return direction === \"rtl\" ? \"right\" : \"left\";\n    }\n    function getEndEdge() {\n        if (scroll === \"y\") return \"bottom\";\n        return direction === \"rtl\" ? \"left\" : \"right\";\n    }\n    const self = {\n        scroll,\n        cross,\n        startEdge,\n        endEdge,\n        measureSize\n    };\n    return self;\n}\n_c3 = Axis;\nfunction Limit() {\n    let min = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 0, max = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0;\n    const length = mathAbs(min - max);\n    function reachedMin(n) {\n        return n < min;\n    }\n    function reachedMax(n) {\n        return n > max;\n    }\n    function reachedAny(n) {\n        return reachedMin(n) || reachedMax(n);\n    }\n    function constrain(n) {\n        if (!reachedAny(n)) return n;\n        return reachedMin(n) ? min : max;\n    }\n    function removeOffset(n) {\n        if (!length) return n;\n        return n - length * Math.ceil((n - max) / length);\n    }\n    const self = {\n        length,\n        max,\n        min,\n        constrain,\n        reachedAny,\n        reachedMax,\n        reachedMin,\n        removeOffset\n    };\n    return self;\n}\n_c4 = Limit;\nfunction Counter(max, start, loop) {\n    const { constrain } = Limit(0, max);\n    const loopEnd = max + 1;\n    let counter = withinLimit(start);\n    function withinLimit(n) {\n        return !loop ? constrain(n) : mathAbs((loopEnd + n) % loopEnd);\n    }\n    function get() {\n        return counter;\n    }\n    function set(n) {\n        counter = withinLimit(n);\n        return self;\n    }\n    function add(n) {\n        return clone().set(get() + n);\n    }\n    function clone() {\n        return Counter(max, get(), loop);\n    }\n    const self = {\n        get,\n        set,\n        add,\n        clone\n    };\n    return self;\n}\n_c5 = Counter;\nfunction Direction(direction) {\n    const sign = direction === \"rtl\" ? -1 : 1;\n    function apply(n) {\n        return n * sign;\n    }\n    const self = {\n        apply\n    };\n    return self;\n}\n_c6 = Direction;\nfunction DragHandler(axis, direction, rootNode, ownerDocument, ownerWindow, target, dragTracker, location, animation, scrollTo, scrollBody, scrollTarget, index, eventHandler, percentOfView, dragFree, dragThreshold, skipSnaps, baseFriction, watchDrag) {\n    var _s = $RefreshSig$(), _s1 = $RefreshSig$(), _s2 = $RefreshSig$();\n    const { cross: crossAxis } = axis;\n    const focusNodes = [\n        \"INPUT\",\n        \"SELECT\",\n        \"TEXTAREA\"\n    ];\n    const nonPassiveEvent = {\n        passive: false\n    };\n    const initEvents = EventStore();\n    const dragEvents = EventStore();\n    const goToNextThreshold = Limit(50, 225).constrain(percentOfView.measure(20));\n    const snapForceBoost = {\n        mouse: 300,\n        touch: 400\n    };\n    const freeForceBoost = {\n        mouse: 500,\n        touch: 600\n    };\n    const baseSpeed = dragFree ? 43 : 25;\n    let isMoving = false;\n    let startScroll = 0;\n    let startCross = 0;\n    let pointerIsDown = false;\n    let preventScroll = false;\n    let preventClick = false;\n    let isMouse = false;\n    function init(emblaApi) {\n        if (!watchDrag) return;\n        function downIfAllowed(evt) {\n            if (isBoolean(watchDrag) || watchDrag(emblaApi, evt)) down(evt);\n        }\n        const node = rootNode;\n        initEvents.add(node, \"dragstart\", (evt)=>evt.preventDefault(), nonPassiveEvent).add(node, \"touchmove\", ()=>undefined, nonPassiveEvent).add(node, \"touchend\", ()=>undefined).add(node, \"touchstart\", downIfAllowed).add(node, \"mousedown\", downIfAllowed).add(node, \"touchcancel\", up).add(node, \"contextmenu\", up).add(node, \"click\", click, true);\n    }\n    function destroy() {\n        initEvents.clear();\n        dragEvents.clear();\n    }\n    function addDragEvents() {\n        const node = isMouse ? ownerDocument : rootNode;\n        dragEvents.add(node, \"touchmove\", move, nonPassiveEvent).add(node, \"touchend\", up).add(node, \"mousemove\", move, nonPassiveEvent).add(node, \"mouseup\", up);\n    }\n    function isFocusNode(node) {\n        const nodeName = node.nodeName || \"\";\n        return focusNodes.includes(nodeName);\n    }\n    function forceBoost() {\n        const boost = dragFree ? freeForceBoost : snapForceBoost;\n        const type = isMouse ? \"mouse\" : \"touch\";\n        return boost[type];\n    }\n    function allowedForce(force, targetChanged) {\n        const next = index.add(mathSign(force) * -1);\n        const baseForce = scrollTarget.byDistance(force, !dragFree).distance;\n        if (dragFree || mathAbs(force) < goToNextThreshold) return baseForce;\n        if (skipSnaps && targetChanged) return baseForce * 0.5;\n        return scrollTarget.byIndex(next.get(), 0).distance;\n    }\n    function down(evt) {\n        _s();\n        const isMouseEvt = isMouseEvent(evt, ownerWindow);\n        isMouse = isMouseEvt;\n        if (isMouseEvt && evt.button !== 0) return;\n        if (isFocusNode(evt.target)) return;\n        preventClick = dragFree && isMouseEvt && !evt.buttons && isMoving;\n        isMoving = deltaAbs(target.get(), location.get()) >= 2;\n        pointerIsDown = true;\n        dragTracker.pointerDown(evt);\n        scrollBody.useFriction(0).useDuration(0);\n        target.set(location);\n        addDragEvents();\n        startScroll = dragTracker.readPoint(evt);\n        startCross = dragTracker.readPoint(evt, crossAxis);\n        eventHandler.emit(\"pointerDown\");\n    }\n    _s(down, \"sqSaGCy89nMA8Wg9CUqGs9A9C/0=\");\n    function move(evt) {\n        _s1();\n        const lastScroll = dragTracker.readPoint(evt);\n        const lastCross = dragTracker.readPoint(evt, crossAxis);\n        const diffScroll = deltaAbs(lastScroll, startScroll);\n        const diffCross = deltaAbs(lastCross, startCross);\n        if (!preventScroll && !isMouse) {\n            if (!evt.cancelable) return up(evt);\n            preventScroll = diffScroll > diffCross;\n            if (!preventScroll) return up(evt);\n        }\n        const diff = dragTracker.pointerMove(evt);\n        if (diffScroll > dragThreshold) preventClick = true;\n        scrollBody.useFriction(0.3).useDuration(1);\n        animation.start();\n        target.add(direction.apply(diff));\n        evt.preventDefault();\n    }\n    _s1(move, \"sqSaGCy89nMA8Wg9CUqGs9A9C/0=\");\n    function up(evt) {\n        _s2();\n        const currentLocation = scrollTarget.byDistance(0, false);\n        const targetChanged = currentLocation.index !== index.get();\n        const rawForce = dragTracker.pointerUp(evt) * forceBoost();\n        const force = allowedForce(direction.apply(rawForce), targetChanged);\n        const forceFactor = factorAbs(rawForce, force);\n        const speed = baseSpeed - 10 * forceFactor;\n        const friction = baseFriction + forceFactor / 50;\n        preventScroll = false;\n        pointerIsDown = false;\n        dragEvents.clear();\n        scrollBody.useDuration(speed).useFriction(friction);\n        scrollTo.distance(force, !dragFree);\n        isMouse = false;\n        eventHandler.emit(\"pointerUp\");\n    }\n    _s2(up, \"Qegetg2aDj5UfW/YunANtgW0KUU=\");\n    function click(evt) {\n        if (preventClick) {\n            evt.stopPropagation();\n            evt.preventDefault();\n        }\n    }\n    function pointerDown() {\n        return pointerIsDown;\n    }\n    const self = {\n        init,\n        pointerDown,\n        destroy\n    };\n    return self;\n}\n_c7 = DragHandler;\nfunction DragTracker(axis, ownerWindow) {\n    const logInterval = 170;\n    let startEvent;\n    let lastEvent;\n    function readTime(evt) {\n        return evt.timeStamp;\n    }\n    function readPoint(evt, evtAxis) {\n        const property = evtAxis || axis.scroll;\n        const coord = \"client\".concat(property === \"x\" ? \"X\" : \"Y\");\n        return (isMouseEvent(evt, ownerWindow) ? evt : evt.touches[0])[coord];\n    }\n    function pointerDown(evt) {\n        startEvent = evt;\n        lastEvent = evt;\n        return readPoint(evt);\n    }\n    function pointerMove(evt) {\n        const diff = readPoint(evt) - readPoint(lastEvent);\n        const expired = readTime(evt) - readTime(startEvent) > logInterval;\n        lastEvent = evt;\n        if (expired) startEvent = evt;\n        return diff;\n    }\n    function pointerUp(evt) {\n        if (!startEvent || !lastEvent) return 0;\n        const diffDrag = readPoint(lastEvent) - readPoint(startEvent);\n        const diffTime = readTime(evt) - readTime(startEvent);\n        const expired = readTime(evt) - readTime(lastEvent) > logInterval;\n        const force = diffDrag / diffTime;\n        const isFlick = diffTime && !expired && mathAbs(force) > 0.1;\n        return isFlick ? force : 0;\n    }\n    const self = {\n        pointerDown,\n        pointerMove,\n        pointerUp,\n        readPoint\n    };\n    return self;\n}\n_c8 = DragTracker;\nfunction NodeRects() {\n    function measure(node) {\n        const { offsetTop, offsetLeft, offsetWidth, offsetHeight } = node;\n        const offset = {\n            top: offsetTop,\n            right: offsetLeft + offsetWidth,\n            bottom: offsetTop + offsetHeight,\n            left: offsetLeft,\n            width: offsetWidth,\n            height: offsetHeight\n        };\n        return offset;\n    }\n    const self = {\n        measure\n    };\n    return self;\n}\n_c9 = NodeRects;\nfunction PercentOfView(viewSize) {\n    function measure(n) {\n        return viewSize * (n / 100);\n    }\n    const self = {\n        measure\n    };\n    return self;\n}\n_c10 = PercentOfView;\nfunction ResizeHandler(container, eventHandler, ownerWindow, slides, axis, watchResize, nodeRects) {\n    let resizeObserver;\n    let containerSize;\n    let slideSizes = [];\n    let destroyed = false;\n    function readSize(node) {\n        return axis.measureSize(nodeRects.measure(node));\n    }\n    function init(emblaApi) {\n        if (!watchResize) return;\n        containerSize = readSize(container);\n        slideSizes = slides.map(readSize);\n        function defaultCallback(entries) {\n            for (const entry of entries){\n                const isContainer = entry.target === container;\n                const slideIndex = slides.indexOf(entry.target);\n                const lastSize = isContainer ? containerSize : slideSizes[slideIndex];\n                const newSize = readSize(isContainer ? container : slides[slideIndex]);\n                const diffSize = mathAbs(newSize - lastSize);\n                if (diffSize >= 0.5) {\n                    ownerWindow.requestAnimationFrame(()=>{\n                        emblaApi.reInit();\n                        eventHandler.emit(\"resize\");\n                    });\n                    break;\n                }\n            }\n        }\n        resizeObserver = new ResizeObserver((entries)=>{\n            if (destroyed) return;\n            if (isBoolean(watchResize) || watchResize(emblaApi, entries)) {\n                defaultCallback(entries);\n            }\n        });\n        const observeNodes = [\n            container\n        ].concat(slides);\n        observeNodes.forEach((node)=>resizeObserver.observe(node));\n    }\n    function destroy() {\n        if (resizeObserver) resizeObserver.disconnect();\n        destroyed = true;\n    }\n    const self = {\n        init,\n        destroy\n    };\n    return self;\n}\n_c11 = ResizeHandler;\nfunction ScrollBody(location, offsetLocation, target, baseDuration, baseFriction) {\n    var _s = $RefreshSig$(), _s1 = $RefreshSig$();\n    let bodyVelocity = 0;\n    let scrollDirection = 0;\n    let scrollDuration = baseDuration;\n    let scrollFriction = baseFriction;\n    let rawLocation = location.get();\n    let rawLocationPrevious = 0;\n    function seek() {\n        const diff = target.get() - location.get();\n        const isInstant = !scrollDuration;\n        let directionDiff = 0;\n        if (isInstant) {\n            bodyVelocity = 0;\n            location.set(target);\n            directionDiff = diff;\n        } else {\n            bodyVelocity += diff / scrollDuration;\n            bodyVelocity *= scrollFriction;\n            rawLocation += bodyVelocity;\n            location.add(bodyVelocity);\n            directionDiff = rawLocation - rawLocationPrevious;\n        }\n        scrollDirection = mathSign(directionDiff);\n        rawLocationPrevious = rawLocation;\n        return self;\n    }\n    function settled() {\n        const diff = target.get() - offsetLocation.get();\n        return mathAbs(diff) < 0.001;\n    }\n    function duration() {\n        return scrollDuration;\n    }\n    function direction() {\n        return scrollDirection;\n    }\n    function velocity() {\n        return bodyVelocity;\n    }\n    function useBaseDuration() {\n        _s();\n        return useDuration(baseDuration);\n    }\n    _s(useBaseDuration, \"sqSaGCy89nMA8Wg9CUqGs9A9C/0=\", false, function() {\n        return [\n            useDuration\n        ];\n    });\n    function useBaseFriction() {\n        _s1();\n        return useFriction(baseFriction);\n    }\n    _s1(useBaseFriction, \"Qegetg2aDj5UfW/YunANtgW0KUU=\", false, function() {\n        return [\n            useFriction\n        ];\n    });\n    function useDuration(n) {\n        scrollDuration = n;\n        return self;\n    }\n    function useFriction(n) {\n        scrollFriction = n;\n        return self;\n    }\n    const self = {\n        direction,\n        duration,\n        velocity,\n        seek,\n        settled,\n        useBaseFriction,\n        useBaseDuration,\n        useFriction,\n        useDuration\n    };\n    return self;\n}\n_c12 = ScrollBody;\nfunction ScrollBounds(limit, location, target, scrollBody, percentOfView) {\n    const pullBackThreshold = percentOfView.measure(10);\n    const edgeOffsetTolerance = percentOfView.measure(50);\n    const frictionLimit = Limit(0.1, 0.99);\n    let disabled = false;\n    function shouldConstrain() {\n        if (disabled) return false;\n        if (!limit.reachedAny(target.get())) return false;\n        if (!limit.reachedAny(location.get())) return false;\n        return true;\n    }\n    function constrain(pointerDown) {\n        if (!shouldConstrain()) return;\n        const edge = limit.reachedMin(location.get()) ? \"min\" : \"max\";\n        const diffToEdge = mathAbs(limit[edge] - location.get());\n        const diffToTarget = target.get() - location.get();\n        const friction = frictionLimit.constrain(diffToEdge / edgeOffsetTolerance);\n        target.subtract(diffToTarget * friction);\n        if (!pointerDown && mathAbs(diffToTarget) < pullBackThreshold) {\n            target.set(limit.constrain(target.get()));\n            scrollBody.useDuration(25).useBaseFriction();\n        }\n    }\n    function toggleActive(active) {\n        disabled = !active;\n    }\n    const self = {\n        constrain,\n        toggleActive\n    };\n    return self;\n}\n_c13 = ScrollBounds;\nfunction ScrollContain(viewSize, contentSize, snapsAligned, containScroll, pixelTolerance) {\n    const scrollBounds = Limit(-contentSize + viewSize, 0);\n    const snapsBounded = measureBounded();\n    const scrollContainLimit = findScrollContainLimit();\n    const snapsContained = measureContained();\n    function usePixelTolerance(bound, snap) {\n        return deltaAbs(bound, snap) < 1;\n    }\n    function findScrollContainLimit() {\n        const startSnap = snapsBounded[0];\n        const endSnap = arrayLast(snapsBounded);\n        const min = snapsBounded.lastIndexOf(startSnap);\n        const max = snapsBounded.indexOf(endSnap) + 1;\n        return Limit(min, max);\n    }\n    function measureBounded() {\n        var _s = $RefreshSig$();\n        return snapsAligned.map(_s((snapAligned, index)=>{\n            _s();\n            const { min, max } = scrollBounds;\n            const snap = scrollBounds.constrain(snapAligned);\n            const isFirst = !index;\n            const isLast = arrayIsLastIndex(snapsAligned, index);\n            if (isFirst) return max;\n            if (isLast) return min;\n            if (usePixelTolerance(min, snap)) return min;\n            if (usePixelTolerance(max, snap)) return max;\n            return snap;\n        }, \"QzEVKh94KaBZy2QpCkxKETH1KYA=\", false, function() {\n            return [\n                usePixelTolerance,\n                usePixelTolerance\n            ];\n        })).map((scrollBound)=>parseFloat(scrollBound.toFixed(3)));\n    }\n    function measureContained() {\n        if (contentSize <= viewSize + pixelTolerance) return [\n            scrollBounds.max\n        ];\n        if (containScroll === \"keepSnaps\") return snapsBounded;\n        const { min, max } = scrollContainLimit;\n        return snapsBounded.slice(min, max);\n    }\n    const self = {\n        snapsContained,\n        scrollContainLimit\n    };\n    return self;\n}\n_c14 = ScrollContain;\nfunction ScrollLimit(contentSize, scrollSnaps, loop) {\n    const max = scrollSnaps[0];\n    const min = loop ? max - contentSize : arrayLast(scrollSnaps);\n    const limit = Limit(min, max);\n    const self = {\n        limit\n    };\n    return self;\n}\n_c15 = ScrollLimit;\nfunction ScrollLooper(contentSize, limit, offsetLocation, vectors) {\n    const jointSafety = 0.1;\n    const min = limit.min + jointSafety;\n    const max = limit.max + jointSafety;\n    const { reachedMin, reachedMax } = Limit(min, max);\n    function shouldLoop(direction) {\n        if (direction === 1) return reachedMax(offsetLocation.get());\n        if (direction === -1) return reachedMin(offsetLocation.get());\n        return false;\n    }\n    function loop(direction) {\n        if (!shouldLoop(direction)) return;\n        const loopDistance = contentSize * (direction * -1);\n        vectors.forEach((v)=>v.add(loopDistance));\n    }\n    const self = {\n        loop\n    };\n    return self;\n}\n_c16 = ScrollLooper;\nfunction ScrollProgress(limit) {\n    const { max, length } = limit;\n    function get(n) {\n        const currentLocation = n - max;\n        return length ? currentLocation / -length : 0;\n    }\n    const self = {\n        get\n    };\n    return self;\n}\n_c17 = ScrollProgress;\nfunction ScrollSnaps(axis, alignment, containerRect, slideRects, slidesToScroll) {\n    const { startEdge, endEdge } = axis;\n    const { groupSlides } = slidesToScroll;\n    const alignments = measureSizes().map(alignment.measure);\n    const snaps = measureUnaligned();\n    const snapsAligned = measureAligned();\n    function measureSizes() {\n        return groupSlides(slideRects).map((rects)=>arrayLast(rects)[endEdge] - rects[0][startEdge]).map(mathAbs);\n    }\n    function measureUnaligned() {\n        return slideRects.map((rect)=>containerRect[startEdge] - rect[startEdge]).map((snap)=>-mathAbs(snap));\n    }\n    function measureAligned() {\n        return groupSlides(snaps).map((g)=>g[0]).map((snap, index)=>snap + alignments[index]);\n    }\n    const self = {\n        snaps,\n        snapsAligned\n    };\n    return self;\n}\n_c18 = ScrollSnaps;\nfunction SlideRegistry(containSnaps, containScroll, scrollSnaps, scrollContainLimit, slidesToScroll, slideIndexes) {\n    const { groupSlides } = slidesToScroll;\n    const { min, max } = scrollContainLimit;\n    const slideRegistry = createSlideRegistry();\n    function createSlideRegistry() {\n        const groupedSlideIndexes = groupSlides(slideIndexes);\n        const doNotContain = !containSnaps || containScroll === \"keepSnaps\";\n        if (scrollSnaps.length === 1) return [\n            slideIndexes\n        ];\n        if (doNotContain) return groupedSlideIndexes;\n        return groupedSlideIndexes.slice(min, max).map((group, index, groups)=>{\n            const isFirst = !index;\n            const isLast = arrayIsLastIndex(groups, index);\n            if (isFirst) {\n                const range = arrayLast(groups[0]) + 1;\n                return arrayFromNumber(range);\n            }\n            if (isLast) {\n                const range = arrayLastIndex(slideIndexes) - arrayLast(groups)[0] + 1;\n                return arrayFromNumber(range, arrayLast(groups)[0]);\n            }\n            return group;\n        });\n    }\n    const self = {\n        slideRegistry\n    };\n    return self;\n}\n_c19 = SlideRegistry;\nfunction ScrollTarget(loop, scrollSnaps, contentSize, limit, targetVector) {\n    const { reachedAny, removeOffset, constrain } = limit;\n    function minDistance(distances) {\n        return distances.concat().sort((a, b)=>mathAbs(a) - mathAbs(b))[0];\n    }\n    function findTargetSnap(target) {\n        const distance = loop ? removeOffset(target) : constrain(target);\n        const ascDiffsToSnaps = scrollSnaps.map((scrollSnap)=>scrollSnap - distance).map((diffToSnap)=>shortcut(diffToSnap, 0)).map((diff, i)=>({\n                diff,\n                index: i\n            })).sort((d1, d2)=>mathAbs(d1.diff) - mathAbs(d2.diff));\n        const { index } = ascDiffsToSnaps[0];\n        return {\n            index,\n            distance\n        };\n    }\n    function shortcut(target, direction) {\n        const targets = [\n            target,\n            target + contentSize,\n            target - contentSize\n        ];\n        if (!loop) return targets[0];\n        if (!direction) return minDistance(targets);\n        const matchingTargets = targets.filter((t)=>mathSign(t) === direction);\n        if (matchingTargets.length) return minDistance(matchingTargets);\n        return arrayLast(targets) - contentSize;\n    }\n    function byIndex(index, direction) {\n        const diffToSnap = scrollSnaps[index] - targetVector.get();\n        const distance = shortcut(diffToSnap, direction);\n        return {\n            index,\n            distance\n        };\n    }\n    function byDistance(distance, snap) {\n        const target = targetVector.get() + distance;\n        const { index, distance: targetSnapDistance } = findTargetSnap(target);\n        const reachedBound = !loop && reachedAny(target);\n        if (!snap || reachedBound) return {\n            index,\n            distance\n        };\n        const diffToSnap = scrollSnaps[index] - targetSnapDistance;\n        const snapDistance = distance + shortcut(diffToSnap, 0);\n        return {\n            index,\n            distance: snapDistance\n        };\n    }\n    const self = {\n        byDistance,\n        byIndex,\n        shortcut\n    };\n    return self;\n}\n_c20 = ScrollTarget;\nfunction ScrollTo(animation, indexCurrent, indexPrevious, scrollBody, scrollTarget, targetVector, eventHandler) {\n    function scrollTo(target) {\n        const distanceDiff = target.distance;\n        const indexDiff = target.index !== indexCurrent.get();\n        targetVector.add(distanceDiff);\n        if (distanceDiff) {\n            if (scrollBody.duration()) {\n                animation.start();\n            } else {\n                animation.update();\n                animation.render(1);\n                animation.update();\n            }\n        }\n        if (indexDiff) {\n            indexPrevious.set(indexCurrent.get());\n            indexCurrent.set(target.index);\n            eventHandler.emit(\"select\");\n        }\n    }\n    function distance(n, snap) {\n        const target = scrollTarget.byDistance(n, snap);\n        scrollTo(target);\n    }\n    function index(n, direction) {\n        const targetIndex = indexCurrent.clone().set(n);\n        const target = scrollTarget.byIndex(targetIndex.get(), direction);\n        scrollTo(target);\n    }\n    const self = {\n        distance,\n        index\n    };\n    return self;\n}\n_c21 = ScrollTo;\nfunction SlideFocus(root, slides, slideRegistry, scrollTo, scrollBody, eventStore) {\n    let lastTabPressTime = 0;\n    function init() {\n        eventStore.add(document, \"keydown\", registerTabPress, false);\n        slides.forEach(addSlideFocusEvent);\n    }\n    function registerTabPress(event) {\n        if (event.code === \"Tab\") lastTabPressTime = new Date().getTime();\n    }\n    function addSlideFocusEvent(slide) {\n        var _s = $RefreshSig$();\n        const focus = ()=>{\n            _s();\n            const nowTime = new Date().getTime();\n            const diffTime = nowTime - lastTabPressTime;\n            if (diffTime > 10) return;\n            root.scrollLeft = 0;\n            const index = slides.indexOf(slide);\n            const group = slideRegistry.findIndex((group)=>group.includes(index));\n            if (!isNumber(group)) return;\n            scrollBody.useDuration(0);\n            scrollTo.index(group, 0);\n        };\n        _s(focus, \"sqSaGCy89nMA8Wg9CUqGs9A9C/0=\", false, function() {\n            return [\n                scrollBody.useDuration\n            ];\n        });\n        eventStore.add(slide, \"focus\", focus, {\n            passive: true,\n            capture: true\n        });\n    }\n    const self = {\n        init\n    };\n    return self;\n}\n_c22 = SlideFocus;\nfunction Vector1D(initialValue) {\n    let value = initialValue;\n    function get() {\n        return value;\n    }\n    function set(n) {\n        value = normalizeInput(n);\n    }\n    function add(n) {\n        value += normalizeInput(n);\n    }\n    function subtract(n) {\n        value -= normalizeInput(n);\n    }\n    function normalizeInput(n) {\n        return isNumber(n) ? n : n.get();\n    }\n    const self = {\n        get,\n        set,\n        add,\n        subtract\n    };\n    return self;\n}\n_c23 = Vector1D;\nfunction Translate(axis, direction, container) {\n    const translate = axis.scroll === \"x\" ? x : y;\n    const containerStyle = container.style;\n    let disabled = false;\n    function x(n) {\n        return \"translate3d(\".concat(n, \"px,0px,0px)\");\n    }\n    function y(n) {\n        return \"translate3d(0px,\".concat(n, \"px,0px)\");\n    }\n    function to(target) {\n        if (disabled) return;\n        containerStyle.transform = translate(direction.apply(target));\n    }\n    function toggleActive(active) {\n        disabled = !active;\n    }\n    function clear() {\n        if (disabled) return;\n        containerStyle.transform = \"\";\n        if (!container.getAttribute(\"style\")) container.removeAttribute(\"style\");\n    }\n    const self = {\n        clear,\n        to,\n        toggleActive\n    };\n    return self;\n}\n_c24 = Translate;\nfunction SlideLooper(axis, direction, viewSize, contentSize, slideSizes, slideSizesWithGaps, snaps, scrollSnaps, offsetLocation, slides) {\n    const roundingSafety = 0.5;\n    const ascItems = arrayKeys(slideSizesWithGaps);\n    const descItems = arrayKeys(slideSizesWithGaps).reverse();\n    const loopPoints = startPoints().concat(endPoints());\n    function removeSlideSizes(indexes, from) {\n        return indexes.reduce((a, i)=>{\n            return a - slideSizesWithGaps[i];\n        }, from);\n    }\n    function slidesInGap(indexes, gap) {\n        return indexes.reduce((a, i)=>{\n            const remainingGap = removeSlideSizes(a, gap);\n            return remainingGap > 0 ? a.concat([\n                i\n            ]) : a;\n        }, []);\n    }\n    function findSlideBounds(offset) {\n        return snaps.map((snap, index)=>({\n                start: snap - slideSizes[index] + roundingSafety + offset,\n                end: snap + viewSize - roundingSafety + offset\n            }));\n    }\n    function findLoopPoints(indexes, offset, isEndEdge) {\n        const slideBounds = findSlideBounds(offset);\n        return indexes.map((index)=>{\n            const initial = isEndEdge ? 0 : -contentSize;\n            const altered = isEndEdge ? contentSize : 0;\n            const boundEdge = isEndEdge ? \"end\" : \"start\";\n            const loopPoint = slideBounds[index][boundEdge];\n            return {\n                index,\n                loopPoint,\n                slideLocation: Vector1D(-1),\n                translate: Translate(axis, direction, slides[index]),\n                target: ()=>offsetLocation.get() > loopPoint ? initial : altered\n            };\n        });\n    }\n    function startPoints() {\n        const gap = scrollSnaps[0];\n        const indexes = slidesInGap(descItems, gap);\n        return findLoopPoints(indexes, contentSize, false);\n    }\n    function endPoints() {\n        const gap = viewSize - scrollSnaps[0] - 1;\n        const indexes = slidesInGap(ascItems, gap);\n        return findLoopPoints(indexes, -contentSize, true);\n    }\n    function canLoop() {\n        return loopPoints.every((param)=>{\n            let { index } = param;\n            const otherIndexes = ascItems.filter((i)=>i !== index);\n            return removeSlideSizes(otherIndexes, viewSize) <= 0.1;\n        });\n    }\n    function loop() {\n        loopPoints.forEach((loopPoint)=>{\n            const { target, translate, slideLocation } = loopPoint;\n            const shiftLocation = target();\n            if (shiftLocation === slideLocation.get()) return;\n            translate.to(shiftLocation);\n            slideLocation.set(shiftLocation);\n        });\n    }\n    function clear() {\n        loopPoints.forEach((loopPoint)=>loopPoint.translate.clear());\n    }\n    const self = {\n        canLoop,\n        clear,\n        loop,\n        loopPoints\n    };\n    return self;\n}\n_c25 = SlideLooper;\nfunction SlidesHandler(container, eventHandler, watchSlides) {\n    let mutationObserver;\n    let destroyed = false;\n    function init(emblaApi) {\n        if (!watchSlides) return;\n        function defaultCallback(mutations) {\n            for (const mutation of mutations){\n                if (mutation.type === \"childList\") {\n                    emblaApi.reInit();\n                    eventHandler.emit(\"slidesChanged\");\n                    break;\n                }\n            }\n        }\n        mutationObserver = new MutationObserver((mutations)=>{\n            if (destroyed) return;\n            if (isBoolean(watchSlides) || watchSlides(emblaApi, mutations)) {\n                defaultCallback(mutations);\n            }\n        });\n        mutationObserver.observe(container, {\n            childList: true\n        });\n    }\n    function destroy() {\n        if (mutationObserver) mutationObserver.disconnect();\n        destroyed = true;\n    }\n    const self = {\n        init,\n        destroy\n    };\n    return self;\n}\n_c26 = SlidesHandler;\nfunction SlidesInView(container, slides, eventHandler, threshold) {\n    const intersectionEntryMap = {};\n    let inViewCache = null;\n    let notInViewCache = null;\n    let intersectionObserver;\n    let destroyed = false;\n    function init() {\n        intersectionObserver = new IntersectionObserver((entries)=>{\n            if (destroyed) return;\n            entries.forEach((entry)=>{\n                const index = slides.indexOf(entry.target);\n                intersectionEntryMap[index] = entry;\n            });\n            inViewCache = null;\n            notInViewCache = null;\n            eventHandler.emit(\"slidesInView\");\n        }, {\n            root: container.parentElement,\n            threshold\n        });\n        slides.forEach((slide)=>intersectionObserver.observe(slide));\n    }\n    function destroy() {\n        if (intersectionObserver) intersectionObserver.disconnect();\n        destroyed = true;\n    }\n    function createInViewList(inView) {\n        return objectKeys(intersectionEntryMap).reduce((list, slideIndex)=>{\n            const index = parseInt(slideIndex);\n            const { isIntersecting } = intersectionEntryMap[index];\n            const inViewMatch = inView && isIntersecting;\n            const notInViewMatch = !inView && !isIntersecting;\n            if (inViewMatch || notInViewMatch) list.push(index);\n            return list;\n        }, []);\n    }\n    function get() {\n        let inView = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : true;\n        if (inView && inViewCache) return inViewCache;\n        if (!inView && notInViewCache) return notInViewCache;\n        const slideIndexes = createInViewList(inView);\n        if (inView) inViewCache = slideIndexes;\n        if (!inView) notInViewCache = slideIndexes;\n        return slideIndexes;\n    }\n    const self = {\n        init,\n        destroy,\n        get\n    };\n    return self;\n}\n_c27 = SlidesInView;\nfunction SlideSizes(axis, containerRect, slideRects, slides, readEdgeGap, ownerWindow) {\n    const { measureSize, startEdge, endEdge } = axis;\n    const withEdgeGap = slideRects[0] && readEdgeGap;\n    const startGap = measureStartGap();\n    const endGap = measureEndGap();\n    const slideSizes = slideRects.map(measureSize);\n    const slideSizesWithGaps = measureWithGaps();\n    function measureStartGap() {\n        if (!withEdgeGap) return 0;\n        const slideRect = slideRects[0];\n        return mathAbs(containerRect[startEdge] - slideRect[startEdge]);\n    }\n    function measureEndGap() {\n        if (!withEdgeGap) return 0;\n        const style = ownerWindow.getComputedStyle(arrayLast(slides));\n        return parseFloat(style.getPropertyValue(\"margin-\".concat(endEdge)));\n    }\n    function measureWithGaps() {\n        return slideRects.map((rect, index, rects)=>{\n            const isFirst = !index;\n            const isLast = arrayIsLastIndex(rects, index);\n            if (isFirst) return slideSizes[index] + startGap;\n            if (isLast) return slideSizes[index] + endGap;\n            return rects[index + 1][startEdge] - rect[startEdge];\n        }).map(mathAbs);\n    }\n    const self = {\n        slideSizes,\n        slideSizesWithGaps,\n        startGap,\n        endGap\n    };\n    return self;\n}\n_c28 = SlideSizes;\nfunction SlidesToScroll(axis, direction, viewSize, slidesToScroll, loop, containerRect, slideRects, startGap, endGap, pixelTolerance) {\n    const { startEdge, endEdge } = axis;\n    const groupByNumber = isNumber(slidesToScroll);\n    function byNumber(array, groupSize) {\n        return arrayKeys(array).filter((i)=>i % groupSize === 0).map((i)=>array.slice(i, i + groupSize));\n    }\n    function bySize(array) {\n        if (!array.length) return [];\n        return arrayKeys(array).reduce((groups, rectB)=>{\n            const rectA = arrayLast(groups) || 0;\n            const isFirst = rectA === 0;\n            const isLast = rectB === arrayLastIndex(array);\n            const edgeA = containerRect[startEdge] - slideRects[rectA][startEdge];\n            const edgeB = containerRect[startEdge] - slideRects[rectB][endEdge];\n            const gapA = !loop && isFirst ? direction.apply(startGap) : 0;\n            const gapB = !loop && isLast ? direction.apply(endGap) : 0;\n            const chunkSize = mathAbs(edgeB - gapB - (edgeA + gapA));\n            if (chunkSize > viewSize + pixelTolerance) groups.push(rectB);\n            if (isLast) groups.push(array.length);\n            return groups;\n        }, []).map((currentSize, index, groups)=>{\n            const previousSize = Math.max(groups[index - 1] || 0);\n            return array.slice(previousSize, currentSize);\n        });\n    }\n    function groupSlides(array) {\n        return groupByNumber ? byNumber(array, slidesToScroll) : bySize(array);\n    }\n    const self = {\n        groupSlides\n    };\n    return self;\n}\n_c29 = SlidesToScroll;\nfunction Engine(root, container, slides, ownerDocument, ownerWindow, options, eventHandler) {\n    // Options\n    const { align, axis: scrollAxis, direction: contentDirection, startIndex, loop, duration, dragFree, dragThreshold, inViewThreshold, slidesToScroll: groupSlides, skipSnaps, containScroll, watchResize, watchSlides, watchDrag } = options;\n    // Measurements\n    const pixelTolerance = 2;\n    const nodeRects = NodeRects();\n    const containerRect = nodeRects.measure(container);\n    const slideRects = slides.map(nodeRects.measure);\n    const direction = Direction(contentDirection);\n    const axis = Axis(scrollAxis, contentDirection);\n    const viewSize = axis.measureSize(containerRect);\n    const percentOfView = PercentOfView(viewSize);\n    const alignment = Alignment(align, viewSize);\n    const containSnaps = !loop && !!containScroll;\n    const readEdgeGap = loop || !!containScroll;\n    const { slideSizes, slideSizesWithGaps, startGap, endGap } = SlideSizes(axis, containerRect, slideRects, slides, readEdgeGap, ownerWindow);\n    const slidesToScroll = SlidesToScroll(axis, direction, viewSize, groupSlides, loop, containerRect, slideRects, startGap, endGap, pixelTolerance);\n    const { snaps, snapsAligned } = ScrollSnaps(axis, alignment, containerRect, slideRects, slidesToScroll);\n    const contentSize = -arrayLast(snaps) + arrayLast(slideSizesWithGaps);\n    const { snapsContained, scrollContainLimit } = ScrollContain(viewSize, contentSize, snapsAligned, containScroll, pixelTolerance);\n    const scrollSnaps = containSnaps ? snapsContained : snapsAligned;\n    const { limit } = ScrollLimit(contentSize, scrollSnaps, loop);\n    // Indexes\n    const index = Counter(arrayLastIndex(scrollSnaps), startIndex, loop);\n    const indexPrevious = index.clone();\n    const slideIndexes = arrayKeys(slides);\n    // Animation\n    const update = (param)=>{\n        let { dragHandler, scrollBody, scrollBounds, options: { loop } } = param;\n        if (!loop) scrollBounds.constrain(dragHandler.pointerDown());\n        scrollBody.seek();\n    };\n    const render = (param, lagOffset)=>{\n        let { scrollBody, translate, location, offsetLocation, scrollLooper, slideLooper, dragHandler, animation, eventHandler, options: { loop } } = param;\n        const velocity = scrollBody.velocity();\n        const hasSettled = scrollBody.settled();\n        if (hasSettled && !dragHandler.pointerDown()) {\n            animation.stop();\n            eventHandler.emit(\"settle\");\n        }\n        if (!hasSettled) eventHandler.emit(\"scroll\");\n        offsetLocation.set(location.get() - velocity + velocity * lagOffset);\n        if (loop) {\n            scrollLooper.loop(scrollBody.direction());\n            slideLooper.loop();\n        }\n        translate.to(offsetLocation.get());\n    };\n    const animation = Animations(ownerDocument, ownerWindow, ()=>update(engine), (lagOffset)=>render(engine, lagOffset));\n    // Shared\n    const friction = 0.68;\n    const startLocation = scrollSnaps[index.get()];\n    const location = Vector1D(startLocation);\n    const offsetLocation = Vector1D(startLocation);\n    const target = Vector1D(startLocation);\n    const scrollBody = ScrollBody(location, offsetLocation, target, duration, friction);\n    const scrollTarget = ScrollTarget(loop, scrollSnaps, contentSize, limit, target);\n    const scrollTo = ScrollTo(animation, index, indexPrevious, scrollBody, scrollTarget, target, eventHandler);\n    const scrollProgress = ScrollProgress(limit);\n    const eventStore = EventStore();\n    const slidesInView = SlidesInView(container, slides, eventHandler, inViewThreshold);\n    const { slideRegistry } = SlideRegistry(containSnaps, containScroll, scrollSnaps, scrollContainLimit, slidesToScroll, slideIndexes);\n    const slideFocus = SlideFocus(root, slides, slideRegistry, scrollTo, scrollBody, eventStore);\n    // Engine\n    const engine = {\n        ownerDocument,\n        ownerWindow,\n        eventHandler,\n        containerRect,\n        slideRects,\n        animation,\n        axis,\n        direction,\n        dragHandler: DragHandler(axis, direction, root, ownerDocument, ownerWindow, target, DragTracker(axis, ownerWindow), location, animation, scrollTo, scrollBody, scrollTarget, index, eventHandler, percentOfView, dragFree, dragThreshold, skipSnaps, friction, watchDrag),\n        eventStore,\n        percentOfView,\n        index,\n        indexPrevious,\n        limit,\n        location,\n        offsetLocation,\n        options,\n        resizeHandler: ResizeHandler(container, eventHandler, ownerWindow, slides, axis, watchResize, nodeRects),\n        scrollBody,\n        scrollBounds: ScrollBounds(limit, location, target, scrollBody, percentOfView),\n        scrollLooper: ScrollLooper(contentSize, limit, offsetLocation, [\n            location,\n            offsetLocation,\n            target\n        ]),\n        scrollProgress,\n        scrollSnapList: scrollSnaps.map(scrollProgress.get),\n        scrollSnaps,\n        scrollTarget,\n        scrollTo,\n        slideLooper: SlideLooper(axis, direction, viewSize, contentSize, slideSizes, slideSizesWithGaps, snaps, scrollSnaps, offsetLocation, slides),\n        slideFocus,\n        slidesHandler: SlidesHandler(container, eventHandler, watchSlides),\n        slidesInView,\n        slideIndexes,\n        slideRegistry,\n        slidesToScroll,\n        target,\n        translate: Translate(axis, direction, container)\n    };\n    return engine;\n}\n_c30 = Engine;\nfunction EventHandler() {\n    const listeners = {};\n    let api;\n    function init(emblaApi) {\n        api = emblaApi;\n    }\n    function getListeners(evt) {\n        return listeners[evt] || [];\n    }\n    function emit(evt) {\n        getListeners(evt).forEach((e)=>e(api, evt));\n        return self;\n    }\n    function on(evt, cb) {\n        listeners[evt] = getListeners(evt).concat([\n            cb\n        ]);\n        return self;\n    }\n    function off(evt, cb) {\n        listeners[evt] = getListeners(evt).filter((e)=>e !== cb);\n        return self;\n    }\n    const self = {\n        init,\n        emit,\n        off,\n        on\n    };\n    return self;\n}\n_c31 = EventHandler;\nconst defaultOptions = {\n    align: \"center\",\n    axis: \"x\",\n    container: null,\n    slides: null,\n    containScroll: \"trimSnaps\",\n    direction: \"ltr\",\n    slidesToScroll: 1,\n    inViewThreshold: 0,\n    breakpoints: {},\n    dragFree: false,\n    dragThreshold: 10,\n    loop: false,\n    skipSnaps: false,\n    duration: 25,\n    startIndex: 0,\n    active: true,\n    watchDrag: true,\n    watchResize: true,\n    watchSlides: true\n};\nfunction OptionsHandler(ownerWindow) {\n    function mergeOptions(optionsA, optionsB) {\n        return objectsMergeDeep(optionsA, optionsB || {});\n    }\n    function optionsAtMedia(options) {\n        const optionsAtMedia = options.breakpoints || {};\n        const matchedMediaOptions = objectKeys(optionsAtMedia).filter((media)=>ownerWindow.matchMedia(media).matches).map((media)=>optionsAtMedia[media]).reduce((a, mediaOption)=>mergeOptions(a, mediaOption), {});\n        return mergeOptions(options, matchedMediaOptions);\n    }\n    function optionsMediaQueries(optionsList) {\n        return optionsList.map((options)=>objectKeys(options.breakpoints || {})).reduce((acc, mediaQueries)=>acc.concat(mediaQueries), []).map(ownerWindow.matchMedia);\n    }\n    const self = {\n        mergeOptions,\n        optionsAtMedia,\n        optionsMediaQueries\n    };\n    return self;\n}\n_c32 = OptionsHandler;\nfunction PluginsHandler(optionsHandler) {\n    let activePlugins = [];\n    function init(emblaApi, plugins) {\n        activePlugins = plugins.filter((param)=>{\n            let { options } = param;\n            return optionsHandler.optionsAtMedia(options).active !== false;\n        });\n        activePlugins.forEach((plugin)=>plugin.init(emblaApi, optionsHandler));\n        return plugins.reduce((map, plugin)=>Object.assign(map, {\n                [plugin.name]: plugin\n            }), {});\n    }\n    function destroy() {\n        activePlugins = activePlugins.filter((plugin)=>plugin.destroy());\n    }\n    const self = {\n        init,\n        destroy\n    };\n    return self;\n}\n_c33 = PluginsHandler;\nfunction EmblaCarousel(root, userOptions, userPlugins) {\n    var _s = $RefreshSig$();\n    const ownerDocument = root.ownerDocument;\n    const ownerWindow = ownerDocument.defaultView;\n    const optionsHandler = OptionsHandler(ownerWindow);\n    const pluginsHandler = PluginsHandler(optionsHandler);\n    const mediaHandlers = EventStore();\n    const eventHandler = EventHandler();\n    const { mergeOptions, optionsAtMedia, optionsMediaQueries } = optionsHandler;\n    const { on, off, emit } = eventHandler;\n    const reInit = reActivate;\n    let destroyed = false;\n    let engine;\n    let optionsBase = mergeOptions(defaultOptions, EmblaCarousel.globalOptions);\n    let options = mergeOptions(optionsBase);\n    let pluginList = [];\n    let pluginApis;\n    let container;\n    let slides;\n    function storeElements() {\n        const { container: userContainer, slides: userSlides } = options;\n        const customContainer = isString(userContainer) ? root.querySelector(userContainer) : userContainer;\n        container = customContainer || root.children[0];\n        const customSlides = isString(userSlides) ? container.querySelectorAll(userSlides) : userSlides;\n        slides = [].slice.call(customSlides || container.children);\n    }\n    function createEngine(options) {\n        const engine = Engine(root, container, slides, ownerDocument, ownerWindow, options, eventHandler);\n        if (options.loop && !engine.slideLooper.canLoop()) {\n            const optionsWithoutLoop = Object.assign({}, options, {\n                loop: false\n            });\n            return createEngine(optionsWithoutLoop);\n        }\n        return engine;\n    }\n    function activate(withOptions, withPlugins) {\n        if (destroyed) return;\n        optionsBase = mergeOptions(optionsBase, withOptions);\n        options = optionsAtMedia(optionsBase);\n        pluginList = withPlugins || pluginList;\n        storeElements();\n        engine = createEngine(options);\n        optionsMediaQueries([\n            optionsBase,\n            ...pluginList.map((param)=>{\n                let { options } = param;\n                return options;\n            })\n        ]).forEach((query)=>mediaHandlers.add(query, \"change\", reActivate));\n        if (!options.active) return;\n        engine.translate.to(engine.location.get());\n        engine.animation.init();\n        engine.slidesInView.init();\n        engine.slideFocus.init();\n        engine.eventHandler.init(self);\n        engine.resizeHandler.init(self);\n        engine.slidesHandler.init(self);\n        if (engine.options.loop) engine.slideLooper.loop();\n        if (container.offsetParent && slides.length) engine.dragHandler.init(self);\n        pluginApis = pluginsHandler.init(self, pluginList);\n    }\n    function reActivate(withOptions, withPlugins) {\n        const startIndex = selectedScrollSnap();\n        deActivate();\n        activate(mergeOptions({\n            startIndex\n        }, withOptions), withPlugins);\n        eventHandler.emit(\"reInit\");\n    }\n    function deActivate() {\n        engine.dragHandler.destroy();\n        engine.eventStore.clear();\n        engine.translate.clear();\n        engine.slideLooper.clear();\n        engine.resizeHandler.destroy();\n        engine.slidesHandler.destroy();\n        engine.slidesInView.destroy();\n        engine.animation.destroy();\n        pluginsHandler.destroy();\n        mediaHandlers.clear();\n    }\n    function destroy() {\n        if (destroyed) return;\n        destroyed = true;\n        mediaHandlers.clear();\n        deActivate();\n        eventHandler.emit(\"destroy\");\n    }\n    function scrollTo(index, jump, direction) {\n        _s();\n        if (!options.active || destroyed) return;\n        engine.scrollBody.useBaseFriction().useDuration(jump === true ? 0 : options.duration);\n        engine.scrollTo.index(index, direction || 0);\n    }\n    _s(scrollTo, \"sqSaGCy89nMA8Wg9CUqGs9A9C/0=\");\n    function scrollNext(jump) {\n        const next = engine.index.add(1).get();\n        scrollTo(next, jump, -1);\n    }\n    function scrollPrev(jump) {\n        const prev = engine.index.add(-1).get();\n        scrollTo(prev, jump, 1);\n    }\n    function canScrollNext() {\n        const next = engine.index.add(1).get();\n        return next !== selectedScrollSnap();\n    }\n    function canScrollPrev() {\n        const prev = engine.index.add(-1).get();\n        return prev !== selectedScrollSnap();\n    }\n    function scrollSnapList() {\n        return engine.scrollSnapList;\n    }\n    function scrollProgress() {\n        return engine.scrollProgress.get(engine.location.get());\n    }\n    function selectedScrollSnap() {\n        return engine.index.get();\n    }\n    function previousScrollSnap() {\n        return engine.indexPrevious.get();\n    }\n    function slidesInView() {\n        return engine.slidesInView.get();\n    }\n    function slidesNotInView() {\n        return engine.slidesInView.get(false);\n    }\n    function plugins() {\n        return pluginApis;\n    }\n    function internalEngine() {\n        return engine;\n    }\n    function rootNode() {\n        return root;\n    }\n    function containerNode() {\n        return container;\n    }\n    function slideNodes() {\n        return slides;\n    }\n    const self = {\n        canScrollNext,\n        canScrollPrev,\n        containerNode,\n        internalEngine,\n        destroy,\n        off,\n        on,\n        emit,\n        plugins,\n        previousScrollSnap,\n        reInit,\n        rootNode,\n        scrollNext,\n        scrollPrev,\n        scrollProgress,\n        scrollSnapList,\n        scrollTo,\n        selectedScrollSnap,\n        slideNodes,\n        slidesInView,\n        slidesNotInView\n    };\n    activate(userOptions, userPlugins);\n    setTimeout(()=>eventHandler.emit(\"init\"), 0);\n    return self;\n}\n_c34 = EmblaCarousel;\nEmblaCarousel.globalOptions = undefined;\n //# sourceMappingURL=embla-carousel.esm.js.map\nvar _c, _c1, _c2, _c3, _c4, _c5, _c6, _c7, _c8, _c9, _c10, _c11, _c12, _c13, _c14, _c15, _c16, _c17, _c18, _c19, _c20, _c21, _c22, _c23, _c24, _c25, _c26, _c27, _c28, _c29, _c30, _c31, _c32, _c33, _c34;\n$RefreshReg$(_c, \"Alignment\");\n$RefreshReg$(_c1, \"EventStore\");\n$RefreshReg$(_c2, \"Animations\");\n$RefreshReg$(_c3, \"Axis\");\n$RefreshReg$(_c4, \"Limit\");\n$RefreshReg$(_c5, \"Counter\");\n$RefreshReg$(_c6, \"Direction\");\n$RefreshReg$(_c7, \"DragHandler\");\n$RefreshReg$(_c8, \"DragTracker\");\n$RefreshReg$(_c9, \"NodeRects\");\n$RefreshReg$(_c10, \"PercentOfView\");\n$RefreshReg$(_c11, \"ResizeHandler\");\n$RefreshReg$(_c12, \"ScrollBody\");\n$RefreshReg$(_c13, \"ScrollBounds\");\n$RefreshReg$(_c14, \"ScrollContain\");\n$RefreshReg$(_c15, \"ScrollLimit\");\n$RefreshReg$(_c16, \"ScrollLooper\");\n$RefreshReg$(_c17, \"ScrollProgress\");\n$RefreshReg$(_c18, \"ScrollSnaps\");\n$RefreshReg$(_c19, \"SlideRegistry\");\n$RefreshReg$(_c20, \"ScrollTarget\");\n$RefreshReg$(_c21, \"ScrollTo\");\n$RefreshReg$(_c22, \"SlideFocus\");\n$RefreshReg$(_c23, \"Vector1D\");\n$RefreshReg$(_c24, \"Translate\");\n$RefreshReg$(_c25, \"SlideLooper\");\n$RefreshReg$(_c26, \"SlidesHandler\");\n$RefreshReg$(_c27, \"SlidesInView\");\n$RefreshReg$(_c28, \"SlideSizes\");\n$RefreshReg$(_c29, \"SlidesToScroll\");\n$RefreshReg$(_c30, \"Engine\");\n$RefreshReg$(_c31, \"EventHandler\");\n$RefreshReg$(_c32, \"OptionsHandler\");\n$RefreshReg$(_c33, \"PluginsHandler\");\n$RefreshReg$(_c34, \"EmblaCarousel\");\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9lbWJsYS1jYXJvdXNlbC9lc20vZW1ibGEtY2Fyb3VzZWwuZXNtLmpzIiwibWFwcGluZ3MiOiI7Ozs7QUFBQSxTQUFTQSxTQUFTQyxPQUFPO0lBQ3ZCLE9BQU8sT0FBT0EsWUFBWTtBQUM1QjtBQUNBLFNBQVNDLFNBQVNELE9BQU87SUFDdkIsT0FBTyxPQUFPQSxZQUFZO0FBQzVCO0FBQ0EsU0FBU0UsVUFBVUYsT0FBTztJQUN4QixPQUFPLE9BQU9BLFlBQVk7QUFDNUI7QUFDQSxTQUFTRyxTQUFTSCxPQUFPO0lBQ3ZCLE9BQU9JLE9BQU9DLFNBQVMsQ0FBQ0MsUUFBUSxDQUFDQyxJQUFJLENBQUNQLGFBQWE7QUFDckQ7QUFDQSxTQUFTUSxRQUFRQyxDQUFDO0lBQ2hCLE9BQU9DLEtBQUtDLEdBQUcsQ0FBQ0Y7QUFDbEI7QUFDQSxTQUFTRyxTQUFTSCxDQUFDO0lBQ2pCLE9BQU9DLEtBQUtHLElBQUksQ0FBQ0o7QUFDbkI7QUFDQSxTQUFTSyxTQUFTQyxNQUFNLEVBQUVDLE1BQU07SUFDOUIsT0FBT1IsUUFBUU8sU0FBU0M7QUFDMUI7QUFDQSxTQUFTQyxVQUFVRixNQUFNLEVBQUVDLE1BQU07SUFDL0IsSUFBSUQsV0FBVyxLQUFLQyxXQUFXLEdBQUcsT0FBTztJQUN6QyxJQUFJUixRQUFRTyxXQUFXUCxRQUFRUSxTQUFTLE9BQU87SUFDL0MsTUFBTUUsT0FBT0osU0FBU04sUUFBUU8sU0FBU1AsUUFBUVE7SUFDL0MsT0FBT1IsUUFBUVUsT0FBT0g7QUFDeEI7QUFDQSxTQUFTSSxVQUFVQyxLQUFLO0lBQ3RCLE9BQU9DLFdBQVdELE9BQU9FLEdBQUcsQ0FBQ0M7QUFDL0I7QUFDQSxTQUFTQyxVQUFVSixLQUFLO0lBQ3RCLE9BQU9BLEtBQUssQ0FBQ0ssZUFBZUwsT0FBTztBQUNyQztBQUNBLFNBQVNLLGVBQWVMLEtBQUs7SUFDM0IsT0FBT1YsS0FBS2dCLEdBQUcsQ0FBQyxHQUFHTixNQUFNTyxNQUFN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QUFhc0QsSUFBSSxDQUFDLFNBQVM7SUFDNUMsT0FBT3BJO0FBQ1Q7T0EvS1M2YztBQWdMVEEsY0FBY1EsYUFBYSxHQUFHMVc7QUFFTSxDQUNwQyw4Q0FBOEMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL2VtYmxhLWNhcm91c2VsL2VzbS9lbWJsYS1jYXJvdXNlbC5lc20uanM/MmQ4MCJdLCJzb3VyY2VzQ29udGVudCI6WyJmdW5jdGlvbiBpc051bWJlcihzdWJqZWN0KSB7XG4gIHJldHVybiB0eXBlb2Ygc3ViamVjdCA9PT0gJ251bWJlcic7XG59XG5mdW5jdGlvbiBpc1N0cmluZyhzdWJqZWN0KSB7XG4gIHJldHVybiB0eXBlb2Ygc3ViamVjdCA9PT0gJ3N0cmluZyc7XG59XG5mdW5jdGlvbiBpc0Jvb2xlYW4oc3ViamVjdCkge1xuICByZXR1cm4gdHlwZW9mIHN1YmplY3QgPT09ICdib29sZWFuJztcbn1cbmZ1bmN0aW9uIGlzT2JqZWN0KHN1YmplY3QpIHtcbiAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChzdWJqZWN0KSA9PT0gJ1tvYmplY3QgT2JqZWN0XSc7XG59XG5mdW5jdGlvbiBtYXRoQWJzKG4pIHtcbiAgcmV0dXJuIE1hdGguYWJzKG4pO1xufVxuZnVuY3Rpb24gbWF0aFNpZ24obikge1xuICByZXR1cm4gTWF0aC5zaWduKG4pO1xufVxuZnVuY3Rpb24gZGVsdGFBYnModmFsdWVCLCB2YWx1ZUEpIHtcbiAgcmV0dXJuIG1hdGhBYnModmFsdWVCIC0gdmFsdWVBKTtcbn1cbmZ1bmN0aW9uIGZhY3RvckFicyh2YWx1ZUIsIHZhbHVlQSkge1xuICBpZiAodmFsdWVCID09PSAwIHx8IHZhbHVlQSA9PT0gMCkgcmV0dXJuIDA7XG4gIGlmIChtYXRoQWJzKHZhbHVlQikgPD0gbWF0aEFicyh2YWx1ZUEpKSByZXR1cm4gMDtcbiAgY29uc3QgZGlmZiA9IGRlbHRhQWJzKG1hdGhBYnModmFsdWVCKSwgbWF0aEFicyh2YWx1ZUEpKTtcbiAgcmV0dXJuIG1hdGhBYnMoZGlmZiAvIHZhbHVlQik7XG59XG5mdW5jdGlvbiBhcnJheUtleXMoYXJyYXkpIHtcbiAgcmV0dXJuIG9iamVjdEtleXMoYXJyYXkpLm1hcChOdW1iZXIpO1xufVxuZnVuY3Rpb24gYXJyYXlMYXN0KGFycmF5KSB7XG4gIHJldHVybiBhcnJheVthcnJheUxhc3RJbmRleChhcnJheSldO1xufVxuZnVuY3Rpb24gYXJyYXlMYXN0SW5kZXgoYXJyYXkpIHtcbiAgcmV0dXJuIE1hdGgubWF4KDAsIGFycmF5Lmxlbmd0aCAtIDEpO1xufVxuZnVuY3Rpb24gYXJyYXlJc0xhc3RJbmRleChhcnJheSwgaW5kZXgpIHtcbiAgcmV0dXJuIGluZGV4ID09PSBhcnJheUxhc3RJbmRleChhcnJheSk7XG59XG5mdW5jdGlvbiBhcnJheUZyb21OdW1iZXIobiwgc3RhcnRBdCA9IDApIHtcbiAgcmV0dXJuIEFycmF5LmZyb20oQXJyYXkobiksIChfLCBpKSA9PiBzdGFydEF0ICsgaSk7XG59XG5mdW5jdGlvbiBvYmplY3RLZXlzKG9iamVjdCkge1xuICByZXR1cm4gT2JqZWN0LmtleXMob2JqZWN0KTtcbn1cbmZ1bmN0aW9uIG9iamVjdHNNZXJnZURlZXAob2JqZWN0QSwgb2JqZWN0Qikge1xuICByZXR1cm4gW29iamVjdEEsIG9iamVjdEJdLnJlZHVjZSgobWVyZ2VkT2JqZWN0cywgY3VycmVudE9iamVjdCkgPT4ge1xuICAgIG9iamVjdEtleXMoY3VycmVudE9iamVjdCkuZm9yRWFjaChrZXkgPT4ge1xuICAgICAgY29uc3QgdmFsdWVBID0gbWVyZ2VkT2JqZWN0c1trZXldO1xuICAgICAgY29uc3QgdmFsdWVCID0gY3VycmVudE9iamVjdFtrZXldO1xuICAgICAgY29uc3QgYXJlT2JqZWN0cyA9IGlzT2JqZWN0KHZhbHVlQSkgJiYgaXNPYmplY3QodmFsdWVCKTtcbiAgICAgIG1lcmdlZE9iamVjdHNba2V5XSA9IGFyZU9iamVjdHMgPyBvYmplY3RzTWVyZ2VEZWVwKHZhbHVlQSwgdmFsdWVCKSA6IHZhbHVlQjtcbiAgICB9KTtcbiAgICByZXR1cm4gbWVyZ2VkT2JqZWN0cztcbiAgfSwge30pO1xufVxuZnVuY3Rpb24gaXNNb3VzZUV2ZW50KGV2dCwgb3duZXJXaW5kb3cpIHtcbiAgcmV0dXJuIHR5cGVvZiBvd25lcldpbmRvdy5Nb3VzZUV2ZW50ICE9PSAndW5kZWZpbmVkJyAmJiBldnQgaW5zdGFuY2VvZiBvd25lcldpbmRvdy5Nb3VzZUV2ZW50O1xufVxuXG5mdW5jdGlvbiBBbGlnbm1lbnQoYWxpZ24sIHZpZXdTaXplKSB7XG4gIGNvbnN0IHByZWRlZmluZWQgPSB7XG4gICAgc3RhcnQsXG4gICAgY2VudGVyLFxuICAgIGVuZFxuICB9O1xuICBmdW5jdGlvbiBzdGFydCgpIHtcbiAgICByZXR1cm4gMDtcbiAgfVxuICBmdW5jdGlvbiBjZW50ZXIobikge1xuICAgIHJldHVybiBlbmQobikgLyAyO1xuICB9XG4gIGZ1bmN0aW9uIGVuZChuKSB7XG4gICAgcmV0dXJuIHZpZXdTaXplIC0gbjtcbiAgfVxuICBmdW5jdGlvbiBtZWFzdXJlKG4sIGluZGV4KSB7XG4gICAgaWYgKGlzU3RyaW5nKGFsaWduKSkgcmV0dXJuIHByZWRlZmluZWRbYWxpZ25dKG4pO1xuICAgIHJldHVybiBhbGlnbih2aWV3U2l6ZSwgbiwgaW5kZXgpO1xuICB9XG4gIGNvbnN0IHNlbGYgPSB7XG4gICAgbWVhc3VyZVxuICB9O1xuICByZXR1cm4gc2VsZjtcbn1cblxuZnVuY3Rpb24gRXZlbnRTdG9yZSgpIHtcbiAgbGV0IGxpc3RlbmVycyA9IFtdO1xuICBmdW5jdGlvbiBhZGQobm9kZSwgdHlwZSwgaGFuZGxlciwgb3B0aW9ucyA9IHtcbiAgICBwYXNzaXZlOiB0cnVlXG4gIH0pIHtcbiAgICBsZXQgcmVtb3ZlTGlzdGVuZXI7XG4gICAgaWYgKCdhZGRFdmVudExpc3RlbmVyJyBpbiBub2RlKSB7XG4gICAgICBub2RlLmFkZEV2ZW50TGlzdGVuZXIodHlwZSwgaGFuZGxlciwgb3B0aW9ucyk7XG4gICAgICByZW1vdmVMaXN0ZW5lciA9ICgpID0+IG5vZGUucmVtb3ZlRXZlbnRMaXN0ZW5lcih0eXBlLCBoYW5kbGVyLCBvcHRpb25zKTtcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3QgbGVnYWN5TWVkaWFRdWVyeUxpc3QgPSBub2RlO1xuICAgICAgbGVnYWN5TWVkaWFRdWVyeUxpc3QuYWRkTGlzdGVuZXIoaGFuZGxlcik7XG4gICAgICByZW1vdmVMaXN0ZW5lciA9ICgpID0+IGxlZ2FjeU1lZGlhUXVlcnlMaXN0LnJlbW92ZUxpc3RlbmVyKGhhbmRsZXIpO1xuICAgIH1cbiAgICBsaXN0ZW5lcnMucHVzaChyZW1vdmVMaXN0ZW5lcik7XG4gICAgcmV0dXJuIHNlbGY7XG4gIH1cbiAgZnVuY3Rpb24gY2xlYXIoKSB7XG4gICAgbGlzdGVuZXJzID0gbGlzdGVuZXJzLmZpbHRlcihyZW1vdmUgPT4gcmVtb3ZlKCkpO1xuICB9XG4gIGNvbnN0IHNlbGYgPSB7XG4gICAgYWRkLFxuICAgIGNsZWFyXG4gIH07XG4gIHJldHVybiBzZWxmO1xufVxuXG5mdW5jdGlvbiBBbmltYXRpb25zKG93bmVyRG9jdW1lbnQsIG93bmVyV2luZG93LCB1cGRhdGUsIHJlbmRlcikge1xuICBjb25zdCBkb2N1bWVudFZpc2libGVIYW5kbGVyID0gRXZlbnRTdG9yZSgpO1xuICBjb25zdCB0aW1lU3RlcCA9IDEwMDAgLyA2MDtcbiAgbGV0IGxhc3RUaW1lU3RhbXAgPSBudWxsO1xuICBsZXQgbGFnID0gMDtcbiAgbGV0IGFuaW1hdGlvbkZyYW1lID0gMDtcbiAgZnVuY3Rpb24gaW5pdCgpIHtcbiAgICBkb2N1bWVudFZpc2libGVIYW5kbGVyLmFkZChvd25lckRvY3VtZW50LCAndmlzaWJpbGl0eWNoYW5nZScsICgpID0+IHtcbiAgICAgIGlmIChvd25lckRvY3VtZW50LmhpZGRlbikgcmVzZXQoKTtcbiAgICB9KTtcbiAgfVxuICBmdW5jdGlvbiBkZXN0cm95KCkge1xuICAgIHN0b3AoKTtcbiAgICBkb2N1bWVudFZpc2libGVIYW5kbGVyLmNsZWFyKCk7XG4gIH1cbiAgZnVuY3Rpb24gYW5pbWF0ZSh0aW1lU3RhbXApIHtcbiAgICBpZiAoIWxhc3RUaW1lU3RhbXApIGxhc3RUaW1lU3RhbXAgPSB0aW1lU3RhbXA7XG4gICAgY29uc3QgZWxhcHNlZCA9IHRpbWVTdGFtcCAtIGxhc3RUaW1lU3RhbXA7XG4gICAgbGFzdFRpbWVTdGFtcCA9IHRpbWVTdGFtcDtcbiAgICBsYWcgKz0gZWxhcHNlZDtcbiAgICB3aGlsZSAobGFnID49IHRpbWVTdGVwKSB7XG4gICAgICB1cGRhdGUoKTtcbiAgICAgIGxhZyAtPSB0aW1lU3RlcDtcbiAgICB9XG4gICAgY29uc3QgbGFnT2Zmc2V0ID0gbWF0aEFicyhsYWcgLyB0aW1lU3RlcCk7XG4gICAgcmVuZGVyKGxhZ09mZnNldCk7XG4gICAgaWYgKGFuaW1hdGlvbkZyYW1lKSBvd25lcldpbmRvdy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUoYW5pbWF0ZSk7XG4gIH1cbiAgZnVuY3Rpb24gc3RhcnQoKSB7XG4gICAgaWYgKGFuaW1hdGlvbkZyYW1lKSByZXR1cm47XG4gICAgYW5pbWF0aW9uRnJhbWUgPSBvd25lcldpbmRvdy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUoYW5pbWF0ZSk7XG4gIH1cbiAgZnVuY3Rpb24gc3RvcCgpIHtcbiAgICBvd25lcldpbmRvdy5jYW5jZWxBbmltYXRpb25GcmFtZShhbmltYXRpb25GcmFtZSk7XG4gICAgbGFzdFRpbWVTdGFtcCA9IG51bGw7XG4gICAgbGFnID0gMDtcbiAgICBhbmltYXRpb25GcmFtZSA9IDA7XG4gIH1cbiAgZnVuY3Rpb24gcmVzZXQoKSB7XG4gICAgbGFzdFRpbWVTdGFtcCA9IG51bGw7XG4gICAgbGFnID0gMDtcbiAgfVxuICBjb25zdCBzZWxmID0ge1xuICAgIGluaXQsXG4gICAgZGVzdHJveSxcbiAgICBzdGFydCxcbiAgICBzdG9wLFxuICAgIHVwZGF0ZSxcbiAgICByZW5kZXJcbiAgfTtcbiAgcmV0dXJuIHNlbGY7XG59XG5cbmZ1bmN0aW9uIEF4aXMoYXhpcywgZGlyZWN0aW9uKSB7XG4gIGNvbnN0IHNjcm9sbCA9IGF4aXMgPT09ICd5JyA/ICd5JyA6ICd4JztcbiAgY29uc3QgY3Jvc3MgPSBheGlzID09PSAneScgPyAneCcgOiAneSc7XG4gIGNvbnN0IHN0YXJ0RWRnZSA9IGdldFN0YXJ0RWRnZSgpO1xuICBjb25zdCBlbmRFZGdlID0gZ2V0RW5kRWRnZSgpO1xuICBmdW5jdGlvbiBtZWFzdXJlU2l6ZShub2RlUmVjdCkge1xuICAgIGNvbnN0IHtcbiAgICAgIHdpZHRoLFxuICAgICAgaGVpZ2h0XG4gICAgfSA9IG5vZGVSZWN0O1xuICAgIHJldHVybiBzY3JvbGwgPT09ICd4JyA/IHdpZHRoIDogaGVpZ2h0O1xuICB9XG4gIGZ1bmN0aW9uIGdldFN0YXJ0RWRnZSgpIHtcbiAgICBpZiAoc2Nyb2xsID09PSAneScpIHJldHVybiAndG9wJztcbiAgICByZXR1cm4gZGlyZWN0aW9uID09PSAncnRsJyA/ICdyaWdodCcgOiAnbGVmdCc7XG4gIH1cbiAgZnVuY3Rpb24gZ2V0RW5kRWRnZSgpIHtcbiAgICBpZiAoc2Nyb2xsID09PSAneScpIHJldHVybiAnYm90dG9tJztcbiAgICByZXR1cm4gZGlyZWN0aW9uID09PSAncnRsJyA/ICdsZWZ0JyA6ICdyaWdodCc7XG4gIH1cbiAgY29uc3Qgc2VsZiA9IHtcbiAgICBzY3JvbGwsXG4gICAgY3Jvc3MsXG4gICAgc3RhcnRFZGdlLFxuICAgIGVuZEVkZ2UsXG4gICAgbWVhc3VyZVNpemVcbiAgfTtcbiAgcmV0dXJuIHNlbGY7XG59XG5cbmZ1bmN0aW9uIExpbWl0KG1pbiA9IDAsIG1heCA9IDApIHtcbiAgY29uc3QgbGVuZ3RoID0gbWF0aEFicyhtaW4gLSBtYXgpO1xuICBmdW5jdGlvbiByZWFjaGVkTWluKG4pIHtcbiAgICByZXR1cm4gbiA8IG1pbjtcbiAgfVxuICBmdW5jdGlvbiByZWFjaGVkTWF4KG4pIHtcbiAgICByZXR1cm4gbiA+IG1heDtcbiAgfVxuICBmdW5jdGlvbiByZWFjaGVkQW55KG4pIHtcbiAgICByZXR1cm4gcmVhY2hlZE1pbihuKSB8fCByZWFjaGVkTWF4KG4pO1xuICB9XG4gIGZ1bmN0aW9uIGNvbnN0cmFpbihuKSB7XG4gICAgaWYgKCFyZWFjaGVkQW55KG4pKSByZXR1cm4gbjtcbiAgICByZXR1cm4gcmVhY2hlZE1pbihuKSA/IG1pbiA6IG1heDtcbiAgfVxuICBmdW5jdGlvbiByZW1vdmVPZmZzZXQobikge1xuICAgIGlmICghbGVuZ3RoKSByZXR1cm4gbjtcbiAgICByZXR1cm4gbiAtIGxlbmd0aCAqIE1hdGguY2VpbCgobiAtIG1heCkgLyBsZW5ndGgpO1xuICB9XG4gIGNvbnN0IHNlbGYgPSB7XG4gICAgbGVuZ3RoLFxuICAgIG1heCxcbiAgICBtaW4sXG4gICAgY29uc3RyYWluLFxuICAgIHJlYWNoZWRBbnksXG4gICAgcmVhY2hlZE1heCxcbiAgICByZWFjaGVkTWluLFxuICAgIHJlbW92ZU9mZnNldFxuICB9O1xuICByZXR1cm4gc2VsZjtcbn1cblxuZnVuY3Rpb24gQ291bnRlcihtYXgsIHN0YXJ0LCBsb29wKSB7XG4gIGNvbnN0IHtcbiAgICBjb25zdHJhaW5cbiAgfSA9IExpbWl0KDAsIG1heCk7XG4gIGNvbnN0IGxvb3BFbmQgPSBtYXggKyAxO1xuICBsZXQgY291bnRlciA9IHdpdGhpbkxpbWl0KHN0YXJ0KTtcbiAgZnVuY3Rpb24gd2l0aGluTGltaXQobikge1xuICAgIHJldHVybiAhbG9vcCA/IGNvbnN0cmFpbihuKSA6IG1hdGhBYnMoKGxvb3BFbmQgKyBuKSAlIGxvb3BFbmQpO1xuICB9XG4gIGZ1bmN0aW9uIGdldCgpIHtcbiAgICByZXR1cm4gY291bnRlcjtcbiAgfVxuICBmdW5jdGlvbiBzZXQobikge1xuICAgIGNvdW50ZXIgPSB3aXRoaW5MaW1pdChuKTtcbiAgICByZXR1cm4gc2VsZjtcbiAgfVxuICBmdW5jdGlvbiBhZGQobikge1xuICAgIHJldHVybiBjbG9uZSgpLnNldChnZXQoKSArIG4pO1xuICB9XG4gIGZ1bmN0aW9uIGNsb25lKCkge1xuICAgIHJldHVybiBDb3VudGVyKG1heCwgZ2V0KCksIGxvb3ApO1xuICB9XG4gIGNvbnN0IHNlbGYgPSB7XG4gICAgZ2V0LFxuICAgIHNldCxcbiAgICBhZGQsXG4gICAgY2xvbmVcbiAgfTtcbiAgcmV0dXJuIHNlbGY7XG59XG5cbmZ1bmN0aW9uIERpcmVjdGlvbihkaXJlY3Rpb24pIHtcbiAgY29uc3Qgc2lnbiA9IGRpcmVjdGlvbiA9PT0gJ3J0bCcgPyAtMSA6IDE7XG4gIGZ1bmN0aW9uIGFwcGx5KG4pIHtcbiAgICByZXR1cm4gbiAqIHNpZ247XG4gIH1cbiAgY29uc3Qgc2VsZiA9IHtcbiAgICBhcHBseVxuICB9O1xuICByZXR1cm4gc2VsZjtcbn1cblxuZnVuY3Rpb24gRHJhZ0hhbmRsZXIoYXhpcywgZGlyZWN0aW9uLCByb290Tm9kZSwgb3duZXJEb2N1bWVudCwgb3duZXJXaW5kb3csIHRhcmdldCwgZHJhZ1RyYWNrZXIsIGxvY2F0aW9uLCBhbmltYXRpb24sIHNjcm9sbFRvLCBzY3JvbGxCb2R5LCBzY3JvbGxUYXJnZXQsIGluZGV4LCBldmVudEhhbmRsZXIsIHBlcmNlbnRPZlZpZXcsIGRyYWdGcmVlLCBkcmFnVGhyZXNob2xkLCBza2lwU25hcHMsIGJhc2VGcmljdGlvbiwgd2F0Y2hEcmFnKSB7XG4gIGNvbnN0IHtcbiAgICBjcm9zczogY3Jvc3NBeGlzXG4gIH0gPSBheGlzO1xuICBjb25zdCBmb2N1c05vZGVzID0gWydJTlBVVCcsICdTRUxFQ1QnLCAnVEVYVEFSRUEnXTtcbiAgY29uc3Qgbm9uUGFzc2l2ZUV2ZW50ID0ge1xuICAgIHBhc3NpdmU6IGZhbHNlXG4gIH07XG4gIGNvbnN0IGluaXRFdmVudHMgPSBFdmVudFN0b3JlKCk7XG4gIGNvbnN0IGRyYWdFdmVudHMgPSBFdmVudFN0b3JlKCk7XG4gIGNvbnN0IGdvVG9OZXh0VGhyZXNob2xkID0gTGltaXQoNTAsIDIyNSkuY29uc3RyYWluKHBlcmNlbnRPZlZpZXcubWVhc3VyZSgyMCkpO1xuICBjb25zdCBzbmFwRm9yY2VCb29zdCA9IHtcbiAgICBtb3VzZTogMzAwLFxuICAgIHRvdWNoOiA0MDBcbiAgfTtcbiAgY29uc3QgZnJlZUZvcmNlQm9vc3QgPSB7XG4gICAgbW91c2U6IDUwMCxcbiAgICB0b3VjaDogNjAwXG4gIH07XG4gIGNvbnN0IGJhc2VTcGVlZCA9IGRyYWdGcmVlID8gNDMgOiAyNTtcbiAgbGV0IGlzTW92aW5nID0gZmFsc2U7XG4gIGxldCBzdGFydFNjcm9sbCA9IDA7XG4gIGxldCBzdGFydENyb3NzID0gMDtcbiAgbGV0IHBvaW50ZXJJc0Rvd24gPSBmYWxzZTtcbiAgbGV0IHByZXZlbnRTY3JvbGwgPSBmYWxzZTtcbiAgbGV0IHByZXZlbnRDbGljayA9IGZhbHNlO1xuICBsZXQgaXNNb3VzZSA9IGZhbHNlO1xuICBmdW5jdGlvbiBpbml0KGVtYmxhQXBpKSB7XG4gICAgaWYgKCF3YXRjaERyYWcpIHJldHVybjtcbiAgICBmdW5jdGlvbiBkb3duSWZBbGxvd2VkKGV2dCkge1xuICAgICAgaWYgKGlzQm9vbGVhbih3YXRjaERyYWcpIHx8IHdhdGNoRHJhZyhlbWJsYUFwaSwgZXZ0KSkgZG93bihldnQpO1xuICAgIH1cbiAgICBjb25zdCBub2RlID0gcm9vdE5vZGU7XG4gICAgaW5pdEV2ZW50cy5hZGQobm9kZSwgJ2RyYWdzdGFydCcsIGV2dCA9PiBldnQucHJldmVudERlZmF1bHQoKSwgbm9uUGFzc2l2ZUV2ZW50KS5hZGQobm9kZSwgJ3RvdWNobW92ZScsICgpID0+IHVuZGVmaW5lZCwgbm9uUGFzc2l2ZUV2ZW50KS5hZGQobm9kZSwgJ3RvdWNoZW5kJywgKCkgPT4gdW5kZWZpbmVkKS5hZGQobm9kZSwgJ3RvdWNoc3RhcnQnLCBkb3duSWZBbGxvd2VkKS5hZGQobm9kZSwgJ21vdXNlZG93bicsIGRvd25JZkFsbG93ZWQpLmFkZChub2RlLCAndG91Y2hjYW5jZWwnLCB1cCkuYWRkKG5vZGUsICdjb250ZXh0bWVudScsIHVwKS5hZGQobm9kZSwgJ2NsaWNrJywgY2xpY2ssIHRydWUpO1xuICB9XG4gIGZ1bmN0aW9uIGRlc3Ryb3koKSB7XG4gICAgaW5pdEV2ZW50cy5jbGVhcigpO1xuICAgIGRyYWdFdmVudHMuY2xlYXIoKTtcbiAgfVxuICBmdW5jdGlvbiBhZGREcmFnRXZlbnRzKCkge1xuICAgIGNvbnN0IG5vZGUgPSBpc01vdXNlID8gb3duZXJEb2N1bWVudCA6IHJvb3ROb2RlO1xuICAgIGRyYWdFdmVudHMuYWRkKG5vZGUsICd0b3VjaG1vdmUnLCBtb3ZlLCBub25QYXNzaXZlRXZlbnQpLmFkZChub2RlLCAndG91Y2hlbmQnLCB1cCkuYWRkKG5vZGUsICdtb3VzZW1vdmUnLCBtb3ZlLCBub25QYXNzaXZlRXZlbnQpLmFkZChub2RlLCAnbW91c2V1cCcsIHVwKTtcbiAgfVxuICBmdW5jdGlvbiBpc0ZvY3VzTm9kZShub2RlKSB7XG4gICAgY29uc3Qgbm9kZU5hbWUgPSBub2RlLm5vZGVOYW1lIHx8ICcnO1xuICAgIHJldHVybiBmb2N1c05vZGVzLmluY2x1ZGVzKG5vZGVOYW1lKTtcbiAgfVxuICBmdW5jdGlvbiBmb3JjZUJvb3N0KCkge1xuICAgIGNvbnN0IGJvb3N0ID0gZHJhZ0ZyZWUgPyBmcmVlRm9yY2VCb29zdCA6IHNuYXBGb3JjZUJvb3N0O1xuICAgIGNvbnN0IHR5cGUgPSBpc01vdXNlID8gJ21vdXNlJyA6ICd0b3VjaCc7XG4gICAgcmV0dXJuIGJvb3N0W3R5cGVdO1xuICB9XG4gIGZ1bmN0aW9uIGFsbG93ZWRGb3JjZShmb3JjZSwgdGFyZ2V0Q2hhbmdlZCkge1xuICAgIGNvbnN0IG5leHQgPSBpbmRleC5hZGQobWF0aFNpZ24oZm9yY2UpICogLTEpO1xuICAgIGNvbnN0IGJhc2VGb3JjZSA9IHNjcm9sbFRhcmdldC5ieURpc3RhbmNlKGZvcmNlLCAhZHJhZ0ZyZWUpLmRpc3RhbmNlO1xuICAgIGlmIChkcmFnRnJlZSB8fCBtYXRoQWJzKGZvcmNlKSA8IGdvVG9OZXh0VGhyZXNob2xkKSByZXR1cm4gYmFzZUZvcmNlO1xuICAgIGlmIChza2lwU25hcHMgJiYgdGFyZ2V0Q2hhbmdlZCkgcmV0dXJuIGJhc2VGb3JjZSAqIDAuNTtcbiAgICByZXR1cm4gc2Nyb2xsVGFyZ2V0LmJ5SW5kZXgobmV4dC5nZXQoKSwgMCkuZGlzdGFuY2U7XG4gIH1cbiAgZnVuY3Rpb24gZG93bihldnQpIHtcbiAgICBjb25zdCBpc01vdXNlRXZ0ID0gaXNNb3VzZUV2ZW50KGV2dCwgb3duZXJXaW5kb3cpO1xuICAgIGlzTW91c2UgPSBpc01vdXNlRXZ0O1xuICAgIGlmIChpc01vdXNlRXZ0ICYmIGV2dC5idXR0b24gIT09IDApIHJldHVybjtcbiAgICBpZiAoaXNGb2N1c05vZGUoZXZ0LnRhcmdldCkpIHJldHVybjtcbiAgICBwcmV2ZW50Q2xpY2sgPSBkcmFnRnJlZSAmJiBpc01vdXNlRXZ0ICYmICFldnQuYnV0dG9ucyAmJiBpc01vdmluZztcbiAgICBpc01vdmluZyA9IGRlbHRhQWJzKHRhcmdldC5nZXQoKSwgbG9jYXRpb24uZ2V0KCkpID49IDI7XG4gICAgcG9pbnRlcklzRG93biA9IHRydWU7XG4gICAgZHJhZ1RyYWNrZXIucG9pbnRlckRvd24oZXZ0KTtcbiAgICBzY3JvbGxCb2R5LnVzZUZyaWN0aW9uKDApLnVzZUR1cmF0aW9uKDApO1xuICAgIHRhcmdldC5zZXQobG9jYXRpb24pO1xuICAgIGFkZERyYWdFdmVudHMoKTtcbiAgICBzdGFydFNjcm9sbCA9IGRyYWdUcmFja2VyLnJlYWRQb2ludChldnQpO1xuICAgIHN0YXJ0Q3Jvc3MgPSBkcmFnVHJhY2tlci5yZWFkUG9pbnQoZXZ0LCBjcm9zc0F4aXMpO1xuICAgIGV2ZW50SGFuZGxlci5lbWl0KCdwb2ludGVyRG93bicpO1xuICB9XG4gIGZ1bmN0aW9uIG1vdmUoZXZ0KSB7XG4gICAgY29uc3QgbGFzdFNjcm9sbCA9IGRyYWdUcmFja2VyLnJlYWRQb2ludChldnQpO1xuICAgIGNvbnN0IGxhc3RDcm9zcyA9IGRyYWdUcmFja2VyLnJlYWRQb2ludChldnQsIGNyb3NzQXhpcyk7XG4gICAgY29uc3QgZGlmZlNjcm9sbCA9IGRlbHRhQWJzKGxhc3RTY3JvbGwsIHN0YXJ0U2Nyb2xsKTtcbiAgICBjb25zdCBkaWZmQ3Jvc3MgPSBkZWx0YUFicyhsYXN0Q3Jvc3MsIHN0YXJ0Q3Jvc3MpO1xuICAgIGlmICghcHJldmVudFNjcm9sbCAmJiAhaXNNb3VzZSkge1xuICAgICAgaWYgKCFldnQuY2FuY2VsYWJsZSkgcmV0dXJuIHVwKGV2dCk7XG4gICAgICBwcmV2ZW50U2Nyb2xsID0gZGlmZlNjcm9sbCA+IGRpZmZDcm9zcztcbiAgICAgIGlmICghcHJldmVudFNjcm9sbCkgcmV0dXJuIHVwKGV2dCk7XG4gICAgfVxuICAgIGNvbnN0IGRpZmYgPSBkcmFnVHJhY2tlci5wb2ludGVyTW92ZShldnQpO1xuICAgIGlmIChkaWZmU2Nyb2xsID4gZHJhZ1RocmVzaG9sZCkgcHJldmVudENsaWNrID0gdHJ1ZTtcbiAgICBzY3JvbGxCb2R5LnVzZUZyaWN0aW9uKDAuMykudXNlRHVyYXRpb24oMSk7XG4gICAgYW5pbWF0aW9uLnN0YXJ0KCk7XG4gICAgdGFyZ2V0LmFkZChkaXJlY3Rpb24uYXBwbHkoZGlmZikpO1xuICAgIGV2dC5wcmV2ZW50RGVmYXVsdCgpO1xuICB9XG4gIGZ1bmN0aW9uIHVwKGV2dCkge1xuICAgIGNvbnN0IGN1cnJlbnRMb2NhdGlvbiA9IHNjcm9sbFRhcmdldC5ieURpc3RhbmNlKDAsIGZhbHNlKTtcbiAgICBjb25zdCB0YXJnZXRDaGFuZ2VkID0gY3VycmVudExvY2F0aW9uLmluZGV4ICE9PSBpbmRleC5nZXQoKTtcbiAgICBjb25zdCByYXdGb3JjZSA9IGRyYWdUcmFja2VyLnBvaW50ZXJVcChldnQpICogZm9yY2VCb29zdCgpO1xuICAgIGNvbnN0IGZvcmNlID0gYWxsb3dlZEZvcmNlKGRpcmVjdGlvbi5hcHBseShyYXdGb3JjZSksIHRhcmdldENoYW5nZWQpO1xuICAgIGNvbnN0IGZvcmNlRmFjdG9yID0gZmFjdG9yQWJzKHJhd0ZvcmNlLCBmb3JjZSk7XG4gICAgY29uc3Qgc3BlZWQgPSBiYXNlU3BlZWQgLSAxMCAqIGZvcmNlRmFjdG9yO1xuICAgIGNvbnN0IGZyaWN0aW9uID0gYmFzZUZyaWN0aW9uICsgZm9yY2VGYWN0b3IgLyA1MDtcbiAgICBwcmV2ZW50U2Nyb2xsID0gZmFsc2U7XG4gICAgcG9pbnRlcklzRG93biA9IGZhbHNlO1xuICAgIGRyYWdFdmVudHMuY2xlYXIoKTtcbiAgICBzY3JvbGxCb2R5LnVzZUR1cmF0aW9uKHNwZWVkKS51c2VGcmljdGlvbihmcmljdGlvbik7XG4gICAgc2Nyb2xsVG8uZGlzdGFuY2UoZm9yY2UsICFkcmFnRnJlZSk7XG4gICAgaXNNb3VzZSA9IGZhbHNlO1xuICAgIGV2ZW50SGFuZGxlci5lbWl0KCdwb2ludGVyVXAnKTtcbiAgfVxuICBmdW5jdGlvbiBjbGljayhldnQpIHtcbiAgICBpZiAocHJldmVudENsaWNrKSB7XG4gICAgICBldnQuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgICBldnQucHJldmVudERlZmF1bHQoKTtcbiAgICB9XG4gIH1cbiAgZnVuY3Rpb24gcG9pbnRlckRvd24oKSB7XG4gICAgcmV0dXJuIHBvaW50ZXJJc0Rvd247XG4gIH1cbiAgY29uc3Qgc2VsZiA9IHtcbiAgICBpbml0LFxuICAgIHBvaW50ZXJEb3duLFxuICAgIGRlc3Ryb3lcbiAgfTtcbiAgcmV0dXJuIHNlbGY7XG59XG5cbmZ1bmN0aW9uIERyYWdUcmFja2VyKGF4aXMsIG93bmVyV2luZG93KSB7XG4gIGNvbnN0IGxvZ0ludGVydmFsID0gMTcwO1xuICBsZXQgc3RhcnRFdmVudDtcbiAgbGV0IGxhc3RFdmVudDtcbiAgZnVuY3Rpb24gcmVhZFRpbWUoZXZ0KSB7XG4gICAgcmV0dXJuIGV2dC50aW1lU3RhbXA7XG4gIH1cbiAgZnVuY3Rpb24gcmVhZFBvaW50KGV2dCwgZXZ0QXhpcykge1xuICAgIGNvbnN0IHByb3BlcnR5ID0gZXZ0QXhpcyB8fCBheGlzLnNjcm9sbDtcbiAgICBjb25zdCBjb29yZCA9IGBjbGllbnQke3Byb3BlcnR5ID09PSAneCcgPyAnWCcgOiAnWSd9YDtcbiAgICByZXR1cm4gKGlzTW91c2VFdmVudChldnQsIG93bmVyV2luZG93KSA/IGV2dCA6IGV2dC50b3VjaGVzWzBdKVtjb29yZF07XG4gIH1cbiAgZnVuY3Rpb24gcG9pbnRlckRvd24oZXZ0KSB7XG4gICAgc3RhcnRFdmVudCA9IGV2dDtcbiAgICBsYXN0RXZlbnQgPSBldnQ7XG4gICAgcmV0dXJuIHJlYWRQb2ludChldnQpO1xuICB9XG4gIGZ1bmN0aW9uIHBvaW50ZXJNb3ZlKGV2dCkge1xuICAgIGNvbnN0IGRpZmYgPSByZWFkUG9pbnQoZXZ0KSAtIHJlYWRQb2ludChsYXN0RXZlbnQpO1xuICAgIGNvbnN0IGV4cGlyZWQgPSByZWFkVGltZShldnQpIC0gcmVhZFRpbWUoc3RhcnRFdmVudCkgPiBsb2dJbnRlcnZhbDtcbiAgICBsYXN0RXZlbnQgPSBldnQ7XG4gICAgaWYgKGV4cGlyZWQpIHN0YXJ0RXZlbnQgPSBldnQ7XG4gICAgcmV0dXJuIGRpZmY7XG4gIH1cbiAgZnVuY3Rpb24gcG9pbnRlclVwKGV2dCkge1xuICAgIGlmICghc3RhcnRFdmVudCB8fCAhbGFzdEV2ZW50KSByZXR1cm4gMDtcbiAgICBjb25zdCBkaWZmRHJhZyA9IHJlYWRQb2ludChsYXN0RXZlbnQpIC0gcmVhZFBvaW50KHN0YXJ0RXZlbnQpO1xuICAgIGNvbnN0IGRpZmZUaW1lID0gcmVhZFRpbWUoZXZ0KSAtIHJlYWRUaW1lKHN0YXJ0RXZlbnQpO1xuICAgIGNvbnN0IGV4cGlyZWQgPSByZWFkVGltZShldnQpIC0gcmVhZFRpbWUobGFzdEV2ZW50KSA+IGxvZ0ludGVydmFsO1xuICAgIGNvbnN0IGZvcmNlID0gZGlmZkRyYWcgLyBkaWZmVGltZTtcbiAgICBjb25zdCBpc0ZsaWNrID0gZGlmZlRpbWUgJiYgIWV4cGlyZWQgJiYgbWF0aEFicyhmb3JjZSkgPiAwLjE7XG4gICAgcmV0dXJuIGlzRmxpY2sgPyBmb3JjZSA6IDA7XG4gIH1cbiAgY29uc3Qgc2VsZiA9IHtcbiAgICBwb2ludGVyRG93bixcbiAgICBwb2ludGVyTW92ZSxcbiAgICBwb2ludGVyVXAsXG4gICAgcmVhZFBvaW50XG4gIH07XG4gIHJldHVybiBzZWxmO1xufVxuXG5mdW5jdGlvbiBOb2RlUmVjdHMoKSB7XG4gIGZ1bmN0aW9uIG1lYXN1cmUobm9kZSkge1xuICAgIGNvbnN0IHtcbiAgICAgIG9mZnNldFRvcCxcbiAgICAgIG9mZnNldExlZnQsXG4gICAgICBvZmZzZXRXaWR0aCxcbiAgICAgIG9mZnNldEhlaWdodFxuICAgIH0gPSBub2RlO1xuICAgIGNvbnN0IG9mZnNldCA9IHtcbiAgICAgIHRvcDogb2Zmc2V0VG9wLFxuICAgICAgcmlnaHQ6IG9mZnNldExlZnQgKyBvZmZzZXRXaWR0aCxcbiAgICAgIGJvdHRvbTogb2Zmc2V0VG9wICsgb2Zmc2V0SGVpZ2h0LFxuICAgICAgbGVmdDogb2Zmc2V0TGVmdCxcbiAgICAgIHdpZHRoOiBvZmZzZXRXaWR0aCxcbiAgICAgIGhlaWdodDogb2Zmc2V0SGVpZ2h0XG4gICAgfTtcbiAgICByZXR1cm4gb2Zmc2V0O1xuICB9XG4gIGNvbnN0IHNlbGYgPSB7XG4gICAgbWVhc3VyZVxuICB9O1xuICByZXR1cm4gc2VsZjtcbn1cblxuZnVuY3Rpb24gUGVyY2VudE9mVmlldyh2aWV3U2l6ZSkge1xuICBmdW5jdGlvbiBtZWFzdXJlKG4pIHtcbiAgICByZXR1cm4gdmlld1NpemUgKiAobiAvIDEwMCk7XG4gIH1cbiAgY29uc3Qgc2VsZiA9IHtcbiAgICBtZWFzdXJlXG4gIH07XG4gIHJldHVybiBzZWxmO1xufVxuXG5mdW5jdGlvbiBSZXNpemVIYW5kbGVyKGNvbnRhaW5lciwgZXZlbnRIYW5kbGVyLCBvd25lcldpbmRvdywgc2xpZGVzLCBheGlzLCB3YXRjaFJlc2l6ZSwgbm9kZVJlY3RzKSB7XG4gIGxldCByZXNpemVPYnNlcnZlcjtcbiAgbGV0IGNvbnRhaW5lclNpemU7XG4gIGxldCBzbGlkZVNpemVzID0gW107XG4gIGxldCBkZXN0cm95ZWQgPSBmYWxzZTtcbiAgZnVuY3Rpb24gcmVhZFNpemUobm9kZSkge1xuICAgIHJldHVybiBheGlzLm1lYXN1cmVTaXplKG5vZGVSZWN0cy5tZWFzdXJlKG5vZGUpKTtcbiAgfVxuICBmdW5jdGlvbiBpbml0KGVtYmxhQXBpKSB7XG4gICAgaWYgKCF3YXRjaFJlc2l6ZSkgcmV0dXJuO1xuICAgIGNvbnRhaW5lclNpemUgPSByZWFkU2l6ZShjb250YWluZXIpO1xuICAgIHNsaWRlU2l6ZXMgPSBzbGlkZXMubWFwKHJlYWRTaXplKTtcbiAgICBmdW5jdGlvbiBkZWZhdWx0Q2FsbGJhY2soZW50cmllcykge1xuICAgICAgZm9yIChjb25zdCBlbnRyeSBvZiBlbnRyaWVzKSB7XG4gICAgICAgIGNvbnN0IGlzQ29udGFpbmVyID0gZW50cnkudGFyZ2V0ID09PSBjb250YWluZXI7XG4gICAgICAgIGNvbnN0IHNsaWRlSW5kZXggPSBzbGlkZXMuaW5kZXhPZihlbnRyeS50YXJnZXQpO1xuICAgICAgICBjb25zdCBsYXN0U2l6ZSA9IGlzQ29udGFpbmVyID8gY29udGFpbmVyU2l6ZSA6IHNsaWRlU2l6ZXNbc2xpZGVJbmRleF07XG4gICAgICAgIGNvbnN0IG5ld1NpemUgPSByZWFkU2l6ZShpc0NvbnRhaW5lciA/IGNvbnRhaW5lciA6IHNsaWRlc1tzbGlkZUluZGV4XSk7XG4gICAgICAgIGNvbnN0IGRpZmZTaXplID0gbWF0aEFicyhuZXdTaXplIC0gbGFzdFNpemUpO1xuICAgICAgICBpZiAoZGlmZlNpemUgPj0gMC41KSB7XG4gICAgICAgICAgb3duZXJXaW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lKCgpID0+IHtcbiAgICAgICAgICAgIGVtYmxhQXBpLnJlSW5pdCgpO1xuICAgICAgICAgICAgZXZlbnRIYW5kbGVyLmVtaXQoJ3Jlc2l6ZScpO1xuICAgICAgICAgIH0pO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHJlc2l6ZU9ic2VydmVyID0gbmV3IFJlc2l6ZU9ic2VydmVyKGVudHJpZXMgPT4ge1xuICAgICAgaWYgKGRlc3Ryb3llZCkgcmV0dXJuO1xuICAgICAgaWYgKGlzQm9vbGVhbih3YXRjaFJlc2l6ZSkgfHwgd2F0Y2hSZXNpemUoZW1ibGFBcGksIGVudHJpZXMpKSB7XG4gICAgICAgIGRlZmF1bHRDYWxsYmFjayhlbnRyaWVzKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICBjb25zdCBvYnNlcnZlTm9kZXMgPSBbY29udGFpbmVyXS5jb25jYXQoc2xpZGVzKTtcbiAgICBvYnNlcnZlTm9kZXMuZm9yRWFjaChub2RlID0+IHJlc2l6ZU9ic2VydmVyLm9ic2VydmUobm9kZSkpO1xuICB9XG4gIGZ1bmN0aW9uIGRlc3Ryb3koKSB7XG4gICAgaWYgKHJlc2l6ZU9ic2VydmVyKSByZXNpemVPYnNlcnZlci5kaXNjb25uZWN0KCk7XG4gICAgZGVzdHJveWVkID0gdHJ1ZTtcbiAgfVxuICBjb25zdCBzZWxmID0ge1xuICAgIGluaXQsXG4gICAgZGVzdHJveVxuICB9O1xuICByZXR1cm4gc2VsZjtcbn1cblxuZnVuY3Rpb24gU2Nyb2xsQm9keShsb2NhdGlvbiwgb2Zmc2V0TG9jYXRpb24sIHRhcmdldCwgYmFzZUR1cmF0aW9uLCBiYXNlRnJpY3Rpb24pIHtcbiAgbGV0IGJvZHlWZWxvY2l0eSA9IDA7XG4gIGxldCBzY3JvbGxEaXJlY3Rpb24gPSAwO1xuICBsZXQgc2Nyb2xsRHVyYXRpb24gPSBiYXNlRHVyYXRpb247XG4gIGxldCBzY3JvbGxGcmljdGlvbiA9IGJhc2VGcmljdGlvbjtcbiAgbGV0IHJhd0xvY2F0aW9uID0gbG9jYXRpb24uZ2V0KCk7XG4gIGxldCByYXdMb2NhdGlvblByZXZpb3VzID0gMDtcbiAgZnVuY3Rpb24gc2VlaygpIHtcbiAgICBjb25zdCBkaWZmID0gdGFyZ2V0LmdldCgpIC0gbG9jYXRpb24uZ2V0KCk7XG4gICAgY29uc3QgaXNJbnN0YW50ID0gIXNjcm9sbER1cmF0aW9uO1xuICAgIGxldCBkaXJlY3Rpb25EaWZmID0gMDtcbiAgICBpZiAoaXNJbnN0YW50KSB7XG4gICAgICBib2R5VmVsb2NpdHkgPSAwO1xuICAgICAgbG9jYXRpb24uc2V0KHRhcmdldCk7XG4gICAgICBkaXJlY3Rpb25EaWZmID0gZGlmZjtcbiAgICB9IGVsc2Uge1xuICAgICAgYm9keVZlbG9jaXR5ICs9IGRpZmYgLyBzY3JvbGxEdXJhdGlvbjtcbiAgICAgIGJvZHlWZWxvY2l0eSAqPSBzY3JvbGxGcmljdGlvbjtcbiAgICAgIHJhd0xvY2F0aW9uICs9IGJvZHlWZWxvY2l0eTtcbiAgICAgIGxvY2F0aW9uLmFkZChib2R5VmVsb2NpdHkpO1xuICAgICAgZGlyZWN0aW9uRGlmZiA9IHJhd0xvY2F0aW9uIC0gcmF3TG9jYXRpb25QcmV2aW91cztcbiAgICB9XG4gICAgc2Nyb2xsRGlyZWN0aW9uID0gbWF0aFNpZ24oZGlyZWN0aW9uRGlmZik7XG4gICAgcmF3TG9jYXRpb25QcmV2aW91cyA9IHJhd0xvY2F0aW9uO1xuICAgIHJldHVybiBzZWxmO1xuICB9XG4gIGZ1bmN0aW9uIHNldHRsZWQoKSB7XG4gICAgY29uc3QgZGlmZiA9IHRhcmdldC5nZXQoKSAtIG9mZnNldExvY2F0aW9uLmdldCgpO1xuICAgIHJldHVybiBtYXRoQWJzKGRpZmYpIDwgMC4wMDE7XG4gIH1cbiAgZnVuY3Rpb24gZHVyYXRpb24oKSB7XG4gICAgcmV0dXJuIHNjcm9sbER1cmF0aW9uO1xuICB9XG4gIGZ1bmN0aW9uIGRpcmVjdGlvbigpIHtcbiAgICByZXR1cm4gc2Nyb2xsRGlyZWN0aW9uO1xuICB9XG4gIGZ1bmN0aW9uIHZlbG9jaXR5KCkge1xuICAgIHJldHVybiBib2R5VmVsb2NpdHk7XG4gIH1cbiAgZnVuY3Rpb24gdXNlQmFzZUR1cmF0aW9uKCkge1xuICAgIHJldHVybiB1c2VEdXJhdGlvbihiYXNlRHVyYXRpb24pO1xuICB9XG4gIGZ1bmN0aW9uIHVzZUJhc2VGcmljdGlvbigpIHtcbiAgICByZXR1cm4gdXNlRnJpY3Rpb24oYmFzZUZyaWN0aW9uKTtcbiAgfVxuICBmdW5jdGlvbiB1c2VEdXJhdGlvbihuKSB7XG4gICAgc2Nyb2xsRHVyYXRpb24gPSBuO1xuICAgIHJldHVybiBzZWxmO1xuICB9XG4gIGZ1bmN0aW9uIHVzZUZyaWN0aW9uKG4pIHtcbiAgICBzY3JvbGxGcmljdGlvbiA9IG47XG4gICAgcmV0dXJuIHNlbGY7XG4gIH1cbiAgY29uc3Qgc2VsZiA9IHtcbiAgICBkaXJlY3Rpb24sXG4gICAgZHVyYXRpb24sXG4gICAgdmVsb2NpdHksXG4gICAgc2VlayxcbiAgICBzZXR0bGVkLFxuICAgIHVzZUJhc2VGcmljdGlvbixcbiAgICB1c2VCYXNlRHVyYXRpb24sXG4gICAgdXNlRnJpY3Rpb24sXG4gICAgdXNlRHVyYXRpb25cbiAgfTtcbiAgcmV0dXJuIHNlbGY7XG59XG5cbmZ1bmN0aW9uIFNjcm9sbEJvdW5kcyhsaW1pdCwgbG9jYXRpb24sIHRhcmdldCwgc2Nyb2xsQm9keSwgcGVyY2VudE9mVmlldykge1xuICBjb25zdCBwdWxsQmFja1RocmVzaG9sZCA9IHBlcmNlbnRPZlZpZXcubWVhc3VyZSgxMCk7XG4gIGNvbnN0IGVkZ2VPZmZzZXRUb2xlcmFuY2UgPSBwZXJjZW50T2ZWaWV3Lm1lYXN1cmUoNTApO1xuICBjb25zdCBmcmljdGlvbkxpbWl0ID0gTGltaXQoMC4xLCAwLjk5KTtcbiAgbGV0IGRpc2FibGVkID0gZmFsc2U7XG4gIGZ1bmN0aW9uIHNob3VsZENvbnN0cmFpbigpIHtcbiAgICBpZiAoZGlzYWJsZWQpIHJldHVybiBmYWxzZTtcbiAgICBpZiAoIWxpbWl0LnJlYWNoZWRBbnkodGFyZ2V0LmdldCgpKSkgcmV0dXJuIGZhbHNlO1xuICAgIGlmICghbGltaXQucmVhY2hlZEFueShsb2NhdGlvbi5nZXQoKSkpIHJldHVybiBmYWxzZTtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICBmdW5jdGlvbiBjb25zdHJhaW4ocG9pbnRlckRvd24pIHtcbiAgICBpZiAoIXNob3VsZENvbnN0cmFpbigpKSByZXR1cm47XG4gICAgY29uc3QgZWRnZSA9IGxpbWl0LnJlYWNoZWRNaW4obG9jYXRpb24uZ2V0KCkpID8gJ21pbicgOiAnbWF4JztcbiAgICBjb25zdCBkaWZmVG9FZGdlID0gbWF0aEFicyhsaW1pdFtlZGdlXSAtIGxvY2F0aW9uLmdldCgpKTtcbiAgICBjb25zdCBkaWZmVG9UYXJnZXQgPSB0YXJnZXQuZ2V0KCkgLSBsb2NhdGlvbi5nZXQoKTtcbiAgICBjb25zdCBmcmljdGlvbiA9IGZyaWN0aW9uTGltaXQuY29uc3RyYWluKGRpZmZUb0VkZ2UgLyBlZGdlT2Zmc2V0VG9sZXJhbmNlKTtcbiAgICB0YXJnZXQuc3VidHJhY3QoZGlmZlRvVGFyZ2V0ICogZnJpY3Rpb24pO1xuICAgIGlmICghcG9pbnRlckRvd24gJiYgbWF0aEFicyhkaWZmVG9UYXJnZXQpIDwgcHVsbEJhY2tUaHJlc2hvbGQpIHtcbiAgICAgIHRhcmdldC5zZXQobGltaXQuY29uc3RyYWluKHRhcmdldC5nZXQoKSkpO1xuICAgICAgc2Nyb2xsQm9keS51c2VEdXJhdGlvbigyNSkudXNlQmFzZUZyaWN0aW9uKCk7XG4gICAgfVxuICB9XG4gIGZ1bmN0aW9uIHRvZ2dsZUFjdGl2ZShhY3RpdmUpIHtcbiAgICBkaXNhYmxlZCA9ICFhY3RpdmU7XG4gIH1cbiAgY29uc3Qgc2VsZiA9IHtcbiAgICBjb25zdHJhaW4sXG4gICAgdG9nZ2xlQWN0aXZlXG4gIH07XG4gIHJldHVybiBzZWxmO1xufVxuXG5mdW5jdGlvbiBTY3JvbGxDb250YWluKHZpZXdTaXplLCBjb250ZW50U2l6ZSwgc25hcHNBbGlnbmVkLCBjb250YWluU2Nyb2xsLCBwaXhlbFRvbGVyYW5jZSkge1xuICBjb25zdCBzY3JvbGxCb3VuZHMgPSBMaW1pdCgtY29udGVudFNpemUgKyB2aWV3U2l6ZSwgMCk7XG4gIGNvbnN0IHNuYXBzQm91bmRlZCA9IG1lYXN1cmVCb3VuZGVkKCk7XG4gIGNvbnN0IHNjcm9sbENvbnRhaW5MaW1pdCA9IGZpbmRTY3JvbGxDb250YWluTGltaXQoKTtcbiAgY29uc3Qgc25hcHNDb250YWluZWQgPSBtZWFzdXJlQ29udGFpbmVkKCk7XG4gIGZ1bmN0aW9uIHVzZVBpeGVsVG9sZXJhbmNlKGJvdW5kLCBzbmFwKSB7XG4gICAgcmV0dXJuIGRlbHRhQWJzKGJvdW5kLCBzbmFwKSA8IDE7XG4gIH1cbiAgZnVuY3Rpb24gZmluZFNjcm9sbENvbnRhaW5MaW1pdCgpIHtcbiAgICBjb25zdCBzdGFydFNuYXAgPSBzbmFwc0JvdW5kZWRbMF07XG4gICAgY29uc3QgZW5kU25hcCA9IGFycmF5TGFzdChzbmFwc0JvdW5kZWQpO1xuICAgIGNvbnN0IG1pbiA9IHNuYXBzQm91bmRlZC5sYXN0SW5kZXhPZihzdGFydFNuYXApO1xuICAgIGNvbnN0IG1heCA9IHNuYXBzQm91bmRlZC5pbmRleE9mKGVuZFNuYXApICsgMTtcbiAgICByZXR1cm4gTGltaXQobWluLCBtYXgpO1xuICB9XG4gIGZ1bmN0aW9uIG1lYXN1cmVCb3VuZGVkKCkge1xuICAgIHJldHVybiBzbmFwc0FsaWduZWQubWFwKChzbmFwQWxpZ25lZCwgaW5kZXgpID0+IHtcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgbWluLFxuICAgICAgICBtYXhcbiAgICAgIH0gPSBzY3JvbGxCb3VuZHM7XG4gICAgICBjb25zdCBzbmFwID0gc2Nyb2xsQm91bmRzLmNvbnN0cmFpbihzbmFwQWxpZ25lZCk7XG4gICAgICBjb25zdCBpc0ZpcnN0ID0gIWluZGV4O1xuICAgICAgY29uc3QgaXNMYXN0ID0gYXJyYXlJc0xhc3RJbmRleChzbmFwc0FsaWduZWQsIGluZGV4KTtcbiAgICAgIGlmIChpc0ZpcnN0KSByZXR1cm4gbWF4O1xuICAgICAgaWYgKGlzTGFzdCkgcmV0dXJuIG1pbjtcbiAgICAgIGlmICh1c2VQaXhlbFRvbGVyYW5jZShtaW4sIHNuYXApKSByZXR1cm4gbWluO1xuICAgICAgaWYgKHVzZVBpeGVsVG9sZXJhbmNlKG1heCwgc25hcCkpIHJldHVybiBtYXg7XG4gICAgICByZXR1cm4gc25hcDtcbiAgICB9KS5tYXAoc2Nyb2xsQm91bmQgPT4gcGFyc2VGbG9hdChzY3JvbGxCb3VuZC50b0ZpeGVkKDMpKSk7XG4gIH1cbiAgZnVuY3Rpb24gbWVhc3VyZUNvbnRhaW5lZCgpIHtcbiAgICBpZiAoY29udGVudFNpemUgPD0gdmlld1NpemUgKyBwaXhlbFRvbGVyYW5jZSkgcmV0dXJuIFtzY3JvbGxCb3VuZHMubWF4XTtcbiAgICBpZiAoY29udGFpblNjcm9sbCA9PT0gJ2tlZXBTbmFwcycpIHJldHVybiBzbmFwc0JvdW5kZWQ7XG4gICAgY29uc3Qge1xuICAgICAgbWluLFxuICAgICAgbWF4XG4gICAgfSA9IHNjcm9sbENvbnRhaW5MaW1pdDtcbiAgICByZXR1cm4gc25hcHNCb3VuZGVkLnNsaWNlKG1pbiwgbWF4KTtcbiAgfVxuICBjb25zdCBzZWxmID0ge1xuICAgIHNuYXBzQ29udGFpbmVkLFxuICAgIHNjcm9sbENvbnRhaW5MaW1pdFxuICB9O1xuICByZXR1cm4gc2VsZjtcbn1cblxuZnVuY3Rpb24gU2Nyb2xsTGltaXQoY29udGVudFNpemUsIHNjcm9sbFNuYXBzLCBsb29wKSB7XG4gIGNvbnN0IG1heCA9IHNjcm9sbFNuYXBzWzBdO1xuICBjb25zdCBtaW4gPSBsb29wID8gbWF4IC0gY29udGVudFNpemUgOiBhcnJheUxhc3Qoc2Nyb2xsU25hcHMpO1xuICBjb25zdCBsaW1pdCA9IExpbWl0KG1pbiwgbWF4KTtcbiAgY29uc3Qgc2VsZiA9IHtcbiAgICBsaW1pdFxuICB9O1xuICByZXR1cm4gc2VsZjtcbn1cblxuZnVuY3Rpb24gU2Nyb2xsTG9vcGVyKGNvbnRlbnRTaXplLCBsaW1pdCwgb2Zmc2V0TG9jYXRpb24sIHZlY3RvcnMpIHtcbiAgY29uc3Qgam9pbnRTYWZldHkgPSAwLjE7XG4gIGNvbnN0IG1pbiA9IGxpbWl0Lm1pbiArIGpvaW50U2FmZXR5O1xuICBjb25zdCBtYXggPSBsaW1pdC5tYXggKyBqb2ludFNhZmV0eTtcbiAgY29uc3Qge1xuICAgIHJlYWNoZWRNaW4sXG4gICAgcmVhY2hlZE1heFxuICB9ID0gTGltaXQobWluLCBtYXgpO1xuICBmdW5jdGlvbiBzaG91bGRMb29wKGRpcmVjdGlvbikge1xuICAgIGlmIChkaXJlY3Rpb24gPT09IDEpIHJldHVybiByZWFjaGVkTWF4KG9mZnNldExvY2F0aW9uLmdldCgpKTtcbiAgICBpZiAoZGlyZWN0aW9uID09PSAtMSkgcmV0dXJuIHJlYWNoZWRNaW4ob2Zmc2V0TG9jYXRpb24uZ2V0KCkpO1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBmdW5jdGlvbiBsb29wKGRpcmVjdGlvbikge1xuICAgIGlmICghc2hvdWxkTG9vcChkaXJlY3Rpb24pKSByZXR1cm47XG4gICAgY29uc3QgbG9vcERpc3RhbmNlID0gY29udGVudFNpemUgKiAoZGlyZWN0aW9uICogLTEpO1xuICAgIHZlY3RvcnMuZm9yRWFjaCh2ID0+IHYuYWRkKGxvb3BEaXN0YW5jZSkpO1xuICB9XG4gIGNvbnN0IHNlbGYgPSB7XG4gICAgbG9vcFxuICB9O1xuICByZXR1cm4gc2VsZjtcbn1cblxuZnVuY3Rpb24gU2Nyb2xsUHJvZ3Jlc3MobGltaXQpIHtcbiAgY29uc3Qge1xuICAgIG1heCxcbiAgICBsZW5ndGhcbiAgfSA9IGxpbWl0O1xuICBmdW5jdGlvbiBnZXQobikge1xuICAgIGNvbnN0IGN1cnJlbnRMb2NhdGlvbiA9IG4gLSBtYXg7XG4gICAgcmV0dXJuIGxlbmd0aCA/IGN1cnJlbnRMb2NhdGlvbiAvIC1sZW5ndGggOiAwO1xuICB9XG4gIGNvbnN0IHNlbGYgPSB7XG4gICAgZ2V0XG4gIH07XG4gIHJldHVybiBzZWxmO1xufVxuXG5mdW5jdGlvbiBTY3JvbGxTbmFwcyhheGlzLCBhbGlnbm1lbnQsIGNvbnRhaW5lclJlY3QsIHNsaWRlUmVjdHMsIHNsaWRlc1RvU2Nyb2xsKSB7XG4gIGNvbnN0IHtcbiAgICBzdGFydEVkZ2UsXG4gICAgZW5kRWRnZVxuICB9ID0gYXhpcztcbiAgY29uc3Qge1xuICAgIGdyb3VwU2xpZGVzXG4gIH0gPSBzbGlkZXNUb1Njcm9sbDtcbiAgY29uc3QgYWxpZ25tZW50cyA9IG1lYXN1cmVTaXplcygpLm1hcChhbGlnbm1lbnQubWVhc3VyZSk7XG4gIGNvbnN0IHNuYXBzID0gbWVhc3VyZVVuYWxpZ25lZCgpO1xuICBjb25zdCBzbmFwc0FsaWduZWQgPSBtZWFzdXJlQWxpZ25lZCgpO1xuICBmdW5jdGlvbiBtZWFzdXJlU2l6ZXMoKSB7XG4gICAgcmV0dXJuIGdyb3VwU2xpZGVzKHNsaWRlUmVjdHMpLm1hcChyZWN0cyA9PiBhcnJheUxhc3QocmVjdHMpW2VuZEVkZ2VdIC0gcmVjdHNbMF1bc3RhcnRFZGdlXSkubWFwKG1hdGhBYnMpO1xuICB9XG4gIGZ1bmN0aW9uIG1lYXN1cmVVbmFsaWduZWQoKSB7XG4gICAgcmV0dXJuIHNsaWRlUmVjdHMubWFwKHJlY3QgPT4gY29udGFpbmVyUmVjdFtzdGFydEVkZ2VdIC0gcmVjdFtzdGFydEVkZ2VdKS5tYXAoc25hcCA9PiAtbWF0aEFicyhzbmFwKSk7XG4gIH1cbiAgZnVuY3Rpb24gbWVhc3VyZUFsaWduZWQoKSB7XG4gICAgcmV0dXJuIGdyb3VwU2xpZGVzKHNuYXBzKS5tYXAoZyA9PiBnWzBdKS5tYXAoKHNuYXAsIGluZGV4KSA9PiBzbmFwICsgYWxpZ25tZW50c1tpbmRleF0pO1xuICB9XG4gIGNvbnN0IHNlbGYgPSB7XG4gICAgc25hcHMsXG4gICAgc25hcHNBbGlnbmVkXG4gIH07XG4gIHJldHVybiBzZWxmO1xufVxuXG5mdW5jdGlvbiBTbGlkZVJlZ2lzdHJ5KGNvbnRhaW5TbmFwcywgY29udGFpblNjcm9sbCwgc2Nyb2xsU25hcHMsIHNjcm9sbENvbnRhaW5MaW1pdCwgc2xpZGVzVG9TY3JvbGwsIHNsaWRlSW5kZXhlcykge1xuICBjb25zdCB7XG4gICAgZ3JvdXBTbGlkZXNcbiAgfSA9IHNsaWRlc1RvU2Nyb2xsO1xuICBjb25zdCB7XG4gICAgbWluLFxuICAgIG1heFxuICB9ID0gc2Nyb2xsQ29udGFpbkxpbWl0O1xuICBjb25zdCBzbGlkZVJlZ2lzdHJ5ID0gY3JlYXRlU2xpZGVSZWdpc3RyeSgpO1xuICBmdW5jdGlvbiBjcmVhdGVTbGlkZVJlZ2lzdHJ5KCkge1xuICAgIGNvbnN0IGdyb3VwZWRTbGlkZUluZGV4ZXMgPSBncm91cFNsaWRlcyhzbGlkZUluZGV4ZXMpO1xuICAgIGNvbnN0IGRvTm90Q29udGFpbiA9ICFjb250YWluU25hcHMgfHwgY29udGFpblNjcm9sbCA9PT0gJ2tlZXBTbmFwcyc7XG4gICAgaWYgKHNjcm9sbFNuYXBzLmxlbmd0aCA9PT0gMSkgcmV0dXJuIFtzbGlkZUluZGV4ZXNdO1xuICAgIGlmIChkb05vdENvbnRhaW4pIHJldHVybiBncm91cGVkU2xpZGVJbmRleGVzO1xuICAgIHJldHVybiBncm91cGVkU2xpZGVJbmRleGVzLnNsaWNlKG1pbiwgbWF4KS5tYXAoKGdyb3VwLCBpbmRleCwgZ3JvdXBzKSA9PiB7XG4gICAgICBjb25zdCBpc0ZpcnN0ID0gIWluZGV4O1xuICAgICAgY29uc3QgaXNMYXN0ID0gYXJyYXlJc0xhc3RJbmRleChncm91cHMsIGluZGV4KTtcbiAgICAgIGlmIChpc0ZpcnN0KSB7XG4gICAgICAgIGNvbnN0IHJhbmdlID0gYXJyYXlMYXN0KGdyb3Vwc1swXSkgKyAxO1xuICAgICAgICByZXR1cm4gYXJyYXlGcm9tTnVtYmVyKHJhbmdlKTtcbiAgICAgIH1cbiAgICAgIGlmIChpc0xhc3QpIHtcbiAgICAgICAgY29uc3QgcmFuZ2UgPSBhcnJheUxhc3RJbmRleChzbGlkZUluZGV4ZXMpIC0gYXJyYXlMYXN0KGdyb3VwcylbMF0gKyAxO1xuICAgICAgICByZXR1cm4gYXJyYXlGcm9tTnVtYmVyKHJhbmdlLCBhcnJheUxhc3QoZ3JvdXBzKVswXSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gZ3JvdXA7XG4gICAgfSk7XG4gIH1cbiAgY29uc3Qgc2VsZiA9IHtcbiAgICBzbGlkZVJlZ2lzdHJ5XG4gIH07XG4gIHJldHVybiBzZWxmO1xufVxuXG5mdW5jdGlvbiBTY3JvbGxUYXJnZXQobG9vcCwgc2Nyb2xsU25hcHMsIGNvbnRlbnRTaXplLCBsaW1pdCwgdGFyZ2V0VmVjdG9yKSB7XG4gIGNvbnN0IHtcbiAgICByZWFjaGVkQW55LFxuICAgIHJlbW92ZU9mZnNldCxcbiAgICBjb25zdHJhaW5cbiAgfSA9IGxpbWl0O1xuICBmdW5jdGlvbiBtaW5EaXN0YW5jZShkaXN0YW5jZXMpIHtcbiAgICByZXR1cm4gZGlzdGFuY2VzLmNvbmNhdCgpLnNvcnQoKGEsIGIpID0+IG1hdGhBYnMoYSkgLSBtYXRoQWJzKGIpKVswXTtcbiAgfVxuICBmdW5jdGlvbiBmaW5kVGFyZ2V0U25hcCh0YXJnZXQpIHtcbiAgICBjb25zdCBkaXN0YW5jZSA9IGxvb3AgPyByZW1vdmVPZmZzZXQodGFyZ2V0KSA6IGNvbnN0cmFpbih0YXJnZXQpO1xuICAgIGNvbnN0IGFzY0RpZmZzVG9TbmFwcyA9IHNjcm9sbFNuYXBzLm1hcChzY3JvbGxTbmFwID0+IHNjcm9sbFNuYXAgLSBkaXN0YW5jZSkubWFwKGRpZmZUb1NuYXAgPT4gc2hvcnRjdXQoZGlmZlRvU25hcCwgMCkpLm1hcCgoZGlmZiwgaSkgPT4gKHtcbiAgICAgIGRpZmYsXG4gICAgICBpbmRleDogaVxuICAgIH0pKS5zb3J0KChkMSwgZDIpID0+IG1hdGhBYnMoZDEuZGlmZikgLSBtYXRoQWJzKGQyLmRpZmYpKTtcbiAgICBjb25zdCB7XG4gICAgICBpbmRleFxuICAgIH0gPSBhc2NEaWZmc1RvU25hcHNbMF07XG4gICAgcmV0dXJuIHtcbiAgICAgIGluZGV4LFxuICAgICAgZGlzdGFuY2VcbiAgICB9O1xuICB9XG4gIGZ1bmN0aW9uIHNob3J0Y3V0KHRhcmdldCwgZGlyZWN0aW9uKSB7XG4gICAgY29uc3QgdGFyZ2V0cyA9IFt0YXJnZXQsIHRhcmdldCArIGNvbnRlbnRTaXplLCB0YXJnZXQgLSBjb250ZW50U2l6ZV07XG4gICAgaWYgKCFsb29wKSByZXR1cm4gdGFyZ2V0c1swXTtcbiAgICBpZiAoIWRpcmVjdGlvbikgcmV0dXJuIG1pbkRpc3RhbmNlKHRhcmdldHMpO1xuICAgIGNvbnN0IG1hdGNoaW5nVGFyZ2V0cyA9IHRhcmdldHMuZmlsdGVyKHQgPT4gbWF0aFNpZ24odCkgPT09IGRpcmVjdGlvbik7XG4gICAgaWYgKG1hdGNoaW5nVGFyZ2V0cy5sZW5ndGgpIHJldHVybiBtaW5EaXN0YW5jZShtYXRjaGluZ1RhcmdldHMpO1xuICAgIHJldHVybiBhcnJheUxhc3QodGFyZ2V0cykgLSBjb250ZW50U2l6ZTtcbiAgfVxuICBmdW5jdGlvbiBieUluZGV4KGluZGV4LCBkaXJlY3Rpb24pIHtcbiAgICBjb25zdCBkaWZmVG9TbmFwID0gc2Nyb2xsU25hcHNbaW5kZXhdIC0gdGFyZ2V0VmVjdG9yLmdldCgpO1xuICAgIGNvbnN0IGRpc3RhbmNlID0gc2hvcnRjdXQoZGlmZlRvU25hcCwgZGlyZWN0aW9uKTtcbiAgICByZXR1cm4ge1xuICAgICAgaW5kZXgsXG4gICAgICBkaXN0YW5jZVxuICAgIH07XG4gIH1cbiAgZnVuY3Rpb24gYnlEaXN0YW5jZShkaXN0YW5jZSwgc25hcCkge1xuICAgIGNvbnN0IHRhcmdldCA9IHRhcmdldFZlY3Rvci5nZXQoKSArIGRpc3RhbmNlO1xuICAgIGNvbnN0IHtcbiAgICAgIGluZGV4LFxuICAgICAgZGlzdGFuY2U6IHRhcmdldFNuYXBEaXN0YW5jZVxuICAgIH0gPSBmaW5kVGFyZ2V0U25hcCh0YXJnZXQpO1xuICAgIGNvbnN0IHJlYWNoZWRCb3VuZCA9ICFsb29wICYmIHJlYWNoZWRBbnkodGFyZ2V0KTtcbiAgICBpZiAoIXNuYXAgfHwgcmVhY2hlZEJvdW5kKSByZXR1cm4ge1xuICAgICAgaW5kZXgsXG4gICAgICBkaXN0YW5jZVxuICAgIH07XG4gICAgY29uc3QgZGlmZlRvU25hcCA9IHNjcm9sbFNuYXBzW2luZGV4XSAtIHRhcmdldFNuYXBEaXN0YW5jZTtcbiAgICBjb25zdCBzbmFwRGlzdGFuY2UgPSBkaXN0YW5jZSArIHNob3J0Y3V0KGRpZmZUb1NuYXAsIDApO1xuICAgIHJldHVybiB7XG4gICAgICBpbmRleCxcbiAgICAgIGRpc3RhbmNlOiBzbmFwRGlzdGFuY2VcbiAgICB9O1xuICB9XG4gIGNvbnN0IHNlbGYgPSB7XG4gICAgYnlEaXN0YW5jZSxcbiAgICBieUluZGV4LFxuICAgIHNob3J0Y3V0XG4gIH07XG4gIHJldHVybiBzZWxmO1xufVxuXG5mdW5jdGlvbiBTY3JvbGxUbyhhbmltYXRpb24sIGluZGV4Q3VycmVudCwgaW5kZXhQcmV2aW91cywgc2Nyb2xsQm9keSwgc2Nyb2xsVGFyZ2V0LCB0YXJnZXRWZWN0b3IsIGV2ZW50SGFuZGxlcikge1xuICBmdW5jdGlvbiBzY3JvbGxUbyh0YXJnZXQpIHtcbiAgICBjb25zdCBkaXN0YW5jZURpZmYgPSB0YXJnZXQuZGlzdGFuY2U7XG4gICAgY29uc3QgaW5kZXhEaWZmID0gdGFyZ2V0LmluZGV4ICE9PSBpbmRleEN1cnJlbnQuZ2V0KCk7XG4gICAgdGFyZ2V0VmVjdG9yLmFkZChkaXN0YW5jZURpZmYpO1xuICAgIGlmIChkaXN0YW5jZURpZmYpIHtcbiAgICAgIGlmIChzY3JvbGxCb2R5LmR1cmF0aW9uKCkpIHtcbiAgICAgICAgYW5pbWF0aW9uLnN0YXJ0KCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBhbmltYXRpb24udXBkYXRlKCk7XG4gICAgICAgIGFuaW1hdGlvbi5yZW5kZXIoMSk7XG4gICAgICAgIGFuaW1hdGlvbi51cGRhdGUoKTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKGluZGV4RGlmZikge1xuICAgICAgaW5kZXhQcmV2aW91cy5zZXQoaW5kZXhDdXJyZW50LmdldCgpKTtcbiAgICAgIGluZGV4Q3VycmVudC5zZXQodGFyZ2V0LmluZGV4KTtcbiAgICAgIGV2ZW50SGFuZGxlci5lbWl0KCdzZWxlY3QnKTtcbiAgICB9XG4gIH1cbiAgZnVuY3Rpb24gZGlzdGFuY2Uobiwgc25hcCkge1xuICAgIGNvbnN0IHRhcmdldCA9IHNjcm9sbFRhcmdldC5ieURpc3RhbmNlKG4sIHNuYXApO1xuICAgIHNjcm9sbFRvKHRhcmdldCk7XG4gIH1cbiAgZnVuY3Rpb24gaW5kZXgobiwgZGlyZWN0aW9uKSB7XG4gICAgY29uc3QgdGFyZ2V0SW5kZXggPSBpbmRleEN1cnJlbnQuY2xvbmUoKS5zZXQobik7XG4gICAgY29uc3QgdGFyZ2V0ID0gc2Nyb2xsVGFyZ2V0LmJ5SW5kZXgodGFyZ2V0SW5kZXguZ2V0KCksIGRpcmVjdGlvbik7XG4gICAgc2Nyb2xsVG8odGFyZ2V0KTtcbiAgfVxuICBjb25zdCBzZWxmID0ge1xuICAgIGRpc3RhbmNlLFxuICAgIGluZGV4XG4gIH07XG4gIHJldHVybiBzZWxmO1xufVxuXG5mdW5jdGlvbiBTbGlkZUZvY3VzKHJvb3QsIHNsaWRlcywgc2xpZGVSZWdpc3RyeSwgc2Nyb2xsVG8sIHNjcm9sbEJvZHksIGV2ZW50U3RvcmUpIHtcbiAgbGV0IGxhc3RUYWJQcmVzc1RpbWUgPSAwO1xuICBmdW5jdGlvbiBpbml0KCkge1xuICAgIGV2ZW50U3RvcmUuYWRkKGRvY3VtZW50LCAna2V5ZG93bicsIHJlZ2lzdGVyVGFiUHJlc3MsIGZhbHNlKTtcbiAgICBzbGlkZXMuZm9yRWFjaChhZGRTbGlkZUZvY3VzRXZlbnQpO1xuICB9XG4gIGZ1bmN0aW9uIHJlZ2lzdGVyVGFiUHJlc3MoZXZlbnQpIHtcbiAgICBpZiAoZXZlbnQuY29kZSA9PT0gJ1RhYicpIGxhc3RUYWJQcmVzc1RpbWUgPSBuZXcgRGF0ZSgpLmdldFRpbWUoKTtcbiAgfVxuICBmdW5jdGlvbiBhZGRTbGlkZUZvY3VzRXZlbnQoc2xpZGUpIHtcbiAgICBjb25zdCBmb2N1cyA9ICgpID0+IHtcbiAgICAgIGNvbnN0IG5vd1RpbWUgPSBuZXcgRGF0ZSgpLmdldFRpbWUoKTtcbiAgICAgIGNvbnN0IGRpZmZUaW1lID0gbm93VGltZSAtIGxhc3RUYWJQcmVzc1RpbWU7XG4gICAgICBpZiAoZGlmZlRpbWUgPiAxMCkgcmV0dXJuO1xuICAgICAgcm9vdC5zY3JvbGxMZWZ0ID0gMDtcbiAgICAgIGNvbnN0IGluZGV4ID0gc2xpZGVzLmluZGV4T2Yoc2xpZGUpO1xuICAgICAgY29uc3QgZ3JvdXAgPSBzbGlkZVJlZ2lzdHJ5LmZpbmRJbmRleChncm91cCA9PiBncm91cC5pbmNsdWRlcyhpbmRleCkpO1xuICAgICAgaWYgKCFpc051bWJlcihncm91cCkpIHJldHVybjtcbiAgICAgIHNjcm9sbEJvZHkudXNlRHVyYXRpb24oMCk7XG4gICAgICBzY3JvbGxUby5pbmRleChncm91cCwgMCk7XG4gICAgfTtcbiAgICBldmVudFN0b3JlLmFkZChzbGlkZSwgJ2ZvY3VzJywgZm9jdXMsIHtcbiAgICAgIHBhc3NpdmU6IHRydWUsXG4gICAgICBjYXB0dXJlOiB0cnVlXG4gICAgfSk7XG4gIH1cbiAgY29uc3Qgc2VsZiA9IHtcbiAgICBpbml0XG4gIH07XG4gIHJldHVybiBzZWxmO1xufVxuXG5mdW5jdGlvbiBWZWN0b3IxRChpbml0aWFsVmFsdWUpIHtcbiAgbGV0IHZhbHVlID0gaW5pdGlhbFZhbHVlO1xuICBmdW5jdGlvbiBnZXQoKSB7XG4gICAgcmV0dXJuIHZhbHVlO1xuICB9XG4gIGZ1bmN0aW9uIHNldChuKSB7XG4gICAgdmFsdWUgPSBub3JtYWxpemVJbnB1dChuKTtcbiAgfVxuICBmdW5jdGlvbiBhZGQobikge1xuICAgIHZhbHVlICs9IG5vcm1hbGl6ZUlucHV0KG4pO1xuICB9XG4gIGZ1bmN0aW9uIHN1YnRyYWN0KG4pIHtcbiAgICB2YWx1ZSAtPSBub3JtYWxpemVJbnB1dChuKTtcbiAgfVxuICBmdW5jdGlvbiBub3JtYWxpemVJbnB1dChuKSB7XG4gICAgcmV0dXJuIGlzTnVtYmVyKG4pID8gbiA6IG4uZ2V0KCk7XG4gIH1cbiAgY29uc3Qgc2VsZiA9IHtcbiAgICBnZXQsXG4gICAgc2V0LFxuICAgIGFkZCxcbiAgICBzdWJ0cmFjdFxuICB9O1xuICByZXR1cm4gc2VsZjtcbn1cblxuZnVuY3Rpb24gVHJhbnNsYXRlKGF4aXMsIGRpcmVjdGlvbiwgY29udGFpbmVyKSB7XG4gIGNvbnN0IHRyYW5zbGF0ZSA9IGF4aXMuc2Nyb2xsID09PSAneCcgPyB4IDogeTtcbiAgY29uc3QgY29udGFpbmVyU3R5bGUgPSBjb250YWluZXIuc3R5bGU7XG4gIGxldCBkaXNhYmxlZCA9IGZhbHNlO1xuICBmdW5jdGlvbiB4KG4pIHtcbiAgICByZXR1cm4gYHRyYW5zbGF0ZTNkKCR7bn1weCwwcHgsMHB4KWA7XG4gIH1cbiAgZnVuY3Rpb24geShuKSB7XG4gICAgcmV0dXJuIGB0cmFuc2xhdGUzZCgwcHgsJHtufXB4LDBweClgO1xuICB9XG4gIGZ1bmN0aW9uIHRvKHRhcmdldCkge1xuICAgIGlmIChkaXNhYmxlZCkgcmV0dXJuO1xuICAgIGNvbnRhaW5lclN0eWxlLnRyYW5zZm9ybSA9IHRyYW5zbGF0ZShkaXJlY3Rpb24uYXBwbHkodGFyZ2V0KSk7XG4gIH1cbiAgZnVuY3Rpb24gdG9nZ2xlQWN0aXZlKGFjdGl2ZSkge1xuICAgIGRpc2FibGVkID0gIWFjdGl2ZTtcbiAgfVxuICBmdW5jdGlvbiBjbGVhcigpIHtcbiAgICBpZiAoZGlzYWJsZWQpIHJldHVybjtcbiAgICBjb250YWluZXJTdHlsZS50cmFuc2Zvcm0gPSAnJztcbiAgICBpZiAoIWNvbnRhaW5lci5nZXRBdHRyaWJ1dGUoJ3N0eWxlJykpIGNvbnRhaW5lci5yZW1vdmVBdHRyaWJ1dGUoJ3N0eWxlJyk7XG4gIH1cbiAgY29uc3Qgc2VsZiA9IHtcbiAgICBjbGVhcixcbiAgICB0byxcbiAgICB0b2dnbGVBY3RpdmVcbiAgfTtcbiAgcmV0dXJuIHNlbGY7XG59XG5cbmZ1bmN0aW9uIFNsaWRlTG9vcGVyKGF4aXMsIGRpcmVjdGlvbiwgdmlld1NpemUsIGNvbnRlbnRTaXplLCBzbGlkZVNpemVzLCBzbGlkZVNpemVzV2l0aEdhcHMsIHNuYXBzLCBzY3JvbGxTbmFwcywgb2Zmc2V0TG9jYXRpb24sIHNsaWRlcykge1xuICBjb25zdCByb3VuZGluZ1NhZmV0eSA9IDAuNTtcbiAgY29uc3QgYXNjSXRlbXMgPSBhcnJheUtleXMoc2xpZGVTaXplc1dpdGhHYXBzKTtcbiAgY29uc3QgZGVzY0l0ZW1zID0gYXJyYXlLZXlzKHNsaWRlU2l6ZXNXaXRoR2FwcykucmV2ZXJzZSgpO1xuICBjb25zdCBsb29wUG9pbnRzID0gc3RhcnRQb2ludHMoKS5jb25jYXQoZW5kUG9pbnRzKCkpO1xuICBmdW5jdGlvbiByZW1vdmVTbGlkZVNpemVzKGluZGV4ZXMsIGZyb20pIHtcbiAgICByZXR1cm4gaW5kZXhlcy5yZWR1Y2UoKGEsIGkpID0+IHtcbiAgICAgIHJldHVybiBhIC0gc2xpZGVTaXplc1dpdGhHYXBzW2ldO1xuICAgIH0sIGZyb20pO1xuICB9XG4gIGZ1bmN0aW9uIHNsaWRlc0luR2FwKGluZGV4ZXMsIGdhcCkge1xuICAgIHJldHVybiBpbmRleGVzLnJlZHVjZSgoYSwgaSkgPT4ge1xuICAgICAgY29uc3QgcmVtYWluaW5nR2FwID0gcmVtb3ZlU2xpZGVTaXplcyhhLCBnYXApO1xuICAgICAgcmV0dXJuIHJlbWFpbmluZ0dhcCA+IDAgPyBhLmNvbmNhdChbaV0pIDogYTtcbiAgICB9LCBbXSk7XG4gIH1cbiAgZnVuY3Rpb24gZmluZFNsaWRlQm91bmRzKG9mZnNldCkge1xuICAgIHJldHVybiBzbmFwcy5tYXAoKHNuYXAsIGluZGV4KSA9PiAoe1xuICAgICAgc3RhcnQ6IHNuYXAgLSBzbGlkZVNpemVzW2luZGV4XSArIHJvdW5kaW5nU2FmZXR5ICsgb2Zmc2V0LFxuICAgICAgZW5kOiBzbmFwICsgdmlld1NpemUgLSByb3VuZGluZ1NhZmV0eSArIG9mZnNldFxuICAgIH0pKTtcbiAgfVxuICBmdW5jdGlvbiBmaW5kTG9vcFBvaW50cyhpbmRleGVzLCBvZmZzZXQsIGlzRW5kRWRnZSkge1xuICAgIGNvbnN0IHNsaWRlQm91bmRzID0gZmluZFNsaWRlQm91bmRzKG9mZnNldCk7XG4gICAgcmV0dXJuIGluZGV4ZXMubWFwKGluZGV4ID0+IHtcbiAgICAgIGNvbnN0IGluaXRpYWwgPSBpc0VuZEVkZ2UgPyAwIDogLWNvbnRlbnRTaXplO1xuICAgICAgY29uc3QgYWx0ZXJlZCA9IGlzRW5kRWRnZSA/IGNvbnRlbnRTaXplIDogMDtcbiAgICAgIGNvbnN0IGJvdW5kRWRnZSA9IGlzRW5kRWRnZSA/ICdlbmQnIDogJ3N0YXJ0JztcbiAgICAgIGNvbnN0IGxvb3BQb2ludCA9IHNsaWRlQm91bmRzW2luZGV4XVtib3VuZEVkZ2VdO1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgaW5kZXgsXG4gICAgICAgIGxvb3BQb2ludCxcbiAgICAgICAgc2xpZGVMb2NhdGlvbjogVmVjdG9yMUQoLTEpLFxuICAgICAgICB0cmFuc2xhdGU6IFRyYW5zbGF0ZShheGlzLCBkaXJlY3Rpb24sIHNsaWRlc1tpbmRleF0pLFxuICAgICAgICB0YXJnZXQ6ICgpID0+IG9mZnNldExvY2F0aW9uLmdldCgpID4gbG9vcFBvaW50ID8gaW5pdGlhbCA6IGFsdGVyZWRcbiAgICAgIH07XG4gICAgfSk7XG4gIH1cbiAgZnVuY3Rpb24gc3RhcnRQb2ludHMoKSB7XG4gICAgY29uc3QgZ2FwID0gc2Nyb2xsU25hcHNbMF07XG4gICAgY29uc3QgaW5kZXhlcyA9IHNsaWRlc0luR2FwKGRlc2NJdGVtcywgZ2FwKTtcbiAgICByZXR1cm4gZmluZExvb3BQb2ludHMoaW5kZXhlcywgY29udGVudFNpemUsIGZhbHNlKTtcbiAgfVxuICBmdW5jdGlvbiBlbmRQb2ludHMoKSB7XG4gICAgY29uc3QgZ2FwID0gdmlld1NpemUgLSBzY3JvbGxTbmFwc1swXSAtIDE7XG4gICAgY29uc3QgaW5kZXhlcyA9IHNsaWRlc0luR2FwKGFzY0l0ZW1zLCBnYXApO1xuICAgIHJldHVybiBmaW5kTG9vcFBvaW50cyhpbmRleGVzLCAtY29udGVudFNpemUsIHRydWUpO1xuICB9XG4gIGZ1bmN0aW9uIGNhbkxvb3AoKSB7XG4gICAgcmV0dXJuIGxvb3BQb2ludHMuZXZlcnkoKHtcbiAgICAgIGluZGV4XG4gICAgfSkgPT4ge1xuICAgICAgY29uc3Qgb3RoZXJJbmRleGVzID0gYXNjSXRlbXMuZmlsdGVyKGkgPT4gaSAhPT0gaW5kZXgpO1xuICAgICAgcmV0dXJuIHJlbW92ZVNsaWRlU2l6ZXMob3RoZXJJbmRleGVzLCB2aWV3U2l6ZSkgPD0gMC4xO1xuICAgIH0pO1xuICB9XG4gIGZ1bmN0aW9uIGxvb3AoKSB7XG4gICAgbG9vcFBvaW50cy5mb3JFYWNoKGxvb3BQb2ludCA9PiB7XG4gICAgICBjb25zdCB7XG4gICAgICAgIHRhcmdldCxcbiAgICAgICAgdHJhbnNsYXRlLFxuICAgICAgICBzbGlkZUxvY2F0aW9uXG4gICAgICB9ID0gbG9vcFBvaW50O1xuICAgICAgY29uc3Qgc2hpZnRMb2NhdGlvbiA9IHRhcmdldCgpO1xuICAgICAgaWYgKHNoaWZ0TG9jYXRpb24gPT09IHNsaWRlTG9jYXRpb24uZ2V0KCkpIHJldHVybjtcbiAgICAgIHRyYW5zbGF0ZS50byhzaGlmdExvY2F0aW9uKTtcbiAgICAgIHNsaWRlTG9jYXRpb24uc2V0KHNoaWZ0TG9jYXRpb24pO1xuICAgIH0pO1xuICB9XG4gIGZ1bmN0aW9uIGNsZWFyKCkge1xuICAgIGxvb3BQb2ludHMuZm9yRWFjaChsb29wUG9pbnQgPT4gbG9vcFBvaW50LnRyYW5zbGF0ZS5jbGVhcigpKTtcbiAgfVxuICBjb25zdCBzZWxmID0ge1xuICAgIGNhbkxvb3AsXG4gICAgY2xlYXIsXG4gICAgbG9vcCxcbiAgICBsb29wUG9pbnRzXG4gIH07XG4gIHJldHVybiBzZWxmO1xufVxuXG5mdW5jdGlvbiBTbGlkZXNIYW5kbGVyKGNvbnRhaW5lciwgZXZlbnRIYW5kbGVyLCB3YXRjaFNsaWRlcykge1xuICBsZXQgbXV0YXRpb25PYnNlcnZlcjtcbiAgbGV0IGRlc3Ryb3llZCA9IGZhbHNlO1xuICBmdW5jdGlvbiBpbml0KGVtYmxhQXBpKSB7XG4gICAgaWYgKCF3YXRjaFNsaWRlcykgcmV0dXJuO1xuICAgIGZ1bmN0aW9uIGRlZmF1bHRDYWxsYmFjayhtdXRhdGlvbnMpIHtcbiAgICAgIGZvciAoY29uc3QgbXV0YXRpb24gb2YgbXV0YXRpb25zKSB7XG4gICAgICAgIGlmIChtdXRhdGlvbi50eXBlID09PSAnY2hpbGRMaXN0Jykge1xuICAgICAgICAgIGVtYmxhQXBpLnJlSW5pdCgpO1xuICAgICAgICAgIGV2ZW50SGFuZGxlci5lbWl0KCdzbGlkZXNDaGFuZ2VkJyk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgbXV0YXRpb25PYnNlcnZlciA9IG5ldyBNdXRhdGlvbk9ic2VydmVyKG11dGF0aW9ucyA9PiB7XG4gICAgICBpZiAoZGVzdHJveWVkKSByZXR1cm47XG4gICAgICBpZiAoaXNCb29sZWFuKHdhdGNoU2xpZGVzKSB8fCB3YXRjaFNsaWRlcyhlbWJsYUFwaSwgbXV0YXRpb25zKSkge1xuICAgICAgICBkZWZhdWx0Q2FsbGJhY2sobXV0YXRpb25zKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICBtdXRhdGlvbk9ic2VydmVyLm9ic2VydmUoY29udGFpbmVyLCB7XG4gICAgICBjaGlsZExpc3Q6IHRydWVcbiAgICB9KTtcbiAgfVxuICBmdW5jdGlvbiBkZXN0cm95KCkge1xuICAgIGlmIChtdXRhdGlvbk9ic2VydmVyKSBtdXRhdGlvbk9ic2VydmVyLmRpc2Nvbm5lY3QoKTtcbiAgICBkZXN0cm95ZWQgPSB0cnVlO1xuICB9XG4gIGNvbnN0IHNlbGYgPSB7XG4gICAgaW5pdCxcbiAgICBkZXN0cm95XG4gIH07XG4gIHJldHVybiBzZWxmO1xufVxuXG5mdW5jdGlvbiBTbGlkZXNJblZpZXcoY29udGFpbmVyLCBzbGlkZXMsIGV2ZW50SGFuZGxlciwgdGhyZXNob2xkKSB7XG4gIGNvbnN0IGludGVyc2VjdGlvbkVudHJ5TWFwID0ge307XG4gIGxldCBpblZpZXdDYWNoZSA9IG51bGw7XG4gIGxldCBub3RJblZpZXdDYWNoZSA9IG51bGw7XG4gIGxldCBpbnRlcnNlY3Rpb25PYnNlcnZlcjtcbiAgbGV0IGRlc3Ryb3llZCA9IGZhbHNlO1xuICBmdW5jdGlvbiBpbml0KCkge1xuICAgIGludGVyc2VjdGlvbk9ic2VydmVyID0gbmV3IEludGVyc2VjdGlvbk9ic2VydmVyKGVudHJpZXMgPT4ge1xuICAgICAgaWYgKGRlc3Ryb3llZCkgcmV0dXJuO1xuICAgICAgZW50cmllcy5mb3JFYWNoKGVudHJ5ID0+IHtcbiAgICAgICAgY29uc3QgaW5kZXggPSBzbGlkZXMuaW5kZXhPZihlbnRyeS50YXJnZXQpO1xuICAgICAgICBpbnRlcnNlY3Rpb25FbnRyeU1hcFtpbmRleF0gPSBlbnRyeTtcbiAgICAgIH0pO1xuICAgICAgaW5WaWV3Q2FjaGUgPSBudWxsO1xuICAgICAgbm90SW5WaWV3Q2FjaGUgPSBudWxsO1xuICAgICAgZXZlbnRIYW5kbGVyLmVtaXQoJ3NsaWRlc0luVmlldycpO1xuICAgIH0sIHtcbiAgICAgIHJvb3Q6IGNvbnRhaW5lci5wYXJlbnRFbGVtZW50LFxuICAgICAgdGhyZXNob2xkXG4gICAgfSk7XG4gICAgc2xpZGVzLmZvckVhY2goc2xpZGUgPT4gaW50ZXJzZWN0aW9uT2JzZXJ2ZXIub2JzZXJ2ZShzbGlkZSkpO1xuICB9XG4gIGZ1bmN0aW9uIGRlc3Ryb3koKSB7XG4gICAgaWYgKGludGVyc2VjdGlvbk9ic2VydmVyKSBpbnRlcnNlY3Rpb25PYnNlcnZlci5kaXNjb25uZWN0KCk7XG4gICAgZGVzdHJveWVkID0gdHJ1ZTtcbiAgfVxuICBmdW5jdGlvbiBjcmVhdGVJblZpZXdMaXN0KGluVmlldykge1xuICAgIHJldHVybiBvYmplY3RLZXlzKGludGVyc2VjdGlvbkVudHJ5TWFwKS5yZWR1Y2UoKGxpc3QsIHNsaWRlSW5kZXgpID0+IHtcbiAgICAgIGNvbnN0IGluZGV4ID0gcGFyc2VJbnQoc2xpZGVJbmRleCk7XG4gICAgICBjb25zdCB7XG4gICAgICAgIGlzSW50ZXJzZWN0aW5nXG4gICAgICB9ID0gaW50ZXJzZWN0aW9uRW50cnlNYXBbaW5kZXhdO1xuICAgICAgY29uc3QgaW5WaWV3TWF0Y2ggPSBpblZpZXcgJiYgaXNJbnRlcnNlY3Rpbmc7XG4gICAgICBjb25zdCBub3RJblZpZXdNYXRjaCA9ICFpblZpZXcgJiYgIWlzSW50ZXJzZWN0aW5nO1xuICAgICAgaWYgKGluVmlld01hdGNoIHx8IG5vdEluVmlld01hdGNoKSBsaXN0LnB1c2goaW5kZXgpO1xuICAgICAgcmV0dXJuIGxpc3Q7XG4gICAgfSwgW10pO1xuICB9XG4gIGZ1bmN0aW9uIGdldChpblZpZXcgPSB0cnVlKSB7XG4gICAgaWYgKGluVmlldyAmJiBpblZpZXdDYWNoZSkgcmV0dXJuIGluVmlld0NhY2hlO1xuICAgIGlmICghaW5WaWV3ICYmIG5vdEluVmlld0NhY2hlKSByZXR1cm4gbm90SW5WaWV3Q2FjaGU7XG4gICAgY29uc3Qgc2xpZGVJbmRleGVzID0gY3JlYXRlSW5WaWV3TGlzdChpblZpZXcpO1xuICAgIGlmIChpblZpZXcpIGluVmlld0NhY2hlID0gc2xpZGVJbmRleGVzO1xuICAgIGlmICghaW5WaWV3KSBub3RJblZpZXdDYWNoZSA9IHNsaWRlSW5kZXhlcztcbiAgICByZXR1cm4gc2xpZGVJbmRleGVzO1xuICB9XG4gIGNvbnN0IHNlbGYgPSB7XG4gICAgaW5pdCxcbiAgICBkZXN0cm95LFxuICAgIGdldFxuICB9O1xuICByZXR1cm4gc2VsZjtcbn1cblxuZnVuY3Rpb24gU2xpZGVTaXplcyhheGlzLCBjb250YWluZXJSZWN0LCBzbGlkZVJlY3RzLCBzbGlkZXMsIHJlYWRFZGdlR2FwLCBvd25lcldpbmRvdykge1xuICBjb25zdCB7XG4gICAgbWVhc3VyZVNpemUsXG4gICAgc3RhcnRFZGdlLFxuICAgIGVuZEVkZ2VcbiAgfSA9IGF4aXM7XG4gIGNvbnN0IHdpdGhFZGdlR2FwID0gc2xpZGVSZWN0c1swXSAmJiByZWFkRWRnZUdhcDtcbiAgY29uc3Qgc3RhcnRHYXAgPSBtZWFzdXJlU3RhcnRHYXAoKTtcbiAgY29uc3QgZW5kR2FwID0gbWVhc3VyZUVuZEdhcCgpO1xuICBjb25zdCBzbGlkZVNpemVzID0gc2xpZGVSZWN0cy5tYXAobWVhc3VyZVNpemUpO1xuICBjb25zdCBzbGlkZVNpemVzV2l0aEdhcHMgPSBtZWFzdXJlV2l0aEdhcHMoKTtcbiAgZnVuY3Rpb24gbWVhc3VyZVN0YXJ0R2FwKCkge1xuICAgIGlmICghd2l0aEVkZ2VHYXApIHJldHVybiAwO1xuICAgIGNvbnN0IHNsaWRlUmVjdCA9IHNsaWRlUmVjdHNbMF07XG4gICAgcmV0dXJuIG1hdGhBYnMoY29udGFpbmVyUmVjdFtzdGFydEVkZ2VdIC0gc2xpZGVSZWN0W3N0YXJ0RWRnZV0pO1xuICB9XG4gIGZ1bmN0aW9uIG1lYXN1cmVFbmRHYXAoKSB7XG4gICAgaWYgKCF3aXRoRWRnZUdhcCkgcmV0dXJuIDA7XG4gICAgY29uc3Qgc3R5bGUgPSBvd25lcldpbmRvdy5nZXRDb21wdXRlZFN0eWxlKGFycmF5TGFzdChzbGlkZXMpKTtcbiAgICByZXR1cm4gcGFyc2VGbG9hdChzdHlsZS5nZXRQcm9wZXJ0eVZhbHVlKGBtYXJnaW4tJHtlbmRFZGdlfWApKTtcbiAgfVxuICBmdW5jdGlvbiBtZWFzdXJlV2l0aEdhcHMoKSB7XG4gICAgcmV0dXJuIHNsaWRlUmVjdHMubWFwKChyZWN0LCBpbmRleCwgcmVjdHMpID0+IHtcbiAgICAgIGNvbnN0IGlzRmlyc3QgPSAhaW5kZXg7XG4gICAgICBjb25zdCBpc0xhc3QgPSBhcnJheUlzTGFzdEluZGV4KHJlY3RzLCBpbmRleCk7XG4gICAgICBpZiAoaXNGaXJzdCkgcmV0dXJuIHNsaWRlU2l6ZXNbaW5kZXhdICsgc3RhcnRHYXA7XG4gICAgICBpZiAoaXNMYXN0KSByZXR1cm4gc2xpZGVTaXplc1tpbmRleF0gKyBlbmRHYXA7XG4gICAgICByZXR1cm4gcmVjdHNbaW5kZXggKyAxXVtzdGFydEVkZ2VdIC0gcmVjdFtzdGFydEVkZ2VdO1xuICAgIH0pLm1hcChtYXRoQWJzKTtcbiAgfVxuICBjb25zdCBzZWxmID0ge1xuICAgIHNsaWRlU2l6ZXMsXG4gICAgc2xpZGVTaXplc1dpdGhHYXBzLFxuICAgIHN0YXJ0R2FwLFxuICAgIGVuZEdhcFxuICB9O1xuICByZXR1cm4gc2VsZjtcbn1cblxuZnVuY3Rpb24gU2xpZGVzVG9TY3JvbGwoYXhpcywgZGlyZWN0aW9uLCB2aWV3U2l6ZSwgc2xpZGVzVG9TY3JvbGwsIGxvb3AsIGNvbnRhaW5lclJlY3QsIHNsaWRlUmVjdHMsIHN0YXJ0R2FwLCBlbmRHYXAsIHBpeGVsVG9sZXJhbmNlKSB7XG4gIGNvbnN0IHtcbiAgICBzdGFydEVkZ2UsXG4gICAgZW5kRWRnZVxuICB9ID0gYXhpcztcbiAgY29uc3QgZ3JvdXBCeU51bWJlciA9IGlzTnVtYmVyKHNsaWRlc1RvU2Nyb2xsKTtcbiAgZnVuY3Rpb24gYnlOdW1iZXIoYXJyYXksIGdyb3VwU2l6ZSkge1xuICAgIHJldHVybiBhcnJheUtleXMoYXJyYXkpLmZpbHRlcihpID0+IGkgJSBncm91cFNpemUgPT09IDApLm1hcChpID0+IGFycmF5LnNsaWNlKGksIGkgKyBncm91cFNpemUpKTtcbiAgfVxuICBmdW5jdGlvbiBieVNpemUoYXJyYXkpIHtcbiAgICBpZiAoIWFycmF5Lmxlbmd0aCkgcmV0dXJuIFtdO1xuICAgIHJldHVybiBhcnJheUtleXMoYXJyYXkpLnJlZHVjZSgoZ3JvdXBzLCByZWN0QikgPT4ge1xuICAgICAgY29uc3QgcmVjdEEgPSBhcnJheUxhc3QoZ3JvdXBzKSB8fCAwO1xuICAgICAgY29uc3QgaXNGaXJzdCA9IHJlY3RBID09PSAwO1xuICAgICAgY29uc3QgaXNMYXN0ID0gcmVjdEIgPT09IGFycmF5TGFzdEluZGV4KGFycmF5KTtcbiAgICAgIGNvbnN0IGVkZ2VBID0gY29udGFpbmVyUmVjdFtzdGFydEVkZ2VdIC0gc2xpZGVSZWN0c1tyZWN0QV1bc3RhcnRFZGdlXTtcbiAgICAgIGNvbnN0IGVkZ2VCID0gY29udGFpbmVyUmVjdFtzdGFydEVkZ2VdIC0gc2xpZGVSZWN0c1tyZWN0Ql1bZW5kRWRnZV07XG4gICAgICBjb25zdCBnYXBBID0gIWxvb3AgJiYgaXNGaXJzdCA/IGRpcmVjdGlvbi5hcHBseShzdGFydEdhcCkgOiAwO1xuICAgICAgY29uc3QgZ2FwQiA9ICFsb29wICYmIGlzTGFzdCA/IGRpcmVjdGlvbi5hcHBseShlbmRHYXApIDogMDtcbiAgICAgIGNvbnN0IGNodW5rU2l6ZSA9IG1hdGhBYnMoZWRnZUIgLSBnYXBCIC0gKGVkZ2VBICsgZ2FwQSkpO1xuICAgICAgaWYgKGNodW5rU2l6ZSA+IHZpZXdTaXplICsgcGl4ZWxUb2xlcmFuY2UpIGdyb3Vwcy5wdXNoKHJlY3RCKTtcbiAgICAgIGlmIChpc0xhc3QpIGdyb3Vwcy5wdXNoKGFycmF5Lmxlbmd0aCk7XG4gICAgICByZXR1cm4gZ3JvdXBzO1xuICAgIH0sIFtdKS5tYXAoKGN1cnJlbnRTaXplLCBpbmRleCwgZ3JvdXBzKSA9PiB7XG4gICAgICBjb25zdCBwcmV2aW91c1NpemUgPSBNYXRoLm1heChncm91cHNbaW5kZXggLSAxXSB8fCAwKTtcbiAgICAgIHJldHVybiBhcnJheS5zbGljZShwcmV2aW91c1NpemUsIGN1cnJlbnRTaXplKTtcbiAgICB9KTtcbiAgfVxuICBmdW5jdGlvbiBncm91cFNsaWRlcyhhcnJheSkge1xuICAgIHJldHVybiBncm91cEJ5TnVtYmVyID8gYnlOdW1iZXIoYXJyYXksIHNsaWRlc1RvU2Nyb2xsKSA6IGJ5U2l6ZShhcnJheSk7XG4gIH1cbiAgY29uc3Qgc2VsZiA9IHtcbiAgICBncm91cFNsaWRlc1xuICB9O1xuICByZXR1cm4gc2VsZjtcbn1cblxuZnVuY3Rpb24gRW5naW5lKHJvb3QsIGNvbnRhaW5lciwgc2xpZGVzLCBvd25lckRvY3VtZW50LCBvd25lcldpbmRvdywgb3B0aW9ucywgZXZlbnRIYW5kbGVyKSB7XG4gIC8vIE9wdGlvbnNcbiAgY29uc3Qge1xuICAgIGFsaWduLFxuICAgIGF4aXM6IHNjcm9sbEF4aXMsXG4gICAgZGlyZWN0aW9uOiBjb250ZW50RGlyZWN0aW9uLFxuICAgIHN0YXJ0SW5kZXgsXG4gICAgbG9vcCxcbiAgICBkdXJhdGlvbixcbiAgICBkcmFnRnJlZSxcbiAgICBkcmFnVGhyZXNob2xkLFxuICAgIGluVmlld1RocmVzaG9sZCxcbiAgICBzbGlkZXNUb1Njcm9sbDogZ3JvdXBTbGlkZXMsXG4gICAgc2tpcFNuYXBzLFxuICAgIGNvbnRhaW5TY3JvbGwsXG4gICAgd2F0Y2hSZXNpemUsXG4gICAgd2F0Y2hTbGlkZXMsXG4gICAgd2F0Y2hEcmFnXG4gIH0gPSBvcHRpb25zO1xuICAvLyBNZWFzdXJlbWVudHNcbiAgY29uc3QgcGl4ZWxUb2xlcmFuY2UgPSAyO1xuICBjb25zdCBub2RlUmVjdHMgPSBOb2RlUmVjdHMoKTtcbiAgY29uc3QgY29udGFpbmVyUmVjdCA9IG5vZGVSZWN0cy5tZWFzdXJlKGNvbnRhaW5lcik7XG4gIGNvbnN0IHNsaWRlUmVjdHMgPSBzbGlkZXMubWFwKG5vZGVSZWN0cy5tZWFzdXJlKTtcbiAgY29uc3QgZGlyZWN0aW9uID0gRGlyZWN0aW9uKGNvbnRlbnREaXJlY3Rpb24pO1xuICBjb25zdCBheGlzID0gQXhpcyhzY3JvbGxBeGlzLCBjb250ZW50RGlyZWN0aW9uKTtcbiAgY29uc3Qgdmlld1NpemUgPSBheGlzLm1lYXN1cmVTaXplKGNvbnRhaW5lclJlY3QpO1xuICBjb25zdCBwZXJjZW50T2ZWaWV3ID0gUGVyY2VudE9mVmlldyh2aWV3U2l6ZSk7XG4gIGNvbnN0IGFsaWdubWVudCA9IEFsaWdubWVudChhbGlnbiwgdmlld1NpemUpO1xuICBjb25zdCBjb250YWluU25hcHMgPSAhbG9vcCAmJiAhIWNvbnRhaW5TY3JvbGw7XG4gIGNvbnN0IHJlYWRFZGdlR2FwID0gbG9vcCB8fCAhIWNvbnRhaW5TY3JvbGw7XG4gIGNvbnN0IHtcbiAgICBzbGlkZVNpemVzLFxuICAgIHNsaWRlU2l6ZXNXaXRoR2FwcyxcbiAgICBzdGFydEdhcCxcbiAgICBlbmRHYXBcbiAgfSA9IFNsaWRlU2l6ZXMoYXhpcywgY29udGFpbmVyUmVjdCwgc2xpZGVSZWN0cywgc2xpZGVzLCByZWFkRWRnZUdhcCwgb3duZXJXaW5kb3cpO1xuICBjb25zdCBzbGlkZXNUb1Njcm9sbCA9IFNsaWRlc1RvU2Nyb2xsKGF4aXMsIGRpcmVjdGlvbiwgdmlld1NpemUsIGdyb3VwU2xpZGVzLCBsb29wLCBjb250YWluZXJSZWN0LCBzbGlkZVJlY3RzLCBzdGFydEdhcCwgZW5kR2FwLCBwaXhlbFRvbGVyYW5jZSk7XG4gIGNvbnN0IHtcbiAgICBzbmFwcyxcbiAgICBzbmFwc0FsaWduZWRcbiAgfSA9IFNjcm9sbFNuYXBzKGF4aXMsIGFsaWdubWVudCwgY29udGFpbmVyUmVjdCwgc2xpZGVSZWN0cywgc2xpZGVzVG9TY3JvbGwpO1xuICBjb25zdCBjb250ZW50U2l6ZSA9IC1hcnJheUxhc3Qoc25hcHMpICsgYXJyYXlMYXN0KHNsaWRlU2l6ZXNXaXRoR2Fwcyk7XG4gIGNvbnN0IHtcbiAgICBzbmFwc0NvbnRhaW5lZCxcbiAgICBzY3JvbGxDb250YWluTGltaXRcbiAgfSA9IFNjcm9sbENvbnRhaW4odmlld1NpemUsIGNvbnRlbnRTaXplLCBzbmFwc0FsaWduZWQsIGNvbnRhaW5TY3JvbGwsIHBpeGVsVG9sZXJhbmNlKTtcbiAgY29uc3Qgc2Nyb2xsU25hcHMgPSBjb250YWluU25hcHMgPyBzbmFwc0NvbnRhaW5lZCA6IHNuYXBzQWxpZ25lZDtcbiAgY29uc3Qge1xuICAgIGxpbWl0XG4gIH0gPSBTY3JvbGxMaW1pdChjb250ZW50U2l6ZSwgc2Nyb2xsU25hcHMsIGxvb3ApO1xuICAvLyBJbmRleGVzXG4gIGNvbnN0IGluZGV4ID0gQ291bnRlcihhcnJheUxhc3RJbmRleChzY3JvbGxTbmFwcyksIHN0YXJ0SW5kZXgsIGxvb3ApO1xuICBjb25zdCBpbmRleFByZXZpb3VzID0gaW5kZXguY2xvbmUoKTtcbiAgY29uc3Qgc2xpZGVJbmRleGVzID0gYXJyYXlLZXlzKHNsaWRlcyk7XG4gIC8vIEFuaW1hdGlvblxuICBjb25zdCB1cGRhdGUgPSAoe1xuICAgIGRyYWdIYW5kbGVyLFxuICAgIHNjcm9sbEJvZHksXG4gICAgc2Nyb2xsQm91bmRzLFxuICAgIG9wdGlvbnM6IHtcbiAgICAgIGxvb3BcbiAgICB9XG4gIH0pID0+IHtcbiAgICBpZiAoIWxvb3ApIHNjcm9sbEJvdW5kcy5jb25zdHJhaW4oZHJhZ0hhbmRsZXIucG9pbnRlckRvd24oKSk7XG4gICAgc2Nyb2xsQm9keS5zZWVrKCk7XG4gIH07XG4gIGNvbnN0IHJlbmRlciA9ICh7XG4gICAgc2Nyb2xsQm9keSxcbiAgICB0cmFuc2xhdGUsXG4gICAgbG9jYXRpb24sXG4gICAgb2Zmc2V0TG9jYXRpb24sXG4gICAgc2Nyb2xsTG9vcGVyLFxuICAgIHNsaWRlTG9vcGVyLFxuICAgIGRyYWdIYW5kbGVyLFxuICAgIGFuaW1hdGlvbixcbiAgICBldmVudEhhbmRsZXIsXG4gICAgb3B0aW9uczoge1xuICAgICAgbG9vcFxuICAgIH1cbiAgfSwgbGFnT2Zmc2V0KSA9PiB7XG4gICAgY29uc3QgdmVsb2NpdHkgPSBzY3JvbGxCb2R5LnZlbG9jaXR5KCk7XG4gICAgY29uc3QgaGFzU2V0dGxlZCA9IHNjcm9sbEJvZHkuc2V0dGxlZCgpO1xuICAgIGlmIChoYXNTZXR0bGVkICYmICFkcmFnSGFuZGxlci5wb2ludGVyRG93bigpKSB7XG4gICAgICBhbmltYXRpb24uc3RvcCgpO1xuICAgICAgZXZlbnRIYW5kbGVyLmVtaXQoJ3NldHRsZScpO1xuICAgIH1cbiAgICBpZiAoIWhhc1NldHRsZWQpIGV2ZW50SGFuZGxlci5lbWl0KCdzY3JvbGwnKTtcbiAgICBvZmZzZXRMb2NhdGlvbi5zZXQobG9jYXRpb24uZ2V0KCkgLSB2ZWxvY2l0eSArIHZlbG9jaXR5ICogbGFnT2Zmc2V0KTtcbiAgICBpZiAobG9vcCkge1xuICAgICAgc2Nyb2xsTG9vcGVyLmxvb3Aoc2Nyb2xsQm9keS5kaXJlY3Rpb24oKSk7XG4gICAgICBzbGlkZUxvb3Blci5sb29wKCk7XG4gICAgfVxuICAgIHRyYW5zbGF0ZS50byhvZmZzZXRMb2NhdGlvbi5nZXQoKSk7XG4gIH07XG4gIGNvbnN0IGFuaW1hdGlvbiA9IEFuaW1hdGlvbnMob3duZXJEb2N1bWVudCwgb3duZXJXaW5kb3csICgpID0+IHVwZGF0ZShlbmdpbmUpLCBsYWdPZmZzZXQgPT4gcmVuZGVyKGVuZ2luZSwgbGFnT2Zmc2V0KSk7XG4gIC8vIFNoYXJlZFxuICBjb25zdCBmcmljdGlvbiA9IDAuNjg7XG4gIGNvbnN0IHN0YXJ0TG9jYXRpb24gPSBzY3JvbGxTbmFwc1tpbmRleC5nZXQoKV07XG4gIGNvbnN0IGxvY2F0aW9uID0gVmVjdG9yMUQoc3RhcnRMb2NhdGlvbik7XG4gIGNvbnN0IG9mZnNldExvY2F0aW9uID0gVmVjdG9yMUQoc3RhcnRMb2NhdGlvbik7XG4gIGNvbnN0IHRhcmdldCA9IFZlY3RvcjFEKHN0YXJ0TG9jYXRpb24pO1xuICBjb25zdCBzY3JvbGxCb2R5ID0gU2Nyb2xsQm9keShsb2NhdGlvbiwgb2Zmc2V0TG9jYXRpb24sIHRhcmdldCwgZHVyYXRpb24sIGZyaWN0aW9uKTtcbiAgY29uc3Qgc2Nyb2xsVGFyZ2V0ID0gU2Nyb2xsVGFyZ2V0KGxvb3AsIHNjcm9sbFNuYXBzLCBjb250ZW50U2l6ZSwgbGltaXQsIHRhcmdldCk7XG4gIGNvbnN0IHNjcm9sbFRvID0gU2Nyb2xsVG8oYW5pbWF0aW9uLCBpbmRleCwgaW5kZXhQcmV2aW91cywgc2Nyb2xsQm9keSwgc2Nyb2xsVGFyZ2V0LCB0YXJnZXQsIGV2ZW50SGFuZGxlcik7XG4gIGNvbnN0IHNjcm9sbFByb2dyZXNzID0gU2Nyb2xsUHJvZ3Jlc3MobGltaXQpO1xuICBjb25zdCBldmVudFN0b3JlID0gRXZlbnRTdG9yZSgpO1xuICBjb25zdCBzbGlkZXNJblZpZXcgPSBTbGlkZXNJblZpZXcoY29udGFpbmVyLCBzbGlkZXMsIGV2ZW50SGFuZGxlciwgaW5WaWV3VGhyZXNob2xkKTtcbiAgY29uc3Qge1xuICAgIHNsaWRlUmVnaXN0cnlcbiAgfSA9IFNsaWRlUmVnaXN0cnkoY29udGFpblNuYXBzLCBjb250YWluU2Nyb2xsLCBzY3JvbGxTbmFwcywgc2Nyb2xsQ29udGFpbkxpbWl0LCBzbGlkZXNUb1Njcm9sbCwgc2xpZGVJbmRleGVzKTtcbiAgY29uc3Qgc2xpZGVGb2N1cyA9IFNsaWRlRm9jdXMocm9vdCwgc2xpZGVzLCBzbGlkZVJlZ2lzdHJ5LCBzY3JvbGxUbywgc2Nyb2xsQm9keSwgZXZlbnRTdG9yZSk7XG4gIC8vIEVuZ2luZVxuICBjb25zdCBlbmdpbmUgPSB7XG4gICAgb3duZXJEb2N1bWVudCxcbiAgICBvd25lcldpbmRvdyxcbiAgICBldmVudEhhbmRsZXIsXG4gICAgY29udGFpbmVyUmVjdCxcbiAgICBzbGlkZVJlY3RzLFxuICAgIGFuaW1hdGlvbixcbiAgICBheGlzLFxuICAgIGRpcmVjdGlvbixcbiAgICBkcmFnSGFuZGxlcjogRHJhZ0hhbmRsZXIoYXhpcywgZGlyZWN0aW9uLCByb290LCBvd25lckRvY3VtZW50LCBvd25lcldpbmRvdywgdGFyZ2V0LCBEcmFnVHJhY2tlcihheGlzLCBvd25lcldpbmRvdyksIGxvY2F0aW9uLCBhbmltYXRpb24sIHNjcm9sbFRvLCBzY3JvbGxCb2R5LCBzY3JvbGxUYXJnZXQsIGluZGV4LCBldmVudEhhbmRsZXIsIHBlcmNlbnRPZlZpZXcsIGRyYWdGcmVlLCBkcmFnVGhyZXNob2xkLCBza2lwU25hcHMsIGZyaWN0aW9uLCB3YXRjaERyYWcpLFxuICAgIGV2ZW50U3RvcmUsXG4gICAgcGVyY2VudE9mVmlldyxcbiAgICBpbmRleCxcbiAgICBpbmRleFByZXZpb3VzLFxuICAgIGxpbWl0LFxuICAgIGxvY2F0aW9uLFxuICAgIG9mZnNldExvY2F0aW9uLFxuICAgIG9wdGlvbnMsXG4gICAgcmVzaXplSGFuZGxlcjogUmVzaXplSGFuZGxlcihjb250YWluZXIsIGV2ZW50SGFuZGxlciwgb3duZXJXaW5kb3csIHNsaWRlcywgYXhpcywgd2F0Y2hSZXNpemUsIG5vZGVSZWN0cyksXG4gICAgc2Nyb2xsQm9keSxcbiAgICBzY3JvbGxCb3VuZHM6IFNjcm9sbEJvdW5kcyhsaW1pdCwgbG9jYXRpb24sIHRhcmdldCwgc2Nyb2xsQm9keSwgcGVyY2VudE9mVmlldyksXG4gICAgc2Nyb2xsTG9vcGVyOiBTY3JvbGxMb29wZXIoY29udGVudFNpemUsIGxpbWl0LCBvZmZzZXRMb2NhdGlvbiwgW2xvY2F0aW9uLCBvZmZzZXRMb2NhdGlvbiwgdGFyZ2V0XSksXG4gICAgc2Nyb2xsUHJvZ3Jlc3MsXG4gICAgc2Nyb2xsU25hcExpc3Q6IHNjcm9sbFNuYXBzLm1hcChzY3JvbGxQcm9ncmVzcy5nZXQpLFxuICAgIHNjcm9sbFNuYXBzLFxuICAgIHNjcm9sbFRhcmdldCxcbiAgICBzY3JvbGxUbyxcbiAgICBzbGlkZUxvb3BlcjogU2xpZGVMb29wZXIoYXhpcywgZGlyZWN0aW9uLCB2aWV3U2l6ZSwgY29udGVudFNpemUsIHNsaWRlU2l6ZXMsIHNsaWRlU2l6ZXNXaXRoR2Fwcywgc25hcHMsIHNjcm9sbFNuYXBzLCBvZmZzZXRMb2NhdGlvbiwgc2xpZGVzKSxcbiAgICBzbGlkZUZvY3VzLFxuICAgIHNsaWRlc0hhbmRsZXI6IFNsaWRlc0hhbmRsZXIoY29udGFpbmVyLCBldmVudEhhbmRsZXIsIHdhdGNoU2xpZGVzKSxcbiAgICBzbGlkZXNJblZpZXcsXG4gICAgc2xpZGVJbmRleGVzLFxuICAgIHNsaWRlUmVnaXN0cnksXG4gICAgc2xpZGVzVG9TY3JvbGwsXG4gICAgdGFyZ2V0LFxuICAgIHRyYW5zbGF0ZTogVHJhbnNsYXRlKGF4aXMsIGRpcmVjdGlvbiwgY29udGFpbmVyKVxuICB9O1xuICByZXR1cm4gZW5naW5lO1xufVxuXG5mdW5jdGlvbiBFdmVudEhhbmRsZXIoKSB7XG4gIGNvbnN0IGxpc3RlbmVycyA9IHt9O1xuICBsZXQgYXBpO1xuICBmdW5jdGlvbiBpbml0KGVtYmxhQXBpKSB7XG4gICAgYXBpID0gZW1ibGFBcGk7XG4gIH1cbiAgZnVuY3Rpb24gZ2V0TGlzdGVuZXJzKGV2dCkge1xuICAgIHJldHVybiBsaXN0ZW5lcnNbZXZ0XSB8fCBbXTtcbiAgfVxuICBmdW5jdGlvbiBlbWl0KGV2dCkge1xuICAgIGdldExpc3RlbmVycyhldnQpLmZvckVhY2goZSA9PiBlKGFwaSwgZXZ0KSk7XG4gICAgcmV0dXJuIHNlbGY7XG4gIH1cbiAgZnVuY3Rpb24gb24oZXZ0LCBjYikge1xuICAgIGxpc3RlbmVyc1tldnRdID0gZ2V0TGlzdGVuZXJzKGV2dCkuY29uY2F0KFtjYl0pO1xuICAgIHJldHVybiBzZWxmO1xuICB9XG4gIGZ1bmN0aW9uIG9mZihldnQsIGNiKSB7XG4gICAgbGlzdGVuZXJzW2V2dF0gPSBnZXRMaXN0ZW5lcnMoZXZ0KS5maWx0ZXIoZSA9PiBlICE9PSBjYik7XG4gICAgcmV0dXJuIHNlbGY7XG4gIH1cbiAgY29uc3Qgc2VsZiA9IHtcbiAgICBpbml0LFxuICAgIGVtaXQsXG4gICAgb2ZmLFxuICAgIG9uXG4gIH07XG4gIHJldHVybiBzZWxmO1xufVxuXG5jb25zdCBkZWZhdWx0T3B0aW9ucyA9IHtcbiAgYWxpZ246ICdjZW50ZXInLFxuICBheGlzOiAneCcsXG4gIGNvbnRhaW5lcjogbnVsbCxcbiAgc2xpZGVzOiBudWxsLFxuICBjb250YWluU2Nyb2xsOiAndHJpbVNuYXBzJyxcbiAgZGlyZWN0aW9uOiAnbHRyJyxcbiAgc2xpZGVzVG9TY3JvbGw6IDEsXG4gIGluVmlld1RocmVzaG9sZDogMCxcbiAgYnJlYWtwb2ludHM6IHt9LFxuICBkcmFnRnJlZTogZmFsc2UsXG4gIGRyYWdUaHJlc2hvbGQ6IDEwLFxuICBsb29wOiBmYWxzZSxcbiAgc2tpcFNuYXBzOiBmYWxzZSxcbiAgZHVyYXRpb246IDI1LFxuICBzdGFydEluZGV4OiAwLFxuICBhY3RpdmU6IHRydWUsXG4gIHdhdGNoRHJhZzogdHJ1ZSxcbiAgd2F0Y2hSZXNpemU6IHRydWUsXG4gIHdhdGNoU2xpZGVzOiB0cnVlXG59O1xuXG5mdW5jdGlvbiBPcHRpb25zSGFuZGxlcihvd25lcldpbmRvdykge1xuICBmdW5jdGlvbiBtZXJnZU9wdGlvbnMob3B0aW9uc0EsIG9wdGlvbnNCKSB7XG4gICAgcmV0dXJuIG9iamVjdHNNZXJnZURlZXAob3B0aW9uc0EsIG9wdGlvbnNCIHx8IHt9KTtcbiAgfVxuICBmdW5jdGlvbiBvcHRpb25zQXRNZWRpYShvcHRpb25zKSB7XG4gICAgY29uc3Qgb3B0aW9uc0F0TWVkaWEgPSBvcHRpb25zLmJyZWFrcG9pbnRzIHx8IHt9O1xuICAgIGNvbnN0IG1hdGNoZWRNZWRpYU9wdGlvbnMgPSBvYmplY3RLZXlzKG9wdGlvbnNBdE1lZGlhKS5maWx0ZXIobWVkaWEgPT4gb3duZXJXaW5kb3cubWF0Y2hNZWRpYShtZWRpYSkubWF0Y2hlcykubWFwKG1lZGlhID0+IG9wdGlvbnNBdE1lZGlhW21lZGlhXSkucmVkdWNlKChhLCBtZWRpYU9wdGlvbikgPT4gbWVyZ2VPcHRpb25zKGEsIG1lZGlhT3B0aW9uKSwge30pO1xuICAgIHJldHVybiBtZXJnZU9wdGlvbnMob3B0aW9ucywgbWF0Y2hlZE1lZGlhT3B0aW9ucyk7XG4gIH1cbiAgZnVuY3Rpb24gb3B0aW9uc01lZGlhUXVlcmllcyhvcHRpb25zTGlzdCkge1xuICAgIHJldHVybiBvcHRpb25zTGlzdC5tYXAob3B0aW9ucyA9PiBvYmplY3RLZXlzKG9wdGlvbnMuYnJlYWtwb2ludHMgfHwge30pKS5yZWR1Y2UoKGFjYywgbWVkaWFRdWVyaWVzKSA9PiBhY2MuY29uY2F0KG1lZGlhUXVlcmllcyksIFtdKS5tYXAob3duZXJXaW5kb3cubWF0Y2hNZWRpYSk7XG4gIH1cbiAgY29uc3Qgc2VsZiA9IHtcbiAgICBtZXJnZU9wdGlvbnMsXG4gICAgb3B0aW9uc0F0TWVkaWEsXG4gICAgb3B0aW9uc01lZGlhUXVlcmllc1xuICB9O1xuICByZXR1cm4gc2VsZjtcbn1cblxuZnVuY3Rpb24gUGx1Z2luc0hhbmRsZXIob3B0aW9uc0hhbmRsZXIpIHtcbiAgbGV0IGFjdGl2ZVBsdWdpbnMgPSBbXTtcbiAgZnVuY3Rpb24gaW5pdChlbWJsYUFwaSwgcGx1Z2lucykge1xuICAgIGFjdGl2ZVBsdWdpbnMgPSBwbHVnaW5zLmZpbHRlcigoe1xuICAgICAgb3B0aW9uc1xuICAgIH0pID0+IG9wdGlvbnNIYW5kbGVyLm9wdGlvbnNBdE1lZGlhKG9wdGlvbnMpLmFjdGl2ZSAhPT0gZmFsc2UpO1xuICAgIGFjdGl2ZVBsdWdpbnMuZm9yRWFjaChwbHVnaW4gPT4gcGx1Z2luLmluaXQoZW1ibGFBcGksIG9wdGlvbnNIYW5kbGVyKSk7XG4gICAgcmV0dXJuIHBsdWdpbnMucmVkdWNlKChtYXAsIHBsdWdpbikgPT4gT2JqZWN0LmFzc2lnbihtYXAsIHtcbiAgICAgIFtwbHVnaW4ubmFtZV06IHBsdWdpblxuICAgIH0pLCB7fSk7XG4gIH1cbiAgZnVuY3Rpb24gZGVzdHJveSgpIHtcbiAgICBhY3RpdmVQbHVnaW5zID0gYWN0aXZlUGx1Z2lucy5maWx0ZXIocGx1Z2luID0+IHBsdWdpbi5kZXN0cm95KCkpO1xuICB9XG4gIGNvbnN0IHNlbGYgPSB7XG4gICAgaW5pdCxcbiAgICBkZXN0cm95XG4gIH07XG4gIHJldHVybiBzZWxmO1xufVxuXG5mdW5jdGlvbiBFbWJsYUNhcm91c2VsKHJvb3QsIHVzZXJPcHRpb25zLCB1c2VyUGx1Z2lucykge1xuICBjb25zdCBvd25lckRvY3VtZW50ID0gcm9vdC5vd25lckRvY3VtZW50O1xuICBjb25zdCBvd25lcldpbmRvdyA9IG93bmVyRG9jdW1lbnQuZGVmYXVsdFZpZXc7XG4gIGNvbnN0IG9wdGlvbnNIYW5kbGVyID0gT3B0aW9uc0hhbmRsZXIob3duZXJXaW5kb3cpO1xuICBjb25zdCBwbHVnaW5zSGFuZGxlciA9IFBsdWdpbnNIYW5kbGVyKG9wdGlvbnNIYW5kbGVyKTtcbiAgY29uc3QgbWVkaWFIYW5kbGVycyA9IEV2ZW50U3RvcmUoKTtcbiAgY29uc3QgZXZlbnRIYW5kbGVyID0gRXZlbnRIYW5kbGVyKCk7XG4gIGNvbnN0IHtcbiAgICBtZXJnZU9wdGlvbnMsXG4gICAgb3B0aW9uc0F0TWVkaWEsXG4gICAgb3B0aW9uc01lZGlhUXVlcmllc1xuICB9ID0gb3B0aW9uc0hhbmRsZXI7XG4gIGNvbnN0IHtcbiAgICBvbixcbiAgICBvZmYsXG4gICAgZW1pdFxuICB9ID0gZXZlbnRIYW5kbGVyO1xuICBjb25zdCByZUluaXQgPSByZUFjdGl2YXRlO1xuICBsZXQgZGVzdHJveWVkID0gZmFsc2U7XG4gIGxldCBlbmdpbmU7XG4gIGxldCBvcHRpb25zQmFzZSA9IG1lcmdlT3B0aW9ucyhkZWZhdWx0T3B0aW9ucywgRW1ibGFDYXJvdXNlbC5nbG9iYWxPcHRpb25zKTtcbiAgbGV0IG9wdGlvbnMgPSBtZXJnZU9wdGlvbnMob3B0aW9uc0Jhc2UpO1xuICBsZXQgcGx1Z2luTGlzdCA9IFtdO1xuICBsZXQgcGx1Z2luQXBpcztcbiAgbGV0IGNvbnRhaW5lcjtcbiAgbGV0IHNsaWRlcztcbiAgZnVuY3Rpb24gc3RvcmVFbGVtZW50cygpIHtcbiAgICBjb25zdCB7XG4gICAgICBjb250YWluZXI6IHVzZXJDb250YWluZXIsXG4gICAgICBzbGlkZXM6IHVzZXJTbGlkZXNcbiAgICB9ID0gb3B0aW9ucztcbiAgICBjb25zdCBjdXN0b21Db250YWluZXIgPSBpc1N0cmluZyh1c2VyQ29udGFpbmVyKSA/IHJvb3QucXVlcnlTZWxlY3Rvcih1c2VyQ29udGFpbmVyKSA6IHVzZXJDb250YWluZXI7XG4gICAgY29udGFpbmVyID0gY3VzdG9tQ29udGFpbmVyIHx8IHJvb3QuY2hpbGRyZW5bMF07XG4gICAgY29uc3QgY3VzdG9tU2xpZGVzID0gaXNTdHJpbmcodXNlclNsaWRlcykgPyBjb250YWluZXIucXVlcnlTZWxlY3RvckFsbCh1c2VyU2xpZGVzKSA6IHVzZXJTbGlkZXM7XG4gICAgc2xpZGVzID0gW10uc2xpY2UuY2FsbChjdXN0b21TbGlkZXMgfHwgY29udGFpbmVyLmNoaWxkcmVuKTtcbiAgfVxuICBmdW5jdGlvbiBjcmVhdGVFbmdpbmUob3B0aW9ucykge1xuICAgIGNvbnN0IGVuZ2luZSA9IEVuZ2luZShyb290LCBjb250YWluZXIsIHNsaWRlcywgb3duZXJEb2N1bWVudCwgb3duZXJXaW5kb3csIG9wdGlvbnMsIGV2ZW50SGFuZGxlcik7XG4gICAgaWYgKG9wdGlvbnMubG9vcCAmJiAhZW5naW5lLnNsaWRlTG9vcGVyLmNhbkxvb3AoKSkge1xuICAgICAgY29uc3Qgb3B0aW9uc1dpdGhvdXRMb29wID0gT2JqZWN0LmFzc2lnbih7fSwgb3B0aW9ucywge1xuICAgICAgICBsb29wOiBmYWxzZVxuICAgICAgfSk7XG4gICAgICByZXR1cm4gY3JlYXRlRW5naW5lKG9wdGlvbnNXaXRob3V0TG9vcCk7XG4gICAgfVxuICAgIHJldHVybiBlbmdpbmU7XG4gIH1cbiAgZnVuY3Rpb24gYWN0aXZhdGUod2l0aE9wdGlvbnMsIHdpdGhQbHVnaW5zKSB7XG4gICAgaWYgKGRlc3Ryb3llZCkgcmV0dXJuO1xuICAgIG9wdGlvbnNCYXNlID0gbWVyZ2VPcHRpb25zKG9wdGlvbnNCYXNlLCB3aXRoT3B0aW9ucyk7XG4gICAgb3B0aW9ucyA9IG9wdGlvbnNBdE1lZGlhKG9wdGlvbnNCYXNlKTtcbiAgICBwbHVnaW5MaXN0ID0gd2l0aFBsdWdpbnMgfHwgcGx1Z2luTGlzdDtcbiAgICBzdG9yZUVsZW1lbnRzKCk7XG4gICAgZW5naW5lID0gY3JlYXRlRW5naW5lKG9wdGlvbnMpO1xuICAgIG9wdGlvbnNNZWRpYVF1ZXJpZXMoW29wdGlvbnNCYXNlLCAuLi5wbHVnaW5MaXN0Lm1hcCgoe1xuICAgICAgb3B0aW9uc1xuICAgIH0pID0+IG9wdGlvbnMpXSkuZm9yRWFjaChxdWVyeSA9PiBtZWRpYUhhbmRsZXJzLmFkZChxdWVyeSwgJ2NoYW5nZScsIHJlQWN0aXZhdGUpKTtcbiAgICBpZiAoIW9wdGlvbnMuYWN0aXZlKSByZXR1cm47XG4gICAgZW5naW5lLnRyYW5zbGF0ZS50byhlbmdpbmUubG9jYXRpb24uZ2V0KCkpO1xuICAgIGVuZ2luZS5hbmltYXRpb24uaW5pdCgpO1xuICAgIGVuZ2luZS5zbGlkZXNJblZpZXcuaW5pdCgpO1xuICAgIGVuZ2luZS5zbGlkZUZvY3VzLmluaXQoKTtcbiAgICBlbmdpbmUuZXZlbnRIYW5kbGVyLmluaXQoc2VsZik7XG4gICAgZW5naW5lLnJlc2l6ZUhhbmRsZXIuaW5pdChzZWxmKTtcbiAgICBlbmdpbmUuc2xpZGVzSGFuZGxlci5pbml0KHNlbGYpO1xuICAgIGlmIChlbmdpbmUub3B0aW9ucy5sb29wKSBlbmdpbmUuc2xpZGVMb29wZXIubG9vcCgpO1xuICAgIGlmIChjb250YWluZXIub2Zmc2V0UGFyZW50ICYmIHNsaWRlcy5sZW5ndGgpIGVuZ2luZS5kcmFnSGFuZGxlci5pbml0KHNlbGYpO1xuICAgIHBsdWdpbkFwaXMgPSBwbHVnaW5zSGFuZGxlci5pbml0KHNlbGYsIHBsdWdpbkxpc3QpO1xuICB9XG4gIGZ1bmN0aW9uIHJlQWN0aXZhdGUod2l0aE9wdGlvbnMsIHdpdGhQbHVnaW5zKSB7XG4gICAgY29uc3Qgc3RhcnRJbmRleCA9IHNlbGVjdGVkU2Nyb2xsU25hcCgpO1xuICAgIGRlQWN0aXZhdGUoKTtcbiAgICBhY3RpdmF0ZShtZXJnZU9wdGlvbnMoe1xuICAgICAgc3RhcnRJbmRleFxuICAgIH0sIHdpdGhPcHRpb25zKSwgd2l0aFBsdWdpbnMpO1xuICAgIGV2ZW50SGFuZGxlci5lbWl0KCdyZUluaXQnKTtcbiAgfVxuICBmdW5jdGlvbiBkZUFjdGl2YXRlKCkge1xuICAgIGVuZ2luZS5kcmFnSGFuZGxlci5kZXN0cm95KCk7XG4gICAgZW5naW5lLmV2ZW50U3RvcmUuY2xlYXIoKTtcbiAgICBlbmdpbmUudHJhbnNsYXRlLmNsZWFyKCk7XG4gICAgZW5naW5lLnNsaWRlTG9vcGVyLmNsZWFyKCk7XG4gICAgZW5naW5lLnJlc2l6ZUhhbmRsZXIuZGVzdHJveSgpO1xuICAgIGVuZ2luZS5zbGlkZXNIYW5kbGVyLmRlc3Ryb3koKTtcbiAgICBlbmdpbmUuc2xpZGVzSW5WaWV3LmRlc3Ryb3koKTtcbiAgICBlbmdpbmUuYW5pbWF0aW9uLmRlc3Ryb3koKTtcbiAgICBwbHVnaW5zSGFuZGxlci5kZXN0cm95KCk7XG4gICAgbWVkaWFIYW5kbGVycy5jbGVhcigpO1xuICB9XG4gIGZ1bmN0aW9uIGRlc3Ryb3koKSB7XG4gICAgaWYgKGRlc3Ryb3llZCkgcmV0dXJuO1xuICAgIGRlc3Ryb3llZCA9IHRydWU7XG4gICAgbWVkaWFIYW5kbGVycy5jbGVhcigpO1xuICAgIGRlQWN0aXZhdGUoKTtcbiAgICBldmVudEhhbmRsZXIuZW1pdCgnZGVzdHJveScpO1xuICB9XG4gIGZ1bmN0aW9uIHNjcm9sbFRvKGluZGV4LCBqdW1wLCBkaXJlY3Rpb24pIHtcbiAgICBpZiAoIW9wdGlvbnMuYWN0aXZlIHx8IGRlc3Ryb3llZCkgcmV0dXJuO1xuICAgIGVuZ2luZS5zY3JvbGxCb2R5LnVzZUJhc2VGcmljdGlvbigpLnVzZUR1cmF0aW9uKGp1bXAgPT09IHRydWUgPyAwIDogb3B0aW9ucy5kdXJhdGlvbik7XG4gICAgZW5naW5lLnNjcm9sbFRvLmluZGV4KGluZGV4LCBkaXJlY3Rpb24gfHwgMCk7XG4gIH1cbiAgZnVuY3Rpb24gc2Nyb2xsTmV4dChqdW1wKSB7XG4gICAgY29uc3QgbmV4dCA9IGVuZ2luZS5pbmRleC5hZGQoMSkuZ2V0KCk7XG4gICAgc2Nyb2xsVG8obmV4dCwganVtcCwgLTEpO1xuICB9XG4gIGZ1bmN0aW9uIHNjcm9sbFByZXYoanVtcCkge1xuICAgIGNvbnN0IHByZXYgPSBlbmdpbmUuaW5kZXguYWRkKC0xKS5nZXQoKTtcbiAgICBzY3JvbGxUbyhwcmV2LCBqdW1wLCAxKTtcbiAgfVxuICBmdW5jdGlvbiBjYW5TY3JvbGxOZXh0KCkge1xuICAgIGNvbnN0IG5leHQgPSBlbmdpbmUuaW5kZXguYWRkKDEpLmdldCgpO1xuICAgIHJldHVybiBuZXh0ICE9PSBzZWxlY3RlZFNjcm9sbFNuYXAoKTtcbiAgfVxuICBmdW5jdGlvbiBjYW5TY3JvbGxQcmV2KCkge1xuICAgIGNvbnN0IHByZXYgPSBlbmdpbmUuaW5kZXguYWRkKC0xKS5nZXQoKTtcbiAgICByZXR1cm4gcHJldiAhPT0gc2VsZWN0ZWRTY3JvbGxTbmFwKCk7XG4gIH1cbiAgZnVuY3Rpb24gc2Nyb2xsU25hcExpc3QoKSB7XG4gICAgcmV0dXJuIGVuZ2luZS5zY3JvbGxTbmFwTGlzdDtcbiAgfVxuICBmdW5jdGlvbiBzY3JvbGxQcm9ncmVzcygpIHtcbiAgICByZXR1cm4gZW5naW5lLnNjcm9sbFByb2dyZXNzLmdldChlbmdpbmUubG9jYXRpb24uZ2V0KCkpO1xuICB9XG4gIGZ1bmN0aW9uIHNlbGVjdGVkU2Nyb2xsU25hcCgpIHtcbiAgICByZXR1cm4gZW5naW5lLmluZGV4LmdldCgpO1xuICB9XG4gIGZ1bmN0aW9uIHByZXZpb3VzU2Nyb2xsU25hcCgpIHtcbiAgICByZXR1cm4gZW5naW5lLmluZGV4UHJldmlvdXMuZ2V0KCk7XG4gIH1cbiAgZnVuY3Rpb24gc2xpZGVzSW5WaWV3KCkge1xuICAgIHJldHVybiBlbmdpbmUuc2xpZGVzSW5WaWV3LmdldCgpO1xuICB9XG4gIGZ1bmN0aW9uIHNsaWRlc05vdEluVmlldygpIHtcbiAgICByZXR1cm4gZW5naW5lLnNsaWRlc0luVmlldy5nZXQoZmFsc2UpO1xuICB9XG4gIGZ1bmN0aW9uIHBsdWdpbnMoKSB7XG4gICAgcmV0dXJuIHBsdWdpbkFwaXM7XG4gIH1cbiAgZnVuY3Rpb24gaW50ZXJuYWxFbmdpbmUoKSB7XG4gICAgcmV0dXJuIGVuZ2luZTtcbiAgfVxuICBmdW5jdGlvbiByb290Tm9kZSgpIHtcbiAgICByZXR1cm4gcm9vdDtcbiAgfVxuICBmdW5jdGlvbiBjb250YWluZXJOb2RlKCkge1xuICAgIHJldHVybiBjb250YWluZXI7XG4gIH1cbiAgZnVuY3Rpb24gc2xpZGVOb2RlcygpIHtcbiAgICByZXR1cm4gc2xpZGVzO1xuICB9XG4gIGNvbnN0IHNlbGYgPSB7XG4gICAgY2FuU2Nyb2xsTmV4dCxcbiAgICBjYW5TY3JvbGxQcmV2LFxuICAgIGNvbnRhaW5lck5vZGUsXG4gICAgaW50ZXJuYWxFbmdpbmUsXG4gICAgZGVzdHJveSxcbiAgICBvZmYsXG4gICAgb24sXG4gICAgZW1pdCxcbiAgICBwbHVnaW5zLFxuICAgIHByZXZpb3VzU2Nyb2xsU25hcCxcbiAgICByZUluaXQsXG4gICAgcm9vdE5vZGUsXG4gICAgc2Nyb2xsTmV4dCxcbiAgICBzY3JvbGxQcmV2LFxuICAgIHNjcm9sbFByb2dyZXNzLFxuICAgIHNjcm9sbFNuYXBMaXN0LFxuICAgIHNjcm9sbFRvLFxuICAgIHNlbGVjdGVkU2Nyb2xsU25hcCxcbiAgICBzbGlkZU5vZGVzLFxuICAgIHNsaWRlc0luVmlldyxcbiAgICBzbGlkZXNOb3RJblZpZXdcbiAgfTtcbiAgYWN0aXZhdGUodXNlck9wdGlvbnMsIHVzZXJQbHVnaW5zKTtcbiAgc2V0VGltZW91dCgoKSA9PiBldmVudEhhbmRsZXIuZW1pdCgnaW5pdCcpLCAwKTtcbiAgcmV0dXJuIHNlbGY7XG59XG5FbWJsYUNhcm91c2VsLmdsb2JhbE9wdGlvbnMgPSB1bmRlZmluZWQ7XG5cbmV4cG9ydCB7IEVtYmxhQ2Fyb3VzZWwgYXMgZGVmYXVsdCB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZW1ibGEtY2Fyb3VzZWwuZXNtLmpzLm1hcFxuIl0sIm5hbWVzIjpbImlzTnVtYmVyIiwic3ViamVjdCIsImlzU3RyaW5nIiwiaXNCb29sZWFuIiwiaXNPYmplY3QiLCJPYmplY3QiLCJwcm90b3R5cGUiLCJ0b1N0cmluZyIsImNhbGwiLCJtYXRoQWJzIiwibiIsIk1hdGgiLCJhYnMiLCJtYXRoU2lnbiIsInNpZ24iLCJkZWx0YUFicyIsInZhbHVlQiIsInZhbHVlQSIsImZhY3RvckFicyIsImRpZmYiLCJhcnJheUtleXMiLCJhcnJheSIsIm9iamVjdEtleXMiLCJtYXAiLCJOdW1iZXIiLCJhcnJheUxhc3QiLCJhcnJheUxhc3RJbmRleCIsIm1heCIsImxlbmd0aCIsImFycmF5SXNMYXN0SW5kZXgiLCJpbmRleCIsImFycmF5RnJvbU51bWJlciIsInN0YXJ0QXQiLCJBcnJheSIsImZyb20iLCJfIiwiaSIsIm9iamVjdCIsImtleXMiLCJvYmplY3RzTWVyZ2VEZWVwIiwib2JqZWN0QSIsIm9iamVjdEIiLCJyZWR1Y2UiLCJtZXJnZWRPYmplY3RzIiwiY3VycmVudE9iamVjdCIsImZvckVhY2giLCJrZXkiLCJhcmVPYmplY3RzIiwiaXNNb3VzZUV2ZW50IiwiZXZ0Iiwib3duZXJXaW5kb3ciLCJNb3VzZUV2ZW50IiwiQWxpZ25tZW50IiwiYWxpZ24iLCJ2aWV3U2l6ZSIsInByZWRlZmluZWQiLCJzdGFydCIsImNlbnRlciIsImVuZCIsIm1lYXN1cmUiLCJzZWxmIiwiRXZlbnRTdG9yZSIsImxpc3RlbmVycyIsImFkZCIsIm5vZGUiLCJ0eXBlIiwiaGFuZGxlciIsIm9wdGlvbnMiLCJwYXNzaXZlIiwicmVtb3ZlTGlzdGVuZXIiLCJhZGRFdmVudExpc3RlbmVyIiwicmVtb3ZlRXZlbnRMaXN0ZW5lciIsImxlZ2FjeU1lZGlhUXVlcnlMaXN0IiwiYWRkTGlzdGVuZXIiLCJwdXNoIiwiY2xlYXIiLCJmaWx0ZXIiLCJyZW1vdmUiLCJBbmltYXRpb25zIiwib3duZXJEb2N1bWVudCIsInVwZGF0ZSIsInJlbmRlciIsImRvY3VtZW50VmlzaWJsZUhhbmRsZXIiLCJ0aW1lU3RlcCIsImxhc3RUaW1lU3RhbXAiLCJsYWciLCJhbmltYXRpb25GcmFtZSIsImluaXQiLCJoaWRkZW4iLCJyZXNldCIsImRlc3Ryb3kiLCJzdG9wIiwiYW5pbWF0ZSIsInRpbWVTdGFtcCIsImVsYXBzZWQiLCJsYWdPZmZzZXQiLCJyZXF1ZXN0QW5pbWF0aW9uRnJhbWUiLCJjYW5jZWxBbmltYXRpb25GcmFtZSIsIkF4aXMiLCJheGlzIiwiZGlyZWN0aW9uIiwic2Nyb2xsIiwiY3Jvc3MiLCJzdGFydEVkZ2UiLCJnZXRTdGFydEVkZ2UiLCJlbmRFZGdlIiwiZ2V0RW5kRWRnZSIsIm1lYXN1cmVTaXplIiwibm9kZVJlY3QiLCJ3aWR0aCIsImhlaWdodCIsIkxpbWl0IiwibWluIiwicmVhY2hlZE1pbiIsInJlYWNoZWRNYXgiLCJyZWFjaGVkQW55IiwiY29uc3RyYWluIiwicmVtb3ZlT2Zmc2V0IiwiY2VpbCIsIkNvdW50ZXIiLCJsb29wIiwibG9vcEVuZCIsImNvdW50ZXIiLCJ3aXRoaW5MaW1pdCIsImdldCIsInNldCIsImNsb25lIiwiRGlyZWN0aW9uIiwiYXBwbHkiLCJEcmFnSGFuZGxlciIsInJvb3ROb2RlIiwidGFyZ2V0IiwiZHJhZ1RyYWNrZXIiLCJsb2NhdGlvbiIsImFuaW1hdGlvbiIsInNjcm9sbFRvIiwic2Nyb2xsQm9keSIsInNjcm9sbFRhcmdldCIsImV2ZW50SGFuZGxlciIsInBlcmNlbnRPZlZpZXciLCJkcmFnRnJlZSIsImRyYWdUaHJlc2hvbGQiLCJza2lwU25hcHMiLCJiYXNlRnJpY3Rpb24iLCJ3YXRjaERyYWciLCJjcm9zc0F4aXMiLCJmb2N1c05vZGVzIiwibm9uUGFzc2l2ZUV2ZW50IiwiaW5pdEV2ZW50cyIsImRyYWdFdmVudHMiLCJnb1RvTmV4dFRocmVzaG9sZCIsInNuYXBGb3JjZUJvb3N0IiwibW91c2UiLCJ0b3VjaCIsImZyZWVGb3JjZUJvb3N0IiwiYmFzZVNwZWVkIiwiaXNNb3ZpbmciLCJzdGFydFNjcm9sbCIsInN0YXJ0Q3Jvc3MiLCJwb2ludGVySXNEb3duIiwicHJldmVudFNjcm9sbCIsInByZXZlbnRDbGljayIsImlzTW91c2UiLCJlbWJsYUFwaSIsImRvd25JZkFsbG93ZWQiLCJkb3duIiwicHJldmVudERlZmF1bHQiLCJ1bmRlZmluZWQiLCJ1cCIsImNsaWNrIiwiYWRkRHJhZ0V2ZW50cyIsIm1vdmUiLCJpc0ZvY3VzTm9kZSIsIm5vZGVOYW1lIiwiaW5jbHVkZXMiLCJmb3JjZUJvb3N0IiwiYm9vc3QiLCJhbGxvd2VkRm9yY2UiLCJmb3JjZSIsInRhcmdldENoYW5nZWQiLCJuZXh0IiwiYmFzZUZvcmNlIiwiYnlEaXN0YW5jZSIsImRpc3RhbmNlIiwiYnlJbmRleCIsImlzTW91c2VFdnQiLCJidXR0b24iLCJidXR0b25zIiwicG9pbnRlckRvd24iLCJ1c2VGcmljdGlvbiIsInVzZUR1cmF0aW9uIiwicmVhZFBvaW50IiwiZW1pdCIsImxhc3RTY3JvbGwiLCJsYXN0Q3Jvc3MiLCJkaWZmU2Nyb2xsIiwiZGlmZkNyb3NzIiwiY2FuY2VsYWJsZSIsInBvaW50ZXJNb3ZlIiwiY3VycmVudExvY2F0aW9uIiwicmF3Rm9yY2UiLCJwb2ludGVyVXAiLCJmb3JjZUZhY3RvciIsInNwZWVkIiwiZnJpY3Rpb24iLCJzdG9wUHJvcGFnYXRpb24iLCJEcmFnVHJhY2tlciIsImxvZ0ludGVydmFsIiwic3RhcnRFdmVudCIsImxhc3RFdmVudCIsInJlYWRUaW1lIiwiZXZ0QXhpcyIsInByb3BlcnR5IiwiY29vcmQiLCJ0b3VjaGVzIiwiZXhwaXJlZCIsImRpZmZEcmFnIiwiZGlmZlRpbWUiLCJpc0ZsaWNrIiwiTm9kZVJlY3RzIiwib2Zmc2V0VG9wIiwib2Zmc2V0TGVmdCIsIm9mZnNldFdpZHRoIiwib2Zmc2V0SGVpZ2h0Iiwib2Zmc2V0IiwidG9wIiwicmlnaHQiLCJib3R0b20iLCJsZWZ0IiwiUGVyY2VudE9mVmlldyIsIlJlc2l6ZUhhbmRsZXIiLCJjb250YWluZXIiLCJzbGlkZXMiLCJ3YXRjaFJlc2l6ZSIsIm5vZGVSZWN0cyIsInJlc2l6ZU9ic2VydmVyIiwiY29udGFpbmVyU2l6ZSIsInNsaWRlU2l6ZXMiLCJkZXN0cm95ZWQiLCJyZWFkU2l6ZSIsImRlZmF1bHRDYWxsYmFjayIsImVudHJpZXMiLCJlbnRyeSIsImlzQ29udGFpbmVyIiwic2xpZGVJbmRleCIsImluZGV4T2YiLCJsYXN0U2l6ZSIsIm5ld1NpemUiLCJkaWZmU2l6ZSIsInJlSW5pdCIsIlJlc2l6ZU9ic2VydmVyIiwib2JzZXJ2ZU5vZGVzIiwiY29uY2F0Iiwib2JzZXJ2ZSIsImRpc2Nvbm5lY3QiLCJTY3JvbGxCb2R5Iiwib2Zmc2V0TG9jYXRpb24iLCJiYXNlRHVyYXRpb24iLCJib2R5VmVsb2NpdHkiLCJzY3JvbGxEaXJlY3Rpb24iLCJzY3JvbGxEdXJhdGlvbiIsInNjcm9sbEZyaWN0aW9uIiwicmF3TG9jYXRpb24iLCJyYXdMb2NhdGlvblByZXZpb3VzIiwic2VlayIsImlzSW5zdGFudCIsImRpcmVjdGlvbkRpZmYiLCJzZXR0bGVkIiwiZHVyYXRpb24iLCJ2ZWxvY2l0eSIsInVzZUJhc2VEdXJhdGlvbiIsInVzZUJhc2VGcmljdGlvbiIsIlNjcm9sbEJvdW5kcyIsImxpbWl0IiwicHVsbEJhY2tUaHJlc2hvbGQiLCJlZGdlT2Zmc2V0VG9sZXJhbmNlIiwiZnJpY3Rpb25MaW1pdCIsImRpc2FibGVkIiwic2hvdWxkQ29uc3RyYWluIiwiZWRnZSIsImRpZmZUb0VkZ2UiLCJkaWZmVG9UYXJnZXQiLCJzdWJ0cmFjdCIsInRvZ2dsZUFjdGl2ZSIsImFjdGl2ZSIsIlNjcm9sbENvbnRhaW4iLCJjb250ZW50U2l6ZSIsInNuYXBzQWxpZ25lZCIsImNvbnRhaW5TY3JvbGwiLCJwaXhlbFRvbGVyYW5jZSIsInNjcm9sbEJvdW5kcyIsInNuYXBzQm91bmRlZCIsIm1lYXN1cmVCb3VuZGVkIiwic2Nyb2xsQ29udGFpbkxpbWl0IiwiZmluZFNjcm9sbENvbnRhaW5MaW1pdCIsInNuYXBzQ29udGFpbmVkIiwibWVhc3VyZUNvbnRhaW5lZCIsInVzZVBpeGVsVG9sZXJhbmNlIiwiYm91bmQiLCJzbmFwIiwic3RhcnRTbmFwIiwiZW5kU25hcCIsImxhc3RJbmRleE9mIiwic25hcEFsaWduZWQiLCJpc0ZpcnN0IiwiaXNMYXN0Iiwic2Nyb2xsQm91bmQiLCJwYXJzZUZsb2F0IiwidG9GaXhlZCIsInNsaWNlIiwiU2Nyb2xsTGltaXQiLCJzY3JvbGxTbmFwcyIsIlNjcm9sbExvb3BlciIsInZlY3RvcnMiLCJqb2ludFNhZmV0eSIsInNob3VsZExvb3AiLCJsb29wRGlzdGFuY2UiLCJ2IiwiU2Nyb2xsUHJvZ3Jlc3MiLCJTY3JvbGxTbmFwcyIsImFsaWdubWVudCIsImNvbnRhaW5lclJlY3QiLCJzbGlkZVJlY3RzIiwic2xpZGVzVG9TY3JvbGwiLCJncm91cFNsaWRlcyIsImFsaWdubWVudHMiLCJtZWFzdXJlU2l6ZXMiLCJzbmFwcyIsIm1lYXN1cmVVbmFsaWduZWQiLCJtZWFzdXJlQWxpZ25lZCIsInJlY3RzIiwicmVjdCIsImciLCJTbGlkZVJlZ2lzdHJ5IiwiY29udGFpblNuYXBzIiwic2xpZGVJbmRleGVzIiwic2xpZGVSZWdpc3RyeSIsImNyZWF0ZVNsaWRlUmVnaXN0cnkiLCJncm91cGVkU2xpZGVJbmRleGVzIiwiZG9Ob3RDb250YWluIiwiZ3JvdXAiLCJncm91cHMiLCJyYW5nZSIsIlNjcm9sbFRhcmdldCIsInRhcmdldFZlY3RvciIsIm1pbkRpc3RhbmNlIiwiZGlzdGFuY2VzIiwic29ydCIsImEiLCJiIiwiZmluZFRhcmdldFNuYXAiLCJhc2NEaWZmc1RvU25hcHMiLCJzY3JvbGxTbmFwIiwiZGlmZlRvU25hcCIsInNob3J0Y3V0IiwiZDEiLCJkMiIsInRhcmdldHMiLCJtYXRjaGluZ1RhcmdldHMiLCJ0IiwidGFyZ2V0U25hcERpc3RhbmNlIiwicmVhY2hlZEJvdW5kIiwic25hcERpc3RhbmNlIiwiU2Nyb2xsVG8iLCJpbmRleEN1cnJlbnQiLCJpbmRleFByZXZpb3VzIiwiZGlzdGFuY2VEaWZmIiwiaW5kZXhEaWZmIiwidGFyZ2V0SW5kZXgiLCJTbGlkZUZvY3VzIiwicm9vdCIsImV2ZW50U3RvcmUiLCJsYXN0VGFiUHJlc3NUaW1lIiwiZG9jdW1lbnQiLCJyZWdpc3RlclRhYlByZXNzIiwiYWRkU2xpZGVGb2N1c0V2ZW50IiwiZXZlbnQiLCJjb2RlIiwiRGF0ZSIsImdldFRpbWUiLCJzbGlkZSIsImZvY3VzIiwibm93VGltZSIsInNjcm9sbExlZnQiLCJmaW5kSW5kZXgiLCJjYXB0dXJlIiwiVmVjdG9yMUQiLCJpbml0aWFsVmFsdWUiLCJ2YWx1ZSIsIm5vcm1hbGl6ZUlucHV0IiwiVHJhbnNsYXRlIiwidHJhbnNsYXRlIiwieCIsInkiLCJjb250YWluZXJTdHlsZSIsInN0eWxlIiwidG8iLCJ0cmFuc2Zvcm0iLCJnZXRBdHRyaWJ1dGUiLCJyZW1vdmVBdHRyaWJ1dGUiLCJTbGlkZUxvb3BlciIsInNsaWRlU2l6ZXNXaXRoR2FwcyIsInJvdW5kaW5nU2FmZXR5IiwiYXNjSXRlbXMiLCJkZXNjSXRlbXMiLCJyZXZlcnNlIiwibG9vcFBvaW50cyIsInN0YXJ0UG9pbnRzIiwiZW5kUG9pbnRzIiwicmVtb3ZlU2xpZGVTaXplcyIsImluZGV4ZXMiLCJzbGlkZXNJbkdhcCIsImdhcCIsInJlbWFpbmluZ0dhcCIsImZpbmRTbGlkZUJvdW5kcyIsImZpbmRMb29wUG9pbnRzIiwiaXNFbmRFZGdlIiwic2xpZGVCb3VuZHMiLCJpbml0aWFsIiwiYWx0ZXJlZCIsImJvdW5kRWRnZSIsImxvb3BQb2ludCIsInNsaWRlTG9jYXRpb24iLCJjYW5Mb29wIiwiZXZlcnkiLCJvdGhlckluZGV4ZXMiLCJzaGlmdExvY2F0aW9uIiwiU2xpZGVzSGFuZGxlciIsIndhdGNoU2xpZGVzIiwibXV0YXRpb25PYnNlcnZlciIsIm11dGF0aW9ucyIsIm11dGF0aW9uIiwiTXV0YXRpb25PYnNlcnZlciIsImNoaWxkTGlzdCIsIlNsaWRlc0luVmlldyIsInRocmVzaG9sZCIsImludGVyc2VjdGlvbkVudHJ5TWFwIiwiaW5WaWV3Q2FjaGUiLCJub3RJblZpZXdDYWNoZSIsImludGVyc2VjdGlvbk9ic2VydmVyIiwiSW50ZXJzZWN0aW9uT2JzZXJ2ZXIiLCJwYXJlbnRFbGVtZW50IiwiY3JlYXRlSW5WaWV3TGlzdCIsImluVmlldyIsImxpc3QiLCJwYXJzZUludCIsImlzSW50ZXJzZWN0aW5nIiwiaW5WaWV3TWF0Y2giLCJub3RJblZpZXdNYXRjaCIsIlNsaWRlU2l6ZXMiLCJyZWFkRWRnZUdhcCIsIndpdGhFZGdlR2FwIiwic3RhcnRHYXAiLCJtZWFzdXJlU3RhcnRHYXAiLCJlbmRHYXAiLCJtZWFzdXJlRW5kR2FwIiwibWVhc3VyZVdpdGhHYXBzIiwic2xpZGVSZWN0IiwiZ2V0Q29tcHV0ZWRTdHlsZSIsImdldFByb3BlcnR5VmFsdWUiLCJTbGlkZXNUb1Njcm9sbCIsImdyb3VwQnlOdW1iZXIiLCJieU51bWJlciIsImdyb3VwU2l6ZSIsImJ5U2l6ZSIsInJlY3RCIiwicmVjdEEiLCJlZGdlQSIsImVkZ2VCIiwiZ2FwQSIsImdhcEIiLCJjaHVua1NpemUiLCJjdXJyZW50U2l6ZSIsInByZXZpb3VzU2l6ZSIsIkVuZ2luZSIsInNjcm9sbEF4aXMiLCJjb250ZW50RGlyZWN0aW9uIiwic3RhcnRJbmRleCIsImluVmlld1RocmVzaG9sZCIsImRyYWdIYW5kbGVyIiwic2Nyb2xsTG9vcGVyIiwic2xpZGVMb29wZXIiLCJoYXNTZXR0bGVkIiwiZW5naW5lIiwic3RhcnRMb2NhdGlvbiIsInNjcm9sbFByb2dyZXNzIiwic2xpZGVzSW5WaWV3Iiwic2xpZGVGb2N1cyIsInJlc2l6ZUhhbmRsZXIiLCJzY3JvbGxTbmFwTGlzdCIsInNsaWRlc0hhbmRsZXIiLCJFdmVudEhhbmRsZXIiLCJhcGkiLCJnZXRMaXN0ZW5lcnMiLCJlIiwib24iLCJjYiIsIm9mZiIsImRlZmF1bHRPcHRpb25zIiwiYnJlYWtwb2ludHMiLCJPcHRpb25zSGFuZGxlciIsIm1lcmdlT3B0aW9ucyIsIm9wdGlvbnNBIiwib3B0aW9uc0IiLCJvcHRpb25zQXRNZWRpYSIsIm1hdGNoZWRNZWRpYU9wdGlvbnMiLCJtZWRpYSIsIm1hdGNoTWVkaWEiLCJtYXRjaGVzIiwibWVkaWFPcHRpb24iLCJvcHRpb25zTWVkaWFRdWVyaWVzIiwib3B0aW9uc0xpc3QiLCJhY2MiLCJtZWRpYVF1ZXJpZXMiLCJQbHVnaW5zSGFuZGxlciIsIm9wdGlvbnNIYW5kbGVyIiwiYWN0aXZlUGx1Z2lucyIsInBsdWdpbnMiLCJwbHVnaW4iLCJhc3NpZ24iLCJuYW1lIiwiRW1ibGFDYXJvdXNlbCIsInVzZXJPcHRpb25zIiwidXNlclBsdWdpbnMiLCJkZWZhdWx0VmlldyIsInBsdWdpbnNIYW5kbGVyIiwibWVkaWFIYW5kbGVycyIsInJlQWN0aXZhdGUiLCJvcHRpb25zQmFzZSIsImdsb2JhbE9wdGlvbnMiLCJwbHVnaW5MaXN0IiwicGx1Z2luQXBpcyIsInN0b3JlRWxlbWVudHMiLCJ1c2VyQ29udGFpbmVyIiwidXNlclNsaWRlcyIsImN1c3RvbUNvbnRhaW5lciIsInF1ZXJ5U2VsZWN0b3IiLCJjaGlsZHJlbiIsImN1c3RvbVNsaWRlcyIsInF1ZXJ5U2VsZWN0b3JBbGwiLCJjcmVhdGVFbmdpbmUiLCJvcHRpb25zV2l0aG91dExvb3AiLCJhY3RpdmF0ZSIsIndpdGhPcHRpb25zIiwid2l0aFBsdWdpbnMiLCJxdWVyeSIsIm9mZnNldFBhcmVudCIsInNlbGVjdGVkU2Nyb2xsU25hcCIsImRlQWN0aXZhdGUiLCJqdW1wIiwic2Nyb2xsTmV4dCIsInNjcm9sbFByZXYiLCJwcmV2IiwiY2FuU2Nyb2xsTmV4dCIsImNhblNjcm9sbFByZXYiLCJwcmV2aW91c1Njcm9sbFNuYXAiLCJzbGlkZXNOb3RJblZpZXciLCJpbnRlcm5hbEVuZ2luZSIsImNvbnRhaW5lck5vZGUiLCJzbGlkZU5vZGVzIiwic2V0VGltZW91dCIsImRlZmF1bHQiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/embla-carousel/esm/embla-carousel.esm.js\n"));

/***/ })

});