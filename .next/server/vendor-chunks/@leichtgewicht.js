"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/@leichtgewicht";
exports.ids = ["vendor-chunks/@leichtgewicht"];
exports.modules = {

/***/ "(ssr)/./node_modules/@leichtgewicht/ip-codec/index.cjs":
/*!********************************************************!*\
  !*** ./node_modules/@leichtgewicht/ip-codec/index.cjs ***!
  \********************************************************/
/***/ ((module, exports) => {

eval("var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;// GENERATED FILE. DO NOT EDIT.\n\nvar ipCodec = function(exports1) {\n    \"use strict\";\n    Object.defineProperty(exports1, \"__esModule\", {\n        value: true\n    });\n    exports1.decode = decode;\n    exports1.encode = encode;\n    exports1.familyOf = familyOf;\n    exports1.name = void 0;\n    exports1.sizeOf = sizeOf;\n    exports1.v6 = exports1.v4 = void 0;\n    const v4Regex = /^(\\d{1,3}\\.){3,3}\\d{1,3}$/;\n    const v4Size = 4;\n    const v6Regex = /^(::)?(((\\d{1,3}\\.){3}(\\d{1,3}){1})?([0-9a-f]){0,4}:{0,2}){1,8}(::)?$/i;\n    const v6Size = 16;\n    const v4 = {\n        name: \"v4\",\n        size: v4Size,\n        isFormat: (ip)=>v4Regex.test(ip),\n        encode (ip, buff, offset) {\n            offset = ~~offset;\n            buff = buff || new Uint8Array(offset + v4Size);\n            const max = ip.length;\n            let n = 0;\n            for(let i = 0; i < max;){\n                const c = ip.charCodeAt(i++);\n                if (c === 46) {\n                    // \".\"\n                    buff[offset++] = n;\n                    n = 0;\n                } else {\n                    n = n * 10 + (c - 48);\n                }\n            }\n            buff[offset] = n;\n            return buff;\n        },\n        decode (buff, offset) {\n            offset = ~~offset;\n            return `${buff[offset++]}.${buff[offset++]}.${buff[offset++]}.${buff[offset]}`;\n        }\n    };\n    exports1.v4 = v4;\n    const v6 = {\n        name: \"v6\",\n        size: v6Size,\n        isFormat: (ip)=>ip.length > 0 && v6Regex.test(ip),\n        encode (ip, buff, offset) {\n            offset = ~~offset;\n            let end = offset + v6Size;\n            let fill = -1;\n            let hexN = 0;\n            let decN = 0;\n            let prevColon = true;\n            let useDec = false;\n            buff = buff || new Uint8Array(offset + v6Size); // Note: This algorithm needs to check if the offset\n            // could exceed the buffer boundaries as it supports\n            // non-standard compliant encodings that may go beyond\n            // the boundary limits. if (offset < end) checks should\n            // not be necessary...\n            for(let i = 0; i < ip.length; i++){\n                let c = ip.charCodeAt(i);\n                if (c === 58) {\n                    // :\n                    if (prevColon) {\n                        if (fill !== -1) {\n                            // Not Standard! (standard doesn't allow multiple ::)\n                            // We need to treat\n                            if (offset < end) buff[offset] = 0;\n                            if (offset < end - 1) buff[offset + 1] = 0;\n                            offset += 2;\n                        } else if (offset < end) {\n                            // :: in the middle\n                            fill = offset;\n                        }\n                    } else {\n                        // : ends the previous number\n                        if (useDec === true) {\n                            // Non-standard! (ipv4 should be at end only)\n                            // A ipv4 address should not be found anywhere else but at\n                            // the end. This codec also support putting characters\n                            // after the ipv4 address..\n                            if (offset < end) buff[offset] = decN;\n                            offset++;\n                        } else {\n                            if (offset < end) buff[offset] = hexN >> 8;\n                            if (offset < end - 1) buff[offset + 1] = hexN & 0xff;\n                            offset += 2;\n                        }\n                        hexN = 0;\n                        decN = 0;\n                    }\n                    prevColon = true;\n                    useDec = false;\n                } else if (c === 46) {\n                    // . indicates IPV4 notation\n                    if (offset < end) buff[offset] = decN;\n                    offset++;\n                    decN = 0;\n                    hexN = 0;\n                    prevColon = false;\n                    useDec = true;\n                } else {\n                    prevColon = false;\n                    if (c >= 97) {\n                        c -= 87; // a-f ... 97~102 -87 => 10~15\n                    } else if (c >= 65) {\n                        c -= 55; // A-F ... 65~70 -55 => 10~15\n                    } else {\n                        c -= 48; // 0-9 ... starting from charCode 48\n                        decN = decN * 10 + c;\n                    } // We don't know yet if its a dec or hex number\n                    hexN = (hexN << 4) + c;\n                }\n            }\n            if (prevColon === false) {\n                // Commiting last number\n                if (useDec === true) {\n                    if (offset < end) buff[offset] = decN;\n                    offset++;\n                } else {\n                    if (offset < end) buff[offset] = hexN >> 8;\n                    if (offset < end - 1) buff[offset + 1] = hexN & 0xff;\n                    offset += 2;\n                }\n            } else if (fill === 0) {\n                // Not Standard! (standard doesn't allow multiple ::)\n                // This means that a : was found at the start AND end which means the\n                // end needs to be treated as 0 entry...\n                if (offset < end) buff[offset] = 0;\n                if (offset < end - 1) buff[offset + 1] = 0;\n                offset += 2;\n            } else if (fill !== -1) {\n                // Non-standard! (standard doens't allow multiple ::)\n                // Here we find that there has been a :: somewhere in the middle\n                // and the end. To treat the end with priority we need to move all\n                // written data two bytes to the right.\n                offset += 2;\n                for(let i = Math.min(offset - 1, end - 1); i >= fill + 2; i--){\n                    buff[i] = buff[i - 2];\n                }\n                buff[fill] = 0;\n                buff[fill + 1] = 0;\n                fill = offset;\n            }\n            if (fill !== offset && fill !== -1) {\n                // Move the written numbers to the end while filling the everything\n                // \"fill\" to the bytes with zeros.\n                if (offset > end - 2) {\n                    // Non Standard support, when the cursor exceeds bounds.\n                    offset = end - 2;\n                }\n                while(end > fill){\n                    buff[--end] = offset < end && offset > fill ? buff[--offset] : 0;\n                }\n            } else {\n                // Fill the rest with zeros\n                while(offset < end){\n                    buff[offset++] = 0;\n                }\n            }\n            return buff;\n        },\n        decode (buff, offset) {\n            offset = ~~offset;\n            let result = \"\";\n            for(let i = 0; i < v6Size; i += 2){\n                if (i !== 0) {\n                    result += \":\";\n                }\n                result += (buff[offset + i] << 8 | buff[offset + i + 1]).toString(16);\n            }\n            return result.replace(/(^|:)0(:0)*:0(:|$)/, \"$1::$3\").replace(/:{3,4}/, \"::\");\n        }\n    };\n    exports1.v6 = v6;\n    const name = \"ip\";\n    exports1.name = name;\n    function sizeOf(ip) {\n        if (v4.isFormat(ip)) return v4.size;\n        if (v6.isFormat(ip)) return v6.size;\n        throw Error(`Invalid ip address: ${ip}`);\n    }\n    function familyOf(string) {\n        return sizeOf(string) === v4.size ? 1 : 2;\n    }\n    function encode(ip, buff, offset) {\n        offset = ~~offset;\n        const size = sizeOf(ip);\n        if (typeof buff === \"function\") {\n            buff = buff(offset + size);\n        }\n        if (size === v4.size) {\n            return v4.encode(ip, buff, offset);\n        }\n        return v6.encode(ip, buff, offset);\n    }\n    function decode(buff, offset, length) {\n        offset = ~~offset;\n        length = length || buff.length - offset;\n        if (length === v4.size) {\n            return v4.decode(buff, offset, length);\n        }\n        if (length === v6.size) {\n            return v6.decode(buff, offset, length);\n        }\n        throw Error(`Invalid buffer size needs to be ${v4.size} for v4 or ${v6.size} for v6.`);\n    }\n    return \"default\" in exports1 ? exports1.default : exports1;\n}({});\nif (true) !(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_RESULT__ = (function() {\n    return ipCodec;\n}).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),\n\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\nelse {}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGxlaWNodGdld2ljaHQvaXAtY29kZWMvaW5kZXguY2pzIiwibWFwcGluZ3MiOiJBQUFBLCtGQUErQjs7QUFDL0IsSUFBSUEsVUFBVSxTQUFVQyxRQUFPO0lBQzdCO0lBRUFDLE9BQU9DLGNBQWMsQ0FBQ0YsVUFBUyxjQUFjO1FBQzNDRyxPQUFPO0lBQ1Q7SUFDQUgsU0FBUUksTUFBTSxHQUFHQTtJQUNqQkosU0FBUUssTUFBTSxHQUFHQTtJQUNqQkwsU0FBUU0sUUFBUSxHQUFHQTtJQUNuQk4sU0FBUU8sSUFBSSxHQUFHLEtBQUs7SUFDcEJQLFNBQVFRLE1BQU0sR0FBR0E7SUFDakJSLFNBQVFTLEVBQUUsR0FBR1QsU0FBUVUsRUFBRSxHQUFHLEtBQUs7SUFDL0IsTUFBTUMsVUFBVTtJQUNoQixNQUFNQyxTQUFTO0lBQ2YsTUFBTUMsVUFBVTtJQUNoQixNQUFNQyxTQUFTO0lBQ2YsTUFBTUosS0FBSztRQUNUSCxNQUFNO1FBQ05RLE1BQU1IO1FBQ05JLFVBQVVDLENBQUFBLEtBQU1OLFFBQVFPLElBQUksQ0FBQ0Q7UUFFN0JaLFFBQU9ZLEVBQUUsRUFBRUUsSUFBSSxFQUFFQyxNQUFNO1lBQ3JCQSxTQUFTLENBQUMsQ0FBQ0E7WUFDWEQsT0FBT0EsUUFBUSxJQUFJRSxXQUFXRCxTQUFTUjtZQUN2QyxNQUFNVSxNQUFNTCxHQUFHTSxNQUFNO1lBQ3JCLElBQUlDLElBQUk7WUFFUixJQUFLLElBQUlDLElBQUksR0FBR0EsSUFBSUgsS0FBTTtnQkFDeEIsTUFBTUksSUFBSVQsR0FBR1UsVUFBVSxDQUFDRjtnQkFFeEIsSUFBSUMsTUFBTSxJQUFJO29CQUNaLE1BQU07b0JBQ05QLElBQUksQ0FBQ0MsU0FBUyxHQUFHSTtvQkFDakJBLElBQUk7Z0JBQ04sT0FBTztvQkFDTEEsSUFBSUEsSUFBSSxLQUFNRSxDQUFBQSxJQUFJLEVBQUM7Z0JBQ3JCO1lBQ0Y7WUFFQVAsSUFBSSxDQUFDQyxPQUFPLEdBQUdJO1lBQ2YsT0FBT0w7UUFD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QkEsT0FBT0EsS0FBS0MsU0FBU0w7UUFDdkI7UUFFQSxJQUFJQSxTQUFTTCxHQUFHSyxJQUFJLEVBQUU7WUFDcEIsT0FBT0wsR0FBR0wsTUFBTSxDQUFDWSxJQUFJRSxNQUFNQztRQUM3QjtRQUVBLE9BQU9YLEdBQUdKLE1BQU0sQ0FBQ1ksSUFBSUUsTUFBTUM7SUFDN0I7SUFFQSxTQUFTaEIsT0FBT2UsSUFBSSxFQUFFQyxNQUFNLEVBQUVHLE1BQU07UUFDbENILFNBQVMsQ0FBQyxDQUFDQTtRQUNYRyxTQUFTQSxVQUFVSixLQUFLSSxNQUFNLEdBQUdIO1FBRWpDLElBQUlHLFdBQVdiLEdBQUdLLElBQUksRUFBRTtZQUN0QixPQUFPTCxHQUFHTixNQUFNLENBQUNlLE1BQU1DLFFBQVFHO1FBQ2pDO1FBRUEsSUFBSUEsV0FBV2QsR0FBR00sSUFBSSxFQUFFO1lBQ3RCLE9BQU9OLEdBQUdMLE1BQU0sQ0FBQ2UsTUFBTUMsUUFBUUc7UUFDakM7UUFFQSxNQUFNZ0IsTUFBTSxDQUFDLGdDQUFnQyxFQUFFN0IsR0FBR0ssSUFBSSxDQUFDLFdBQVcsRUFBRU4sR0FBR00sSUFBSSxDQUFDLFFBQVEsQ0FBQztJQUN2RjtJQUNBLE9BQU8sYUFBYWYsV0FBVUEsU0FBUXlDLE9BQU8sR0FBR3pDO0FBQ2xELEVBQUcsQ0FBQztBQUNKLElBQUksSUFBMEMsRUFBRTBDLGlDQUFPLEVBQUUsbUNBQUU7SUFBYSxPQUFPM0M7QUFBUyxDQUFDO0FBQUEsa0dBQUM7S0FDckYsRUFBc0ZBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbW9iaWxlLy4vbm9kZV9tb2R1bGVzL0BsZWljaHRnZXdpY2h0L2lwLWNvZGVjL2luZGV4LmNqcz9jMGMzIl0sInNvdXJjZXNDb250ZW50IjpbIi8vIEdFTkVSQVRFRCBGSUxFLiBETyBOT1QgRURJVC5cbnZhciBpcENvZGVjID0gKGZ1bmN0aW9uKGV4cG9ydHMpIHtcbiAgXCJ1c2Ugc3RyaWN0XCI7XG4gIFxuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgICB2YWx1ZTogdHJ1ZVxuICB9KTtcbiAgZXhwb3J0cy5kZWNvZGUgPSBkZWNvZGU7XG4gIGV4cG9ydHMuZW5jb2RlID0gZW5jb2RlO1xuICBleHBvcnRzLmZhbWlseU9mID0gZmFtaWx5T2Y7XG4gIGV4cG9ydHMubmFtZSA9IHZvaWQgMDtcbiAgZXhwb3J0cy5zaXplT2YgPSBzaXplT2Y7XG4gIGV4cG9ydHMudjYgPSBleHBvcnRzLnY0ID0gdm9pZCAwO1xuICBjb25zdCB2NFJlZ2V4ID0gL14oXFxkezEsM31cXC4pezMsM31cXGR7MSwzfSQvO1xuICBjb25zdCB2NFNpemUgPSA0O1xuICBjb25zdCB2NlJlZ2V4ID0gL14oOjopPygoKFxcZHsxLDN9XFwuKXszfShcXGR7MSwzfSl7MX0pPyhbMC05YS1mXSl7MCw0fTp7MCwyfSl7MSw4fSg6Oik/JC9pO1xuICBjb25zdCB2NlNpemUgPSAxNjtcbiAgY29uc3QgdjQgPSB7XG4gICAgbmFtZTogJ3Y0JyxcbiAgICBzaXplOiB2NFNpemUsXG4gICAgaXNGb3JtYXQ6IGlwID0+IHY0UmVnZXgudGVzdChpcCksXG4gIFxuICAgIGVuY29kZShpcCwgYnVmZiwgb2Zmc2V0KSB7XG4gICAgICBvZmZzZXQgPSB+fm9mZnNldDtcbiAgICAgIGJ1ZmYgPSBidWZmIHx8IG5ldyBVaW50OEFycmF5KG9mZnNldCArIHY0U2l6ZSk7XG4gICAgICBjb25zdCBtYXggPSBpcC5sZW5ndGg7XG4gICAgICBsZXQgbiA9IDA7XG4gIFxuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBtYXg7KSB7XG4gICAgICAgIGNvbnN0IGMgPSBpcC5jaGFyQ29kZUF0KGkrKyk7XG4gIFxuICAgICAgICBpZiAoYyA9PT0gNDYpIHtcbiAgICAgICAgICAvLyBcIi5cIlxuICAgICAgICAgIGJ1ZmZbb2Zmc2V0KytdID0gbjtcbiAgICAgICAgICBuID0gMDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBuID0gbiAqIDEwICsgKGMgLSA0OCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgXG4gICAgICBidWZmW29mZnNldF0gPSBuO1xuICAgICAgcmV0dXJuIGJ1ZmY7XG4gICAgfSxcbiAgXG4gICAgZGVjb2RlKGJ1ZmYsIG9mZnNldCkge1xuICAgICAgb2Zmc2V0ID0gfn5vZmZzZXQ7XG4gICAgICByZXR1cm4gYCR7YnVmZltvZmZzZXQrK119LiR7YnVmZltvZmZzZXQrK119LiR7YnVmZltvZmZzZXQrK119LiR7YnVmZltvZmZzZXRdfWA7XG4gICAgfVxuICBcbiAgfTtcbiAgZXhwb3J0cy52NCA9IHY0O1xuICBjb25zdCB2NiA9IHtcbiAgICBuYW1lOiAndjYnLFxuICAgIHNpemU6IHY2U2l6ZSxcbiAgICBpc0Zvcm1hdDogaXAgPT4gaXAubGVuZ3RoID4gMCAmJiB2NlJlZ2V4LnRlc3QoaXApLFxuICBcbiAgICBlbmNvZGUoaXAsIGJ1ZmYsIG9mZnNldCkge1xuICAgICAgb2Zmc2V0ID0gfn5vZmZzZXQ7XG4gICAgICBsZXQgZW5kID0gb2Zmc2V0ICsgdjZTaXplO1xuICAgICAgbGV0IGZpbGwgPSAtMTtcbiAgICAgIGxldCBoZXhOID0gMDtcbiAgICAgIGxldCBkZWNOID0gMDtcbiAgICAgIGxldCBwcmV2Q29sb24gPSB0cnVlO1xuICAgICAgbGV0IHVzZURlYyA9IGZhbHNlO1xuICAgICAgYnVmZiA9IGJ1ZmYgfHwgbmV3IFVpbnQ4QXJyYXkob2Zmc2V0ICsgdjZTaXplKTsgLy8gTm90ZTogVGhpcyBhbGdvcml0aG0gbmVlZHMgdG8gY2hlY2sgaWYgdGhlIG9mZnNldFxuICAgICAgLy8gY291bGQgZXhjZWVkIHRoZSBidWZmZXIgYm91bmRhcmllcyBhcyBpdCBzdXBwb3J0c1xuICAgICAgLy8gbm9uLXN0YW5kYXJkIGNvbXBsaWFudCBlbmNvZGluZ3MgdGhhdCBtYXkgZ28gYmV5b25kXG4gICAgICAvLyB0aGUgYm91bmRhcnkgbGltaXRzLiBpZiAob2Zmc2V0IDwgZW5kKSBjaGVja3Mgc2hvdWxkXG4gICAgICAvLyBub3QgYmUgbmVjZXNzYXJ5Li4uXG4gIFxuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBpcC5sZW5ndGg7IGkrKykge1xuICAgICAgICBsZXQgYyA9IGlwLmNoYXJDb2RlQXQoaSk7XG4gIFxuICAgICAgICBpZiAoYyA9PT0gNTgpIHtcbiAgICAgICAgICAvLyA6XG4gICAgICAgICAgaWYgKHByZXZDb2xvbikge1xuICAgICAgICAgICAgaWYgKGZpbGwgIT09IC0xKSB7XG4gICAgICAgICAgICAgIC8vIE5vdCBTdGFuZGFyZCEgKHN0YW5kYXJkIGRvZXNuJ3QgYWxsb3cgbXVsdGlwbGUgOjopXG4gICAgICAgICAgICAgIC8vIFdlIG5lZWQgdG8gdHJlYXRcbiAgICAgICAgICAgICAgaWYgKG9mZnNldCA8IGVuZCkgYnVmZltvZmZzZXRdID0gMDtcbiAgICAgICAgICAgICAgaWYgKG9mZnNldCA8IGVuZCAtIDEpIGJ1ZmZbb2Zmc2V0ICsgMV0gPSAwO1xuICAgICAgICAgICAgICBvZmZzZXQgKz0gMjtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAob2Zmc2V0IDwgZW5kKSB7XG4gICAgICAgICAgICAgIC8vIDo6IGluIHRoZSBtaWRkbGVcbiAgICAgICAgICAgICAgZmlsbCA9IG9mZnNldDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gOiBlbmRzIHRoZSBwcmV2aW91cyBudW1iZXJcbiAgICAgICAgICAgIGlmICh1c2VEZWMgPT09IHRydWUpIHtcbiAgICAgICAgICAgICAgLy8gTm9uLXN0YW5kYXJkISAoaXB2NCBzaG91bGQgYmUgYXQgZW5kIG9ubHkpXG4gICAgICAgICAgICAgIC8vIEEgaXB2NCBhZGRyZXNzIHNob3VsZCBub3QgYmUgZm91bmQgYW55d2hlcmUgZWxzZSBidXQgYXRcbiAgICAgICAgICAgICAgLy8gdGhlIGVuZC4gVGhpcyBjb2RlYyBhbHNvIHN1cHBvcnQgcHV0dGluZyBjaGFyYWN0ZXJzXG4gICAgICAgICAgICAgIC8vIGFmdGVyIHRoZSBpcHY0IGFkZHJlc3MuLlxuICAgICAgICAgICAgICBpZiAob2Zmc2V0IDwgZW5kKSBidWZmW29mZnNldF0gPSBkZWNOO1xuICAgICAgICAgICAgICBvZmZzZXQrKztcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIGlmIChvZmZzZXQgPCBlbmQpIGJ1ZmZbb2Zmc2V0XSA9IGhleE4gPj4gODtcbiAgICAgICAgICAgICAgaWYgKG9mZnNldCA8IGVuZCAtIDEpIGJ1ZmZbb2Zmc2V0ICsgMV0gPSBoZXhOICYgMHhmZjtcbiAgICAgICAgICAgICAgb2Zmc2V0ICs9IDI7XG4gICAgICAgICAgICB9XG4gIFxuICAgICAgICAgICAgaGV4TiA9IDA7XG4gICAgICAgICAgICBkZWNOID0gMDtcbiAgICAgICAgICB9XG4gIFxuICAgICAgICAgIHByZXZDb2xvbiA9IHRydWU7XG4gICAgICAgICAgdXNlRGVjID0gZmFsc2U7XG4gICAgICAgIH0gZWxzZSBpZiAoYyA9PT0gNDYpIHtcbiAgICAgICAgICAvLyAuIGluZGljYXRlcyBJUFY0IG5vdGF0aW9uXG4gICAgICAgICAgaWYgKG9mZnNldCA8IGVuZCkgYnVmZltvZmZzZXRdID0gZGVjTjtcbiAgICAgICAgICBvZmZzZXQrKztcbiAgICAgICAgICBkZWNOID0gMDtcbiAgICAgICAgICBoZXhOID0gMDtcbiAgICAgICAgICBwcmV2Q29sb24gPSBmYWxzZTtcbiAgICAgICAgICB1c2VEZWMgPSB0cnVlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHByZXZDb2xvbiA9IGZhbHNlO1xuICBcbiAgICAgICAgICBpZiAoYyA+PSA5Nykge1xuICAgICAgICAgICAgYyAtPSA4NzsgLy8gYS1mIC4uLiA5N34xMDIgLTg3ID0+IDEwfjE1XG4gICAgICAgICAgfSBlbHNlIGlmIChjID49IDY1KSB7XG4gICAgICAgICAgICBjIC09IDU1OyAvLyBBLUYgLi4uIDY1fjcwIC01NSA9PiAxMH4xNVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjIC09IDQ4OyAvLyAwLTkgLi4uIHN0YXJ0aW5nIGZyb20gY2hhckNvZGUgNDhcbiAgXG4gICAgICAgICAgICBkZWNOID0gZGVjTiAqIDEwICsgYztcbiAgICAgICAgICB9IC8vIFdlIGRvbid0IGtub3cgeWV0IGlmIGl0cyBhIGRlYyBvciBoZXggbnVtYmVyXG4gIFxuICBcbiAgICAgICAgICBoZXhOID0gKGhleE4gPDwgNCkgKyBjO1xuICAgICAgICB9XG4gICAgICB9XG4gIFxuICAgICAgaWYgKHByZXZDb2xvbiA9PT0gZmFsc2UpIHtcbiAgICAgICAgLy8gQ29tbWl0aW5nIGxhc3QgbnVtYmVyXG4gICAgICAgIGlmICh1c2VEZWMgPT09IHRydWUpIHtcbiAgICAgICAgICBpZiAob2Zmc2V0IDwgZW5kKSBidWZmW29mZnNldF0gPSBkZWNOO1xuICAgICAgICAgIG9mZnNldCsrO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGlmIChvZmZzZXQgPCBlbmQpIGJ1ZmZbb2Zmc2V0XSA9IGhleE4gPj4gODtcbiAgICAgICAgICBpZiAob2Zmc2V0IDwgZW5kIC0gMSkgYnVmZltvZmZzZXQgKyAxXSA9IGhleE4gJiAweGZmO1xuICAgICAgICAgIG9mZnNldCArPSAyO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKGZpbGwgPT09IDApIHtcbiAgICAgICAgLy8gTm90IFN0YW5kYXJkISAoc3RhbmRhcmQgZG9lc24ndCBhbGxvdyBtdWx0aXBsZSA6OilcbiAgICAgICAgLy8gVGhpcyBtZWFucyB0aGF0IGEgOiB3YXMgZm91bmQgYXQgdGhlIHN0YXJ0IEFORCBlbmQgd2hpY2ggbWVhbnMgdGhlXG4gICAgICAgIC8vIGVuZCBuZWVkcyB0byBiZSB0cmVhdGVkIGFzIDAgZW50cnkuLi5cbiAgICAgICAgaWYgKG9mZnNldCA8IGVuZCkgYnVmZltvZmZzZXRdID0gMDtcbiAgICAgICAgaWYgKG9mZnNldCA8IGVuZCAtIDEpIGJ1ZmZbb2Zmc2V0ICsgMV0gPSAwO1xuICAgICAgICBvZmZzZXQgKz0gMjtcbiAgICAgIH0gZWxzZSBpZiAoZmlsbCAhPT0gLTEpIHtcbiAgICAgICAgLy8gTm9uLXN0YW5kYXJkISAoc3RhbmRhcmQgZG9lbnMndCBhbGxvdyBtdWx0aXBsZSA6OilcbiAgICAgICAgLy8gSGVyZSB3ZSBmaW5kIHRoYXQgdGhlcmUgaGFzIGJlZW4gYSA6OiBzb21ld2hlcmUgaW4gdGhlIG1pZGRsZVxuICAgICAgICAvLyBhbmQgdGhlIGVuZC4gVG8gdHJlYXQgdGhlIGVuZCB3aXRoIHByaW9yaXR5IHdlIG5lZWQgdG8gbW92ZSBhbGxcbiAgICAgICAgLy8gd3JpdHRlbiBkYXRhIHR3byBieXRlcyB0byB0aGUgcmlnaHQuXG4gICAgICAgIG9mZnNldCArPSAyO1xuICBcbiAgICAgICAgZm9yIChsZXQgaSA9IE1hdGgubWluKG9mZnNldCAtIDEsIGVuZCAtIDEpOyBpID49IGZpbGwgKyAyOyBpLS0pIHtcbiAgICAgICAgICBidWZmW2ldID0gYnVmZltpIC0gMl07XG4gICAgICAgIH1cbiAgXG4gICAgICAgIGJ1ZmZbZmlsbF0gPSAwO1xuICAgICAgICBidWZmW2ZpbGwgKyAxXSA9IDA7XG4gICAgICAgIGZpbGwgPSBvZmZzZXQ7XG4gICAgICB9XG4gIFxuICAgICAgaWYgKGZpbGwgIT09IG9mZnNldCAmJiBmaWxsICE9PSAtMSkge1xuICAgICAgICAvLyBNb3ZlIHRoZSB3cml0dGVuIG51bWJlcnMgdG8gdGhlIGVuZCB3aGlsZSBmaWxsaW5nIHRoZSBldmVyeXRoaW5nXG4gICAgICAgIC8vIFwiZmlsbFwiIHRvIHRoZSBieXRlcyB3aXRoIHplcm9zLlxuICAgICAgICBpZiAob2Zmc2V0ID4gZW5kIC0gMikge1xuICAgICAgICAgIC8vIE5vbiBTdGFuZGFyZCBzdXBwb3J0LCB3aGVuIHRoZSBjdXJzb3IgZXhjZWVkcyBib3VuZHMuXG4gICAgICAgICAgb2Zmc2V0ID0gZW5kIC0gMjtcbiAgICAgICAgfVxuICBcbiAgICAgICAgd2hpbGUgKGVuZCA+IGZpbGwpIHtcbiAgICAgICAgICBidWZmWy0tZW5kXSA9IG9mZnNldCA8IGVuZCAmJiBvZmZzZXQgPiBmaWxsID8gYnVmZlstLW9mZnNldF0gOiAwO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBGaWxsIHRoZSByZXN0IHdpdGggemVyb3NcbiAgICAgICAgd2hpbGUgKG9mZnNldCA8IGVuZCkge1xuICAgICAgICAgIGJ1ZmZbb2Zmc2V0KytdID0gMDtcbiAgICAgICAgfVxuICAgICAgfVxuICBcbiAgICAgIHJldHVybiBidWZmO1xuICAgIH0sXG4gIFxuICAgIGRlY29kZShidWZmLCBvZmZzZXQpIHtcbiAgICAgIG9mZnNldCA9IH5+b2Zmc2V0O1xuICAgICAgbGV0IHJlc3VsdCA9ICcnO1xuICBcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdjZTaXplOyBpICs9IDIpIHtcbiAgICAgICAgaWYgKGkgIT09IDApIHtcbiAgICAgICAgICByZXN1bHQgKz0gJzonO1xuICAgICAgICB9XG4gIFxuICAgICAgICByZXN1bHQgKz0gKGJ1ZmZbb2Zmc2V0ICsgaV0gPDwgOCB8IGJ1ZmZbb2Zmc2V0ICsgaSArIDFdKS50b1N0cmluZygxNik7XG4gICAgICB9XG4gIFxuICAgICAgcmV0dXJuIHJlc3VsdC5yZXBsYWNlKC8oXnw6KTAoOjApKjowKDp8JCkvLCAnJDE6OiQzJykucmVwbGFjZSgvOnszLDR9LywgJzo6Jyk7XG4gICAgfVxuICBcbiAgfTtcbiAgZXhwb3J0cy52NiA9IHY2O1xuICBjb25zdCBuYW1lID0gJ2lwJztcbiAgZXhwb3J0cy5uYW1lID0gbmFtZTtcbiAgXG4gIGZ1bmN0aW9uIHNpemVPZihpcCkge1xuICAgIGlmICh2NC5pc0Zvcm1hdChpcCkpIHJldHVybiB2NC5zaXplO1xuICAgIGlmICh2Ni5pc0Zvcm1hdChpcCkpIHJldHVybiB2Ni5zaXplO1xuICAgIHRocm93IEVycm9yKGBJbnZhbGlkIGlwIGFkZHJlc3M6ICR7aXB9YCk7XG4gIH1cbiAgXG4gIGZ1bmN0aW9uIGZhbWlseU9mKHN0cmluZykge1xuICAgIHJldHVybiBzaXplT2Yoc3RyaW5nKSA9PT0gdjQuc2l6ZSA/IDEgOiAyO1xuICB9XG4gIFxuICBmdW5jdGlvbiBlbmNvZGUoaXAsIGJ1ZmYsIG9mZnNldCkge1xuICAgIG9mZnNldCA9IH5+b2Zmc2V0O1xuICAgIGNvbnN0IHNpemUgPSBzaXplT2YoaXApO1xuICBcbiAgICBpZiAodHlwZW9mIGJ1ZmYgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIGJ1ZmYgPSBidWZmKG9mZnNldCArIHNpemUpO1xuICAgIH1cbiAgXG4gICAgaWYgKHNpemUgPT09IHY0LnNpemUpIHtcbiAgICAgIHJldHVybiB2NC5lbmNvZGUoaXAsIGJ1ZmYsIG9mZnNldCk7XG4gICAgfVxuICBcbiAgICByZXR1cm4gdjYuZW5jb2RlKGlwLCBidWZmLCBvZmZzZXQpO1xuICB9XG4gIFxuICBmdW5jdGlvbiBkZWNvZGUoYnVmZiwgb2Zmc2V0LCBsZW5ndGgpIHtcbiAgICBvZmZzZXQgPSB+fm9mZnNldDtcbiAgICBsZW5ndGggPSBsZW5ndGggfHwgYnVmZi5sZW5ndGggLSBvZmZzZXQ7XG4gIFxuICAgIGlmIChsZW5ndGggPT09IHY0LnNpemUpIHtcbiAgICAgIHJldHVybiB2NC5kZWNvZGUoYnVmZiwgb2Zmc2V0LCBsZW5ndGgpO1xuICAgIH1cbiAgXG4gICAgaWYgKGxlbmd0aCA9PT0gdjYuc2l6ZSkge1xuICAgICAgcmV0dXJuIHY2LmRlY29kZShidWZmLCBvZmZzZXQsIGxlbmd0aCk7XG4gICAgfVxuICBcbiAgICB0aHJvdyBFcnJvcihgSW52YWxpZCBidWZmZXIgc2l6ZSBuZWVkcyB0byBiZSAke3Y0LnNpemV9IGZvciB2NCBvciAke3Y2LnNpemV9IGZvciB2Ni5gKTtcbiAgfVxuICByZXR1cm4gXCJkZWZhdWx0XCIgaW4gZXhwb3J0cyA/IGV4cG9ydHMuZGVmYXVsdCA6IGV4cG9ydHM7XG59KSh7fSk7XG5pZiAodHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kKSBkZWZpbmUoW10sIGZ1bmN0aW9uKCkgeyByZXR1cm4gaXBDb2RlYzsgfSk7XG5lbHNlIGlmICh0eXBlb2YgbW9kdWxlID09PSAnb2JqZWN0JyAmJiB0eXBlb2YgZXhwb3J0cz09PSdvYmplY3QnKSBtb2R1bGUuZXhwb3J0cyA9IGlwQ29kZWM7XG4iXSwibmFtZXMiOlsiaXBDb2RlYyIsImV4cG9ydHMiLCJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0eSIsInZhbHVlIiwiZGVjb2RlIiwiZW5jb2RlIiwiZmFtaWx5T2YiLCJuYW1lIiwic2l6ZU9mIiwidjYiLCJ2NCIsInY0UmVnZXgiLCJ2NFNpemUiLCJ2NlJlZ2V4IiwidjZTaXplIiwic2l6ZSIsImlzRm9ybWF0IiwiaXAiLCJ0ZXN0IiwiYnVmZiIsIm9mZnNldCIsIlVpbnQ4QXJyYXkiLCJtYXgiLCJsZW5ndGgiLCJuIiwiaSIsImMiLCJjaGFyQ29kZUF0IiwiZW5kIiwiZmlsbCIsImhleE4iLCJkZWNOIiwicHJldkNvbG9uIiwidXNlRGVjIiwiTWF0aCIsIm1pbiIsInJlc3VsdCIsInRvU3RyaW5nIiwicmVwbGFjZSIsIkVycm9yIiwic3RyaW5nIiwiZGVmYXVsdCIsImRlZmluZSIsImFtZCIsIm1vZHVsZSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@leichtgewicht/ip-codec/index.cjs\n");

/***/ })

};
;